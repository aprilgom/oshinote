/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/fabric/dist/fabric.js":
/*!********************************************!*\
  !*** ./node_modules/fabric/dist/fabric.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/* build: `node build.js modules=ALL exclude=gestures,accessors,erasing requirejs minifier=uglifyjs` */ /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */var fabric=fabric||{version:'4.6.0'};if(true){exports.fabric=fabric;}/* _AMD_START_ */else {}/* _AMD_END_ */if(typeof document!=='undefined'&&typeof window!=='undefined'){if(document instanceof(typeof HTMLDocument!=='undefined'?HTMLDocument:Document)){fabric.document=document;}else{fabric.document=document.implementation.createHTMLDocument('');}fabric.window=window;}else{// assume we're running under node.js when document/window are not present\nvar jsdom=__webpack_require__(/*! jsdom */ \"?7b10\");var virtualWindow=new jsdom.JSDOM(decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),{features:{FetchExternalResources:['img']},resources:'usable'}).window;fabric.document=virtualWindow.document;fabric.jsdomImplForWrapper=(__webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ \"?6799\").implForWrapper);fabric.nodeCanvas=(__webpack_require__(/*! jsdom/lib/jsdom/utils */ \"?9748\").Canvas);fabric.window=virtualWindow;DOMParser=fabric.window.DOMParser;}/**\n * True when in environment that supports touch events\n * @type boolean\n */fabric.isTouchSupported='ontouchstart'in fabric.window||'ontouchstart'in fabric.document||fabric.window&&fabric.window.navigator&&fabric.window.navigator.maxTouchPoints>0;/**\n * True when in environment that's probably Node.js\n * @type boolean\n */fabric.isLikelyNode=typeof Buffer!=='undefined'&&typeof window==='undefined';/* _FROM_SVG_START_ */ /**\n * Attributes parsed from all SVG elements\n * @type array\n */fabric.SHARED_ATTRIBUTES=['display','transform','fill','fill-opacity','fill-rule','opacity','stroke','stroke-dasharray','stroke-linecap','stroke-dashoffset','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','id','paint-order','vector-effect','instantiated_by_use','clip-path'];/* _FROM_SVG_END_ */ /**\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\n */fabric.DPI=96;fabric.reNum='(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)';fabric.commaWsp='(?:\\\\s+,?\\\\s*|,\\\\s*)';fabric.rePathCommand=/([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:[eE][-+]?\\d+)?)/ig;fabric.reNonWord=/[ \\n\\.,;!\\?\\-]/;fabric.fontPaths={};fabric.iMatrix=[1,0,0,1,0,0];fabric.svgNS='http://www.w3.org/2000/svg';/**\n * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.\n * @since 1.7.14\n * @type Number\n * @default\n */fabric.perfLimitSizeTotal=2097152;/**\n * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000\n * @since 1.7.14\n * @type Number\n * @default\n */fabric.maxCacheSideLimit=4096;/**\n * Lowest pixel limit for cache canvases, set at 256PX\n * @since 1.7.14\n * @type Number\n * @default\n */fabric.minCacheSideLimit=256;/**\n * Cache Object for widths of chars in text rendering.\n */fabric.charWidthsCache={};/**\n * if webgl is enabled and available, textureSize will determine the size\n * of the canvas backend\n * @since 2.0.0\n * @type Number\n * @default\n */fabric.textureSize=2048;/**\n * When 'true', style information is not retained when copy/pasting text, making\n * pasted text use destination style.\n * Defaults to 'false'.\n * @type Boolean\n * @default\n */fabric.disableStyleCopyPaste=false;/**\n * Enable webgl for filtering picture is available\n * A filtering backend will be initialized, this will both take memory and\n * time since a default 2048x2048 canvas will be created for the gl context\n * @since 2.0.0\n * @type Boolean\n * @default\n */fabric.enableGLFiltering=true;/**\n * Device Pixel Ratio\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\n */fabric.devicePixelRatio=fabric.window.devicePixelRatio||fabric.window.webkitDevicePixelRatio||fabric.window.mozDevicePixelRatio||1;/**\n * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,\n * which is unitless and not rendered equally across browsers.\n *\n * Values that work quite well (as of October 2017) are:\n * - Chrome: 1.5\n * - Edge: 1.75\n * - Firefox: 0.9\n * - Safari: 0.95\n *\n * @since 2.0.0\n * @type Number\n * @default 1\n */fabric.browserShadowBlurConstant=1;/**\n * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.\n * It was an internal variable, is accessible since version 2.3.4\n */fabric.arcToSegmentsCache={};/**\n * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.\n * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing\n * you do not get any speed benefit and you get a big object in memory.\n * The object was a private variable before, while now is appended to the lib so that you have access to it and you\n * can eventually clear it.\n * It was an internal variable, is accessible since version 2.3.4\n */fabric.boundsOfCurveCache={};/**\n * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better\n * @default true\n */fabric.cachesBoundsOfCurve=true;/**\n * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on\n * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true\n * this has to be set before instantiating the filtering backend ( before filtering the first image )\n * @type Boolean\n * @default false\n */fabric.forceGLPutImageData=false;fabric.initFilterBackend=function(){if(fabric.enableGLFiltering&&fabric.isWebglSupported&&fabric.isWebglSupported(fabric.textureSize)){console.log('max texture size: '+fabric.maxTextureSize);return new fabric.WebglFilterBackend({tileSize:fabric.textureSize});}else if(fabric.Canvas2dFilterBackend){return new fabric.Canvas2dFilterBackend();}};if(typeof document!=='undefined'&&typeof window!=='undefined'){// ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)\nwindow.fabric=fabric;}(function(){/**\n   * @private\n   * @param {String} eventName\n   * @param {Function} handler\n   */function _removeEventListener(eventName,handler){if(!this.__eventListeners[eventName]){return;}var eventListener=this.__eventListeners[eventName];if(handler){eventListener[eventListener.indexOf(handler)]=false;}else{fabric.util.array.fill(eventListener,false);}}/**\n   * Observes specified event\n   * @memberOf fabric.Observable\n   * @alias on\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\n   * @return {Self} thisArg\n   * @chainable\n   */function on(eventName,handler){if(!this.__eventListeners){this.__eventListeners={};}// one object with key/value pairs was passed\nif(arguments.length===1){for(var prop in eventName){this.on(prop,eventName[prop]);}}else{if(!this.__eventListeners[eventName]){this.__eventListeners[eventName]=[];}this.__eventListeners[eventName].push(handler);}return this;}function _once(eventName,handler){var _handler=function(){handler.apply(this,arguments);this.off(eventName,_handler);}.bind(this);this.on(eventName,_handler);}function once(eventName,handler){// one object with key/value pairs was passed\nif(arguments.length===1){for(var prop in eventName){_once.call(this,prop,eventName[prop]);}}else{_once.call(this,eventName,handler);}return this;}/**\n   * Stops event observing for a particular event handler. Calling this method\n   * without arguments removes all handlers for all events\n   * @memberOf fabric.Observable\n   * @alias off\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function to be deleted from EventListeners\n   * @return {Self} thisArg\n   * @chainable\n   */function off(eventName,handler){if(!this.__eventListeners){return this;}// remove all key/value pairs (event name -> event handler)\nif(arguments.length===0){for(eventName in this.__eventListeners){_removeEventListener.call(this,eventName);}}// one object with key/value pairs was passed\nelse if(arguments.length===1&&typeof arguments[0]==='object'){for(var prop in eventName){_removeEventListener.call(this,prop,eventName[prop]);}}else{_removeEventListener.call(this,eventName,handler);}return this;}/**\n   * Fires event with an optional options object\n   * @memberOf fabric.Observable\n   * @param {String} eventName Event name to fire\n   * @param {Object} [options] Options object\n   * @return {Self} thisArg\n   * @chainable\n   */function fire(eventName,options){if(!this.__eventListeners){return this;}var listenersForEvent=this.__eventListeners[eventName];if(!listenersForEvent){return this;}for(var i=0,len=listenersForEvent.length;i<len;i++){listenersForEvent[i]&&listenersForEvent[i].call(this,options||{});}this.__eventListeners[eventName]=listenersForEvent.filter(function(value){return value!==false;});return this;}/**\n   * @namespace fabric.Observable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}\n   * @see {@link http://fabricjs.com/events|Events demo}\n   */fabric.Observable={fire:fire,on:on,once:once,off:off};})();/**\n * @namespace fabric.Collection\n */fabric.Collection={_objects:[],/**\n   * Adds objects to collection, Canvas or Group, then renders canvas\n   * (if `renderOnAddRemove` is not `false`).\n   * in case of Group no changes to bounding box are made.\n   * Objects should be instances of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the add method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */add:function(){this._objects.push.apply(this._objects,arguments);if(this._onObjectAdded){for(var i=0,length=arguments.length;i<length;i++){this._onObjectAdded(arguments[i]);}}this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * An object should be an instance of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the insertAt method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {Object} object Object to insert\n   * @param {Number} index Index to insert object at\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\n   * @return {Self} thisArg\n   * @chainable\n   */insertAt:function(object,index,nonSplicing){var objects=this._objects;if(nonSplicing){objects[index]=object;}else{objects.splice(index,0,object);}this._onObjectAdded&&this._onObjectAdded(object);this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */remove:function(){var objects=this._objects,index,somethingRemoved=false;for(var i=0,length=arguments.length;i<length;i++){index=objects.indexOf(arguments[i]);// only call onObjectRemoved if an object was actually removed\nif(index!==-1){somethingRemoved=true;objects.splice(index,1);this._onObjectRemoved&&this._onObjectRemoved(arguments[i]);}}this.renderOnAddRemove&&somethingRemoved&&this.requestRenderAll();return this;},/**\n   * Executes given function for each object in this group\n   * @param {Function} callback\n   *                   Callback invoked with current object as first argument,\n   *                   index - as second and an array of all objects - as third.\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\n   *                   when no `context` argument is given\n   *\n   * @param {Object} context Context (aka thisObject)\n   * @return {Self} thisArg\n   * @chainable\n   */forEachObject:function(callback,context){var objects=this.getObjects();for(var i=0,len=objects.length;i<len;i++){callback.call(context,objects[i],i,objects);}return this;},/**\n   * Returns an array of children objects of this instance\n   * Type parameter introduced in 1.3.10\n   * since 2.3.5 this method return always a COPY of the array;\n   * @param {String} [type] When specified, only objects of this type are returned\n   * @return {Array}\n   */getObjects:function(type){if(typeof type==='undefined'){return this._objects.concat();}return this._objects.filter(function(o){return o.type===type;});},/**\n   * Returns object at specified index\n   * @param {Number} index\n   * @return {Self} thisArg\n   */item:function(index){return this._objects[index];},/**\n   * Returns true if collection contains no objects\n   * @return {Boolean} true if collection is empty\n   */isEmpty:function(){return this._objects.length===0;},/**\n   * Returns a size of a collection (i.e: length of an array containing its objects)\n   * @return {Number} Collection size\n   */size:function(){return this._objects.length;},/**\n   * Returns true if collection contains an object\n   * @param {Object} object Object to check against\n   * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`\n   * @return {Boolean} `true` if collection contains an object\n   */contains:function(object,deep){if(this._objects.indexOf(object)>-1){return true;}else if(deep){return this._objects.some(function(obj){return typeof obj.contains==='function'&&obj.contains(object,true);});}return false;},/**\n   * Returns number representation of a collection complexity\n   * @return {Number} complexity\n   */complexity:function(){return this._objects.reduce(function(memo,current){memo+=current.complexity?current.complexity():0;return memo;},0);}};/**\n * @namespace fabric.CommonMethods\n */fabric.CommonMethods={/**\n   * Sets object's properties from options\n   * @param {Object} [options] Options object\n   */_setOptions:function(options){for(var prop in options){this.set(prop,options[prop]);}},/**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Gradient to\n   */_initGradient:function(filler,property){if(filler&&filler.colorStops&&!(filler instanceof fabric.Gradient)){this.set(property,new fabric.Gradient(filler));}},/**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Pattern to\n   * @param {Function} [callback] callback to invoke after pattern load\n   */_initPattern:function(filler,property,callback){if(filler&&filler.source&&!(filler instanceof fabric.Pattern)){this.set(property,new fabric.Pattern(filler,callback));}else{callback&&callback();}},/**\n   * @private\n   */_setObject:function(obj){for(var prop in obj){this._set(prop,obj[prop]);}},/**\n   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n   * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */set:function(key,value){if(typeof key==='object'){this._setObject(key);}else{this._set(key,value);}return this;},_set:function(key,value){this[key]=value;},/**\n   * Toggles specified property from `true` to `false` or from `false` to `true`\n   * @param {String} property Property to toggle\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */toggle:function(property){var value=this.get(property);if(typeof value==='boolean'){this.set(property,!value);}return this;},/**\n   * Basic getter\n   * @param {String} property Property name\n   * @return {*} value of a property\n   */get:function(property){return this[property];}};(function(global){var sqrt=Math.sqrt,atan2=Math.atan2,pow=Math.pow,PiBy180=Math.PI/180,PiBy2=Math.PI/2;/**\n   * @namespace fabric.util\n   */fabric.util={/**\n     * Calculate the cos of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */cos:function(angle){if(angle===0){return 1;}if(angle<0){// cos(a) = cos(-a)\nangle=-angle;}var angleSlice=angle/PiBy2;switch(angleSlice){case 1:case 3:return 0;case 2:return-1;}return Math.cos(angle);},/**\n     * Calculate the sin of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */sin:function(angle){if(angle===0){return 0;}var angleSlice=angle/PiBy2,sign=1;if(angle<0){// sin(-a) = -sin(a)\nsign=-1;}switch(angleSlice){case 1:return sign;case 2:return 0;case 3:return-sign;}return Math.sin(angle);},/**\n     * Removes value from an array.\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} array\n     * @param {*} value\n     * @return {Array} original array\n     */removeFromArray:function(array,value){var idx=array.indexOf(value);if(idx!==-1){array.splice(idx,1);}return array;},/**\n     * Returns random number between 2 specified ones.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} min lower limit\n     * @param {Number} max upper limit\n     * @return {Number} random value (between min and max)\n     */getRandomInt:function(min,max){return Math.floor(Math.random()*(max-min+1))+min;},/**\n     * Transforms degrees to radians.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} degrees value in degrees\n     * @return {Number} value in radians\n     */degreesToRadians:function(degrees){return degrees*PiBy180;},/**\n     * Transforms radians to degrees.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} radians value in radians\n     * @return {Number} value in degrees\n     */radiansToDegrees:function(radians){return radians/PiBy180;},/**\n     * Rotates `point` around `origin` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {fabric.Point} point The point to rotate\n     * @param {fabric.Point} origin The origin of the rotation\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {fabric.Point} The new rotated point\n     */rotatePoint:function(point,origin,radians){var newPoint=new fabric.Point(point.x-origin.x,point.y-origin.y),v=fabric.util.rotateVector(newPoint,radians);return new fabric.Point(v.x,v.y).addEquals(origin);},/**\n     * Rotates `vector` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} vector The vector to rotate (x and y)\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {Object} The new rotated point\n     */rotateVector:function(vector,radians){var sin=fabric.util.sin(radians),cos=fabric.util.cos(radians),rx=vector.x*cos-vector.y*sin,ry=vector.x*sin+vector.y*cos;return{x:rx,y:ry};},/**\n     * Apply transform t to point p\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Point} p The point to transform\n     * @param  {Array} t The transform\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\n     * @return {fabric.Point} The transformed point\n     */transformPoint:function(p,t,ignoreOffset){if(ignoreOffset){return new fabric.Point(t[0]*p.x+t[2]*p.y,t[1]*p.x+t[3]*p.y);}return new fabric.Point(t[0]*p.x+t[2]*p.y+t[4],t[1]*p.x+t[3]*p.y+t[5]);},/**\n     * Returns coordinates of points's bounding rectangle (left, top, width, height)\n     * @param {Array} points 4 points array\n     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix\n     * @return {Object} Object with left, top, width, height properties\n     */makeBoundingBoxFromPoints:function(points,transform){if(transform){for(var i=0;i<points.length;i++){points[i]=fabric.util.transformPoint(points[i],transform);}}var xPoints=[points[0].x,points[1].x,points[2].x,points[3].x],minX=fabric.util.array.min(xPoints),maxX=fabric.util.array.max(xPoints),width=maxX-minX,yPoints=[points[0].y,points[1].y,points[2].y,points[3].y],minY=fabric.util.array.min(yPoints),maxY=fabric.util.array.max(yPoints),height=maxY-minY;return{left:minX,top:minY,width:width,height:height};},/**\n     * Invert transformation t\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} t The transform\n     * @return {Array} The inverted transform\n     */invertTransform:function(t){var a=1/(t[0]*t[3]-t[1]*t[2]),r=[a*t[3],-a*t[1],-a*t[2],a*t[0]],o=fabric.util.transformPoint({x:t[4],y:t[5]},r,true);r[4]=-o.x;r[5]=-o.y;return r;},/**\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number|String} number number to operate on\n     * @param {Number} fractionDigits number of fraction digits to \"leave\"\n     * @return {Number}\n     */toFixed:function(number,fractionDigits){return parseFloat(Number(number).toFixed(fractionDigits));},/**\n     * Converts from attribute value to pixel value if applicable.\n     * Returns converted pixels or original value not converted.\n     * @param {Number|String} value number to operate on\n     * @param {Number} fontSize\n     * @return {Number|String}\n     */parseUnit:function(value,fontSize){var unit=/\\D{0,2}$/.exec(value),number=parseFloat(value);if(!fontSize){fontSize=fabric.Text.DEFAULT_SVG_FONT_SIZE;}switch(unit[0]){case'mm':return number*fabric.DPI/25.4;case'cm':return number*fabric.DPI/2.54;case'in':return number*fabric.DPI;case'pt':return number*fabric.DPI/72;// or * 4 / 3\ncase'pc':return number*fabric.DPI/72*12;// or * 16\ncase'em':return number*fontSize;default:return number;}},/**\n     * Function which always returns `false`.\n     * @static\n     * @memberOf fabric.util\n     * @return {Boolean}\n     */falseFunction:function(){return false;},/**\n     * Returns klass \"Class\" object of given namespace\n     * @memberOf fabric.util\n     * @param {String} type Type of object (eg. 'circle')\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @return {Object} klass \"Class\"\n     */getKlass:function(type,namespace){// capitalize first letter only\ntype=fabric.util.string.camelize(type.charAt(0).toUpperCase()+type.slice(1));return fabric.util.resolveNamespace(namespace)[type];},/**\n     * Returns array of attributes for given svg that fabric parses\n     * @memberOf fabric.util\n     * @param {String} type Type of svg element (eg. 'circle')\n     * @return {Array} string names of supported attributes\n     */getSvgAttributes:function(type){var attributes=['instantiated_by_use','style','id','class'];switch(type){case'linearGradient':attributes=attributes.concat(['x1','y1','x2','y2','gradientUnits','gradientTransform']);break;case'radialGradient':attributes=attributes.concat(['gradientUnits','gradientTransform','cx','cy','r','fx','fy','fr']);break;case'stop':attributes=attributes.concat(['offset','stop-color','stop-opacity']);break;}return attributes;},/**\n     * Returns object of given namespace\n     * @memberOf fabric.util\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\n     * @return {Object} Object for given namespace (default fabric)\n     */resolveNamespace:function(namespace){if(!namespace){return fabric;}var parts=namespace.split('.'),len=parts.length,i,obj=global||fabric.window;for(i=0;i<len;++i){obj=obj[parts[i]];}return obj;},/**\n     * Loads image element from given url and passes it to a callback\n     * @memberOf fabric.util\n     * @param {String} url URL representing an image\n     * @param {Function} callback Callback; invoked with loaded image\n     * @param {*} [context] Context to invoke callback in\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\n     */loadImage:function(url,callback,context,crossOrigin){if(!url){callback&&callback.call(context,url);return;}var img=fabric.util.createImage();/** @ignore */var onLoadCallback=function(){callback&&callback.call(context,img,false);img=img.onload=img.onerror=null;};img.onload=onLoadCallback;/** @ignore */img.onerror=function(){fabric.log('Error loading '+img.src);callback&&callback.call(context,null,true);img=img.onload=img.onerror=null;};// data-urls appear to be buggy with crossOrigin\n// https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\n// see https://code.google.com/p/chromium/issues/detail?id=315152\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\n// crossOrigin null is the same as not set.\nif(url.indexOf('data')!==0&&crossOrigin!==undefined&&crossOrigin!==null){img.crossOrigin=crossOrigin;}// IE10 / IE11-Fix: SVG contents from data: URI\n// will only be available if the IMG is present\n// in the DOM (and visible)\nif(url.substring(0,14)==='data:image/svg'){img.onload=null;fabric.util.loadImageInDom(img,onLoadCallback);}img.src=url;},/**\n     * Attaches SVG image with data: URL to the dom\n     * @memberOf fabric.util\n     * @param {Object} img Image object with data:image/svg src\n     * @param {Function} callback Callback; invoked with loaded image\n     * @return {Object} DOM element (div containing the SVG image)\n     */loadImageInDom:function(img,onLoadCallback){var div=fabric.document.createElement('div');div.style.width=div.style.height='1px';div.style.left=div.style.top='-100%';div.style.position='absolute';div.appendChild(img);fabric.document.querySelector('body').appendChild(div);/**\n       * Wrap in function to:\n       *   1. Call existing callback\n       *   2. Cleanup DOM\n       */img.onload=function(){onLoadCallback();div.parentNode.removeChild(div);div=null;};},/**\n     * Creates corresponding fabric instances from their object representations\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} objects Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @param {Function} reviver Method for further parsing of object elements,\n     * called after each fabric object created.\n     */enlivenObjects:function(objects,callback,namespace,reviver){objects=objects||[];var enlivenedObjects=[],numLoadedObjects=0,numTotalObjects=objects.length;function onLoaded(){if(++numLoadedObjects===numTotalObjects){callback&&callback(enlivenedObjects.filter(function(obj){// filter out undefined objects (objects that gave error)\nreturn obj;}));}}if(!numTotalObjects){callback&&callback(enlivenedObjects);return;}objects.forEach(function(o,index){// if sparse array\nif(!o||!o.type){onLoaded();return;}var klass=fabric.util.getKlass(o.type,namespace);klass.fromObject(o,function(obj,error){error||(enlivenedObjects[index]=obj);reviver&&reviver(o,obj,error);onLoaded();});});},/**\n     * Create and wait for loading of patterns\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} patterns Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * called after each fabric object created.\n     */enlivenPatterns:function(patterns,callback){patterns=patterns||[];function onLoaded(){if(++numLoadedPatterns===numPatterns){callback&&callback(enlivenedPatterns);}}var enlivenedPatterns=[],numLoadedPatterns=0,numPatterns=patterns.length;if(!numPatterns){callback&&callback(enlivenedPatterns);return;}patterns.forEach(function(p,index){if(p&&p.source){new fabric.Pattern(p,function(pattern){enlivenedPatterns[index]=pattern;onLoaded();});}else{enlivenedPatterns[index]=p;onLoaded();}});},/**\n     * Groups SVG elements (usually those retrieved from SVG document)\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} elements SVG elements to group\n     * @param {Object} [options] Options object\n     * @param {String} path Value to set sourcePath to\n     * @return {fabric.Object|fabric.Group}\n     */groupSVGElements:function(elements,options,path){var object;if(elements&&elements.length===1){return elements[0];}if(options){if(options.width&&options.height){options.centerPoint={x:options.width/2,y:options.height/2};}else{delete options.width;delete options.height;}}object=new fabric.Group(elements,options);if(typeof path!=='undefined'){object.sourcePath=path;}return object;},/**\n     * Populates an object with properties of another object\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} source Source object\n     * @param {Object} destination Destination object\n     * @return {Array} properties Properties names to include\n     */populateWithProperties:function(source,destination,properties){if(properties&&Object.prototype.toString.call(properties)==='[object Array]'){for(var i=0,len=properties.length;i<len;i++){if(properties[i]in source){destination[properties[i]]=source[properties[i]];}}}},/**\n     * WARNING: THIS WAS TO SUPPORT OLD BROWSERS. deprecated.\n     * WILL BE REMOVED IN FABRIC 5.0\n     * Draws a dashed line between two points\n     *\n     * This method is used to draw dashed line around selection area.\n     * See <a href=\"http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas\">dotted stroke in canvas</a>\n     *\n     * @param {CanvasRenderingContext2D} ctx context\n     * @param {Number} x  start x coordinate\n     * @param {Number} y start y coordinate\n     * @param {Number} x2 end x coordinate\n     * @param {Number} y2 end y coordinate\n     * @param {Array} da dash array pattern\n     * @deprecated\n     */drawDashedLine:function(ctx,x,y,x2,y2,da){var dx=x2-x,dy=y2-y,len=sqrt(dx*dx+dy*dy),rot=atan2(dy,dx),dc=da.length,di=0,draw=true;ctx.save();ctx.translate(x,y);ctx.moveTo(0,0);ctx.rotate(rot);x=0;while(len>x){x+=da[di++%dc];if(x>len){x=len;}ctx[draw?'lineTo':'moveTo'](x,0);draw=!draw;}ctx.restore();},/**\n     * Creates canvas element\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */createCanvasElement:function(){return fabric.document.createElement('canvas');},/**\n     * Creates a canvas element that is a copy of another and is also painted\n     * @param {CanvasElement} canvas to copy size and content of\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */copyCanvasElement:function(canvas){var newCanvas=fabric.util.createCanvasElement();newCanvas.width=canvas.width;newCanvas.height=canvas.height;newCanvas.getContext('2d').drawImage(canvas,0,0);return newCanvas;},/**\n     * since 2.6.0 moved from canvas instance to utility.\n     * @param {CanvasElement} canvasEl to copy size and content of\n     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too\n     * @param {Number} quality <= 1 and > 0\n     * @static\n     * @memberOf fabric.util\n     * @return {String} data url\n     */toDataURL:function(canvasEl,format,quality){return canvasEl.toDataURL('image/'+format,quality);},/**\n     * Creates image element (works on client and node)\n     * @static\n     * @memberOf fabric.util\n     * @return {HTMLImageElement} HTML image element\n     */createImage:function(){return fabric.document.createElement('img');},/**\n     * Multiply matrix A by matrix B to nest transformations\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a First transformMatrix\n     * @param  {Array} b Second transformMatrix\n     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices\n     * @return {Array} The product of the two transform matrices\n     */multiplyTransformMatrices:function(a,b,is2x2){// Matrix multiply a * b\nreturn[a[0]*b[0]+a[2]*b[1],a[1]*b[0]+a[3]*b[1],a[0]*b[2]+a[2]*b[3],a[1]*b[2]+a[3]*b[3],is2x2?0:a[0]*b[4]+a[2]*b[5]+a[4],is2x2?0:a[1]*b[4]+a[3]*b[5]+a[5]];},/**\n     * Decomposes standard 2x3 matrix into transform components\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a transformMatrix\n     * @return {Object} Components of transform\n     */qrDecompose:function(a){var angle=atan2(a[1],a[0]),denom=pow(a[0],2)+pow(a[1],2),scaleX=sqrt(denom),scaleY=(a[0]*a[3]-a[2]*a[1])/scaleX,skewX=atan2(a[0]*a[2]+a[1]*a[3],denom);return{angle:angle/PiBy180,scaleX:scaleX,scaleY:scaleY,skewX:skewX/PiBy180,skewY:0,translateX:a[4],translateY:a[5]};},/**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle] angle in degrees\n     * @return {Number[]} transform matrix\n     */calcRotateMatrix:function(options){if(!options.angle){return fabric.iMatrix.concat();}var theta=fabric.util.degreesToRadians(options.angle),cos=fabric.util.cos(theta),sin=fabric.util.sin(theta);return[cos,sin,-sin,cos,0,0];},/**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet.\n     * is called DimensionsTransformMatrix because those properties are the one that influence\n     * the size of the resulting box of the object.\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewX]\n     * @return {Number[]} transform matrix\n     */calcDimensionsMatrix:function(options){var scaleX=typeof options.scaleX==='undefined'?1:options.scaleX,scaleY=typeof options.scaleY==='undefined'?1:options.scaleY,scaleMatrix=[options.flipX?-scaleX:scaleX,0,0,options.flipY?-scaleY:scaleY,0,0],multiply=fabric.util.multiplyTransformMatrices,degreesToRadians=fabric.util.degreesToRadians;if(options.skewX){scaleMatrix=multiply(scaleMatrix,[1,0,Math.tan(degreesToRadians(options.skewX)),1],true);}if(options.skewY){scaleMatrix=multiply(scaleMatrix,[1,Math.tan(degreesToRadians(options.skewY)),0,1],true);}return scaleMatrix;},/**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle]\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.translateX]\n     * @param  {Number} [options.translateY]\n     * @return {Number[]} transform matrix\n     */composeMatrix:function(options){var matrix=[1,0,0,1,options.translateX||0,options.translateY||0],multiply=fabric.util.multiplyTransformMatrices;if(options.angle){matrix=multiply(matrix,fabric.util.calcRotateMatrix(options));}if(options.scaleX!==1||options.scaleY!==1||options.skewX||options.skewY||options.flipX||options.flipY){matrix=multiply(matrix,fabric.util.calcDimensionsMatrix(options));}return matrix;},/**\n     * reset an object transform state to neutral. Top and left are not accounted for\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to transform\n     */resetObjectTransform:function(target){target.scaleX=1;target.scaleY=1;target.skewX=0;target.skewY=0;target.flipX=false;target.flipY=false;target.rotate(0);},/**\n     * Extract Object transform values\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to read from\n     * @return {Object} Components of transform\n     */saveObjectTransform:function(target){return{scaleX:target.scaleX,scaleY:target.scaleY,skewX:target.skewX,skewY:target.skewY,angle:target.angle,left:target.left,flipX:target.flipX,flipY:target.flipY,top:target.top};},/**\n     * Returns true if context has transparent pixel\n     * at specified location (taking tolerance into account)\n     * @param {CanvasRenderingContext2D} ctx context\n     * @param {Number} x x coordinate\n     * @param {Number} y y coordinate\n     * @param {Number} tolerance Tolerance\n     */isTransparent:function(ctx,x,y,tolerance){// If tolerance is > 0 adjust start coords to take into account.\n// If moves off Canvas fix to 0\nif(tolerance>0){if(x>tolerance){x-=tolerance;}else{x=0;}if(y>tolerance){y-=tolerance;}else{y=0;}}var _isTransparent=true,i,temp,imageData=ctx.getImageData(x,y,tolerance*2||1,tolerance*2||1),l=imageData.data.length;// Split image data - for tolerance > 1, pixelDataSize = 4;\nfor(i=3;i<l;i+=4){temp=imageData.data[i];_isTransparent=temp<=0;if(_isTransparent===false){break;// Stop if colour found\n}}imageData=null;return _isTransparent;},/**\n     * Parse preserveAspectRatio attribute from element\n     * @param {string} attribute to be parsed\n     * @return {Object} an object containing align and meetOrSlice attribute\n     */parsePreserveAspectRatioAttribute:function(attribute){var meetOrSlice='meet',alignX='Mid',alignY='Mid',aspectRatioAttrs=attribute.split(' '),align;if(aspectRatioAttrs&&aspectRatioAttrs.length){meetOrSlice=aspectRatioAttrs.pop();if(meetOrSlice!=='meet'&&meetOrSlice!=='slice'){align=meetOrSlice;meetOrSlice='meet';}else if(aspectRatioAttrs.length){align=aspectRatioAttrs.pop();}}//divide align in alignX and alignY\nalignX=align!=='none'?align.slice(1,4):'none';alignY=align!=='none'?align.slice(5,8):'none';return{meetOrSlice:meetOrSlice,alignX:alignX,alignY:alignY};},/**\n     * Clear char widths cache for the given font family or all the cache if no\n     * fontFamily is specified.\n     * Use it if you know you are loading fonts in a lazy way and you are not waiting\n     * for custom fonts to load properly when adding text objects to the canvas.\n     * If a text object is added when its own font is not loaded yet, you will get wrong\n     * measurement and so wrong bounding boxes.\n     * After the font cache is cleared, either change the textObject text content or call\n     * initDimensions() to trigger a recalculation\n     * @memberOf fabric.util\n     * @param {String} [fontFamily] font family to clear\n     */clearFabricFontCache:function(fontFamily){fontFamily=(fontFamily||'').toLowerCase();if(!fontFamily){fabric.charWidthsCache={};}else if(fabric.charWidthsCache[fontFamily]){delete fabric.charWidthsCache[fontFamily];}},/**\n     * Given current aspect ratio, determines the max width and height that can\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Number} ar aspect ratio\n     * @param {Number} maximumArea Maximum area you want to achieve\n     * @return {Object.x} Limited dimensions by X\n     * @return {Object.y} Limited dimensions by Y\n     */limitDimsByArea:function(ar,maximumArea){var roughWidth=Math.sqrt(maximumArea*ar),perfLimitSizeY=Math.floor(maximumArea/roughWidth);return{x:Math.floor(roughWidth),y:perfLimitSizeY};},capValue:function(min,value,max){return Math.max(min,Math.min(value,max));},/**\n     * Finds the scale for the object source to fit inside the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to fit into destination\n     */findScaleToFit:function(source,destination){return Math.min(destination.width/source.width,destination.height/source.height);},/**\n     * Finds the scale for the object source to cover entirely the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to cover destination\n     */findScaleToCover:function(source,destination){return Math.max(destination.width/source.width,destination.height/source.height);},/**\n     * given an array of 6 number returns something like `\"matrix(...numbers)\"`\n     * @memberOf fabric.util\n     * @param {Array} transform an array with 6 numbers\n     * @return {String} transform matrix for svg\n     * @return {Object.y} Limited dimensions by Y\n     */matrixToSVG:function(transform){return'matrix('+transform.map(function(value){return fabric.util.toFixed(value,fabric.Object.NUM_FRACTION_DIGITS);}).join(' ')+')';},/**\n     * given an object and a transform, apply the inverse transform to the object,\n     * this is equivalent to remove from that object that transformation, so that\n     * added in a space with the removed transform, the object will be the same as before.\n     * Removing from an object a transform that scale by 2 is like scaling it by 1/2.\n     * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg\n     * in the opposite direction.\n     * This util is used to add objects inside transformed groups or nested groups.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */removeTransformFromObject:function(object,transform){var inverted=fabric.util.invertTransform(transform),finalTransform=fabric.util.multiplyTransformMatrices(inverted,object.calcOwnMatrix());fabric.util.applyTransformToObject(object,finalTransform);},/**\n     * given an object and a transform, apply the transform to the object.\n     * this is equivalent to change the space where the object is drawn.\n     * Adding to an object a transform that scale by 2 is like scaling it by 2.\n     * This is used when removing an object from an active selection for example.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */addTransformToObject:function(object,transform){fabric.util.applyTransformToObject(object,fabric.util.multiplyTransformMatrices(transform,object.calcOwnMatrix()));},/**\n     * discard an object transform state and apply the one from the matrix.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */applyTransformToObject:function(object,transform){var options=fabric.util.qrDecompose(transform),center=new fabric.Point(options.translateX,options.translateY);object.flipX=false;object.flipY=false;object.set('scaleX',options.scaleX);object.set('scaleY',options.scaleY);object.skewX=options.skewX;object.skewY=options.skewY;object.angle=options.angle;object.setPositionByOrigin(center,'center','center');},/**\n     * given a width and height, return the size of the bounding box\n     * that can contains the box with width/height with applied transform\n     * described in options.\n     * Use to calculate the boxes around objects for controls.\n     * @memberOf fabric.util\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Object} options\n     * @param {Number} options.scaleX\n     * @param {Number} options.scaleY\n     * @param {Number} options.skewX\n     * @param {Number} options.skewY\n     * @return {Object.x} width of containing\n     * @return {Object.y} height of containing\n     */sizeAfterTransform:function(width,height,options){var dimX=width/2,dimY=height/2,points=[{x:-dimX,y:-dimY},{x:dimX,y:-dimY},{x:-dimX,y:dimY},{x:dimX,y:dimY}],transformMatrix=fabric.util.calcDimensionsMatrix(options),bbox=fabric.util.makeBoundingBoxFromPoints(points,transformMatrix);return{x:bbox.width,y:bbox.height};}};})( true?exports:0);(function(){var _join=Array.prototype.join,commandLengths={m:2,l:2,h:1,v:1,c:6,s:4,q:4,t:2,a:7},repeatedCommands={m:'l',M:'L'};function segmentToBezier(th2,th3,cosTh,sinTh,rx,ry,cx1,cy1,mT,fromX,fromY){var costh2=fabric.util.cos(th2),sinth2=fabric.util.sin(th2),costh3=fabric.util.cos(th3),sinth3=fabric.util.sin(th3),toX=cosTh*rx*costh3-sinTh*ry*sinth3+cx1,toY=sinTh*rx*costh3+cosTh*ry*sinth3+cy1,cp1X=fromX+mT*(-cosTh*rx*sinth2-sinTh*ry*costh2),cp1Y=fromY+mT*(-sinTh*rx*sinth2+cosTh*ry*costh2),cp2X=toX+mT*(cosTh*rx*sinth3+sinTh*ry*costh3),cp2Y=toY+mT*(sinTh*rx*sinth3-cosTh*ry*costh3);return['C',cp1X,cp1Y,cp2X,cp2Y,toX,toY];}/* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\n   * http://mozilla.org/MPL/2.0/\n   */function arcToSegments(toX,toY,rx,ry,large,sweep,rotateX){var PI=Math.PI,th=rotateX*PI/180,sinTh=fabric.util.sin(th),cosTh=fabric.util.cos(th),fromX=0,fromY=0;rx=Math.abs(rx);ry=Math.abs(ry);var px=-cosTh*toX*0.5-sinTh*toY*0.5,py=-cosTh*toY*0.5+sinTh*toX*0.5,rx2=rx*rx,ry2=ry*ry,py2=py*py,px2=px*px,pl=rx2*ry2-rx2*py2-ry2*px2,root=0;if(pl<0){var s=Math.sqrt(1-pl/(rx2*ry2));rx*=s;ry*=s;}else{root=(large===sweep?-1.0:1.0)*Math.sqrt(pl/(rx2*py2+ry2*px2));}var cx=root*rx*py/ry,cy=-root*ry*px/rx,cx1=cosTh*cx-sinTh*cy+toX*0.5,cy1=sinTh*cx+cosTh*cy+toY*0.5,mTheta=calcVectorAngle(1,0,(px-cx)/rx,(py-cy)/ry),dtheta=calcVectorAngle((px-cx)/rx,(py-cy)/ry,(-px-cx)/rx,(-py-cy)/ry);if(sweep===0&&dtheta>0){dtheta-=2*PI;}else if(sweep===1&&dtheta<0){dtheta+=2*PI;}// Convert into cubic bezier segments <= 90deg\nvar segments=Math.ceil(Math.abs(dtheta/PI*2)),result=[],mDelta=dtheta/segments,mT=8/3*Math.sin(mDelta/4)*Math.sin(mDelta/4)/Math.sin(mDelta/2),th3=mTheta+mDelta;for(var i=0;i<segments;i++){result[i]=segmentToBezier(mTheta,th3,cosTh,sinTh,rx,ry,cx1,cy1,mT,fromX,fromY);fromX=result[i][5];fromY=result[i][6];mTheta=th3;th3+=mDelta;}return result;}/*\n   * Private\n   */function calcVectorAngle(ux,uy,vx,vy){var ta=Math.atan2(uy,ux),tb=Math.atan2(vy,vx);if(tb>=ta){return tb-ta;}else{return 2*Math.PI-(ta-tb);}}/**\n   * Calculate bounding box of a beziercurve\n   * @param {Number} x0 starting point\n   * @param {Number} y0\n   * @param {Number} x1 first control point\n   * @param {Number} y1\n   * @param {Number} x2 secondo control point\n   * @param {Number} y2\n   * @param {Number} x3 end of bezier\n   * @param {Number} y3\n   */ // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\n// TODO: can we normalize this with the starting points set at 0 and then translated the bbox?\nfunction getBoundsOfCurve(x0,y0,x1,y1,x2,y2,x3,y3){var argsString;if(fabric.cachesBoundsOfCurve){argsString=_join.call(arguments);if(fabric.boundsOfCurveCache[argsString]){return fabric.boundsOfCurveCache[argsString];}}var sqrt=Math.sqrt,min=Math.min,max=Math.max,abs=Math.abs,tvalues=[],bounds=[[],[]],a,b,c,t,t1,t2,b2ac,sqrtb2ac;b=6*x0-12*x1+6*x2;a=-3*x0+9*x1-9*x2+3*x3;c=3*x1-3*x0;for(var i=0;i<2;++i){if(i>0){b=6*y0-12*y1+6*y2;a=-3*y0+9*y1-9*y2+3*y3;c=3*y1-3*y0;}if(abs(a)<1e-12){if(abs(b)<1e-12){continue;}t=-c/b;if(0<t&&t<1){tvalues.push(t);}continue;}b2ac=b*b-4*c*a;if(b2ac<0){continue;}sqrtb2ac=sqrt(b2ac);t1=(-b+sqrtb2ac)/(2*a);if(0<t1&&t1<1){tvalues.push(t1);}t2=(-b-sqrtb2ac)/(2*a);if(0<t2&&t2<1){tvalues.push(t2);}}var x,y,j=tvalues.length,jlen=j,mt;while(j--){t=tvalues[j];mt=1-t;x=mt*mt*mt*x0+3*mt*mt*t*x1+3*mt*t*t*x2+t*t*t*x3;bounds[0][j]=x;y=mt*mt*mt*y0+3*mt*mt*t*y1+3*mt*t*t*y2+t*t*t*y3;bounds[1][j]=y;}bounds[0][jlen]=x0;bounds[1][jlen]=y0;bounds[0][jlen+1]=x3;bounds[1][jlen+1]=y3;var result=[{x:min.apply(null,bounds[0]),y:min.apply(null,bounds[1])},{x:max.apply(null,bounds[0]),y:max.apply(null,bounds[1])}];if(fabric.cachesBoundsOfCurve){fabric.boundsOfCurveCache[argsString]=result;}return result;}/**\n   * Converts arc to a bunch of bezier curves\n   * @param {Number} fx starting point x\n   * @param {Number} fy starting point y\n   * @param {Array} coords Arc command\n   */function fromArcToBeziers(fx,fy,coords){var rx=coords[1],ry=coords[2],rot=coords[3],large=coords[4],sweep=coords[5],tx=coords[6],ty=coords[7],segsNorm=arcToSegments(tx-fx,ty-fy,rx,ry,large,sweep,rot);for(var i=0,len=segsNorm.length;i<len;i++){segsNorm[i][1]+=fx;segsNorm[i][2]+=fy;segsNorm[i][3]+=fx;segsNorm[i][4]+=fy;segsNorm[i][5]+=fx;segsNorm[i][6]+=fy;}return segsNorm;};/**\n   * This function take a parsed SVG path and make it simpler for fabricJS logic.\n   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )\n   * S converted in C, T converted in Q, A converted in C.\n   * @param {Array} path the array of commands of a parsed svg path for fabric.Path\n   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path\n   */function makePathSimpler(path){// x and y represent the last point of the path. the previous command point.\n// we add them to each relative command to make it an absolute comment.\n// we also swap the v V h H with L, because are easier to transform.\nvar x=0,y=0,len=path.length,// x1 and y1 represent the last point of the subpath. the subpath is started with\n// m or M command. When a z or Z command is drawn, x and y need to be resetted to\n// the last x1 and y1.\nx1=0,y1=0,current,i,converted,// previous will host the letter of the previous command, to handle S and T.\n// controlX and controlY will host the previous reflected control point\ndestinationPath=[],previous,controlX,controlY;for(i=0;i<len;++i){converted=false;current=path[i].slice(0);switch(current[0]){// first letter\ncase'l':// lineto, relative\ncurrent[0]='L';current[1]+=x;current[2]+=y;// falls through\ncase'L':x=current[1];y=current[2];break;case'h':// horizontal lineto, relative\ncurrent[1]+=x;// falls through\ncase'H':current[0]='L';current[2]=y;x=current[1];break;case'v':// vertical lineto, relative\ncurrent[1]+=y;// falls through\ncase'V':current[0]='L';y=current[1];current[1]=x;current[2]=y;break;case'm':// moveTo, relative\ncurrent[0]='M';current[1]+=x;current[2]+=y;// falls through\ncase'M':x=current[1];y=current[2];x1=current[1];y1=current[2];break;case'c':// bezierCurveTo, relative\ncurrent[0]='C';current[1]+=x;current[2]+=y;current[3]+=x;current[4]+=y;current[5]+=x;current[6]+=y;// falls through\ncase'C':controlX=current[3];controlY=current[4];x=current[5];y=current[6];break;case's':// shorthand cubic bezierCurveTo, relative\ncurrent[0]='S';current[1]+=x;current[2]+=y;current[3]+=x;current[4]+=y;// falls through\ncase'S':// would be sScC but since we are swapping sSc for C, we check just that.\nif(previous==='C'){// calculate reflection of previous control points\ncontrolX=2*x-controlX;controlY=2*y-controlY;}else{// If there is no previous command or if the previous command was not a C, c, S, or s,\n// the control point is coincident with the current point\ncontrolX=x;controlY=y;}x=current[3];y=current[4];current[0]='C';current[5]=current[3];current[6]=current[4];current[3]=current[1];current[4]=current[2];current[1]=controlX;current[2]=controlY;// current[3] and current[4] are NOW the second control point.\n// we keep it for the next reflection.\ncontrolX=current[3];controlY=current[4];break;case'q':// quadraticCurveTo, relative\ncurrent[0]='Q';current[1]+=x;current[2]+=y;current[3]+=x;current[4]+=y;// falls through\ncase'Q':controlX=current[1];controlY=current[2];x=current[3];y=current[4];break;case't':// shorthand quadraticCurveTo, relative\ncurrent[0]='T';current[1]+=x;current[2]+=y;// falls through\ncase'T':if(previous==='Q'){// calculate reflection of previous control point\ncontrolX=2*x-controlX;controlY=2*y-controlY;}else{// If there is no previous command or if the previous command was not a Q, q, T or t,\n// assume the control point is coincident with the current point\ncontrolX=x;controlY=y;}current[0]='Q';x=current[1];y=current[2];current[1]=controlX;current[2]=controlY;current[3]=x;current[4]=y;break;case'a':current[0]='A';current[6]+=x;current[7]+=y;// falls through\ncase'A':converted=true;destinationPath=destinationPath.concat(fromArcToBeziers(x,y,current));x=current[6];y=current[7];break;case'z':case'Z':x=x1;y=y1;break;default:}if(!converted){destinationPath.push(current);}previous=current[0];}return destinationPath;};/**\n   * Calc length from point x1,y1 to x2,y2\n   * @param {Number} x1 starting point x\n   * @param {Number} y1 starting point y\n   * @param {Number} x2 starting point x\n   * @param {Number} y2 starting point y\n   * @return {Number} length of segment\n   */function calcLineLength(x1,y1,x2,y2){return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));}// functions for the Cubic beizer\n// taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350\nfunction CB1(t){return t*t*t;}function CB2(t){return 3*t*t*(1-t);}function CB3(t){return 3*t*(1-t)*(1-t);}function CB4(t){return(1-t)*(1-t)*(1-t);}function getPointOnCubicBezierIterator(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y){return function(pct){var c1=CB1(pct),c2=CB2(pct),c3=CB3(pct),c4=CB4(pct);return{x:p4x*c1+p3x*c2+p2x*c3+p1x*c4,y:p4y*c1+p3y*c2+p2y*c3+p1y*c4};};}function getTangentCubicIterator(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y){return function(pct){var invT=1-pct,tangentX=3*invT*invT*(p2x-p1x)+6*invT*pct*(p3x-p2x)+3*pct*pct*(p4x-p3x),tangentY=3*invT*invT*(p2y-p1y)+6*invT*pct*(p3y-p2y)+3*pct*pct*(p4y-p3y);return Math.atan2(tangentY,tangentX);};}function QB1(t){return t*t;}function QB2(t){return 2*t*(1-t);}function QB3(t){return(1-t)*(1-t);}function getPointOnQuadraticBezierIterator(p1x,p1y,p2x,p2y,p3x,p3y){return function(pct){var c1=QB1(pct),c2=QB2(pct),c3=QB3(pct);return{x:p3x*c1+p2x*c2+p1x*c3,y:p3y*c1+p2y*c2+p1y*c3};};}function getTangentQuadraticIterator(p1x,p1y,p2x,p2y,p3x,p3y){return function(pct){var invT=1-pct,tangentX=2*invT*(p2x-p1x)+2*pct*(p3x-p2x),tangentY=2*invT*(p2y-p1y)+2*pct*(p3y-p2y);return Math.atan2(tangentY,tangentX);};}// this will run over a path segment ( a cubic or quadratic segment) and approximate it\n// with 100 segemnts. This will good enough to calculate the length of the curve\nfunction pathIterator(iterator,x1,y1){var tempP={x:x1,y:y1},p,tmpLen=0,perc;for(perc=1;perc<=100;perc+=1){p=iterator(perc/100);tmpLen+=calcLineLength(tempP.x,tempP.y,p.x,p.y);tempP=p;}return tmpLen;}/**\n   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1\n   * that correspond to that pixels run over the path.\n   * The percentage will be then used to find the correct point on the canvas for the path.\n   * @param {Array} segInfo fabricJS collection of information on a parsed path\n   * @param {Number} distance from starting point, in pixels.\n   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;\n   */function findPercentageForDistance(segInfo,distance){var perc=0,tmpLen=0,iterator=segInfo.iterator,tempP={x:segInfo.x,y:segInfo.y},p,nextLen,nextStep=0.01,angleFinder=segInfo.angleFinder,lastPerc;// nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100\n// the path\nwhile(tmpLen<distance&&perc<=1&&nextStep>0.0001){p=iterator(perc);lastPerc=perc;nextLen=calcLineLength(tempP.x,tempP.y,p.x,p.y);// compare tmpLen each cycle with distance, decide next perc to test.\nif(nextLen+tmpLen>distance){// we discard this step and we make smaller steps.\nnextStep/=2;perc-=nextStep;}else{tempP=p;perc+=nextStep;tmpLen+=nextLen;}}p.angle=angleFinder(lastPerc);return p;}/**\n   * Run over a parsed and simplifed path and extrac some informations.\n   * informations are length of each command and starting point\n   * @param {Array} path fabricJS parsed path commands\n   * @return {Array} path commands informations\n   */function getPathSegmentsInfo(path){var totalLength=0,len=path.length,current,//x2 and y2 are the coords of segment start\n//x1 and y1 are the coords of the current point\nx1=0,y1=0,x2=0,y2=0,info=[],iterator,tempInfo,angleFinder;for(var i=0;i<len;i++){current=path[i];tempInfo={x:x1,y:y1,command:current[0]};switch(current[0]){//first letter\ncase'M':tempInfo.length=0;x2=x1=current[1];y2=y1=current[2];break;case'L':tempInfo.length=calcLineLength(x1,y1,current[1],current[2]);x1=current[1];y1=current[2];break;case'C':iterator=getPointOnCubicBezierIterator(x1,y1,current[1],current[2],current[3],current[4],current[5],current[6]);angleFinder=getTangentCubicIterator(x1,y1,current[1],current[2],current[3],current[4],current[5],current[6]);tempInfo.iterator=iterator;tempInfo.angleFinder=angleFinder;tempInfo.length=pathIterator(iterator,x1,y1);x1=current[5];y1=current[6];break;case'Q':iterator=getPointOnQuadraticBezierIterator(x1,y1,current[1],current[2],current[3],current[4]);angleFinder=getTangentQuadraticIterator(x1,y1,current[1],current[2],current[3],current[4]);tempInfo.iterator=iterator;tempInfo.angleFinder=angleFinder;tempInfo.length=pathIterator(iterator,x1,y1);x1=current[3];y1=current[4];break;case'Z':case'z':// we add those in order to ease calculations later\ntempInfo.destX=x2;tempInfo.destY=y2;tempInfo.length=calcLineLength(x1,y1,x2,y2);x1=x2;y1=y2;break;}totalLength+=tempInfo.length;info.push(tempInfo);}info.push({length:totalLength,x:x1,y:y1});return info;}function getPointOnPath(path,distance,infos){if(!infos){infos=getPathSegmentsInfo(path);}var i=0;while(distance-infos[i].length>0&&i<infos.length-2){distance-=infos[i].length;i++;}// var distance = infos[infos.length - 1] * perc;\nvar segInfo=infos[i],segPercent=distance/segInfo.length,command=segInfo.command,segment=path[i],info;switch(command){case'M':return{x:segInfo.x,y:segInfo.y,angle:0};case'Z':case'z':info=new fabric.Point(segInfo.x,segInfo.y).lerp(new fabric.Point(segInfo.destX,segInfo.destY),segPercent);info.angle=Math.atan2(segInfo.destY-segInfo.y,segInfo.destX-segInfo.x);return info;case'L':info=new fabric.Point(segInfo.x,segInfo.y).lerp(new fabric.Point(segment[1],segment[2]),segPercent);info.angle=Math.atan2(segment[2]-segInfo.y,segment[1]-segInfo.x);return info;case'C':return findPercentageForDistance(segInfo,distance);case'Q':return findPercentageForDistance(segInfo,distance);}}/**\n   *\n   * @param {string} pathString\n   * @return {(string|number)[][]} An array of SVG path commands\n   * @example <caption>Usage</caption>\n   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [\n   *   ['M', 3, 4],\n   *   ['Q', 3, 5, 2, 1, 4, 0],\n   *   ['Q', 9, 12, 2, 1, 4, 0],\n   * ];\n   *\n   */function parsePath(pathString){var result=[],coords=[],currentPath,parsed,re=fabric.rePathCommand,rNumber='[-+]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.?)(?:[eE][-+]?\\\\d+)?\\\\s*',rNumberCommaWsp='('+rNumber+')'+fabric.commaWsp,rFlagCommaWsp='([01])'+fabric.commaWsp+'?',rArcSeq=rNumberCommaWsp+'?'+rNumberCommaWsp+'?'+rNumberCommaWsp+rFlagCommaWsp+rFlagCommaWsp+rNumberCommaWsp+'?('+rNumber+')',regArcArgumentSequence=new RegExp(rArcSeq,'g'),match,coordsStr,// one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\npath;if(!pathString||!pathString.match){return result;}path=pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);for(var i=0,coordsParsed,len=path.length;i<len;i++){currentPath=path[i];coordsStr=currentPath.slice(1).trim();coords.length=0;var command=currentPath.charAt(0);coordsParsed=[command];if(command.toLowerCase()==='a'){// arcs have special flags that apparently don't require spaces so handle special\nfor(var args;args=regArcArgumentSequence.exec(coordsStr);){for(var j=1;j<args.length;j++){coords.push(args[j]);}}}else{while(match=re.exec(coordsStr)){coords.push(match[0]);}}for(var j=0,jlen=coords.length;j<jlen;j++){parsed=parseFloat(coords[j]);if(!isNaN(parsed)){coordsParsed.push(parsed);}}var commandLength=commandLengths[command.toLowerCase()],repeatedCommand=repeatedCommands[command]||command;if(coordsParsed.length-1>commandLength){for(var k=1,klen=coordsParsed.length;k<klen;k+=commandLength){result.push([command].concat(coordsParsed.slice(k,k+commandLength)));command=repeatedCommand;}}else{result.push(coordsParsed);}}return result;};/**\n   *\n   * Converts points to a smooth SVG path\n   * @param {{ x: number,y: number }[]} points Array of points\n   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.\n   * @return {(string|number)[][]} An array of SVG path commands\n   */function getSmoothPathFromPoints(points,correction){var path=[],i,p1=new fabric.Point(points[0].x,points[0].y),p2=new fabric.Point(points[1].x,points[1].y),len=points.length,multSignX=1,multSignY=0,manyPoints=len>2;correction=correction||0;if(manyPoints){multSignX=points[2].x<p2.x?-1:points[2].x===p2.x?0:1;multSignY=points[2].y<p2.y?-1:points[2].y===p2.y?0:1;}path.push(['M',p1.x-multSignX*correction,p1.y-multSignY*correction]);for(i=1;i<len;i++){if(!p1.eq(p2)){var midPoint=p1.midPointFrom(p2);// p1 is our bezier control point\n// midpoint is our endpoint\n// start point is p(i-1) value.\npath.push(['Q',p1.x,p1.y,midPoint.x,midPoint.y]);}p1=points[i];if(i+1<points.length){p2=points[i+1];}}if(manyPoints){multSignX=p1.x>points[i-2].x?1:p1.x===points[i-2].x?0:-1;multSignY=p1.y>points[i-2].y?1:p1.y===points[i-2].y?0:-1;}path.push(['L',p1.x+multSignX*correction,p1.y+multSignY*correction]);return path;}/**\n   * Transform a path by transforming each segment.\n   * it has to be a simplified path or it won't work.\n   * WARNING: this depends from pathOffset for correct operation\n   * @param {Array} path fabricJS parsed and simplified path commands\n   * @param {Array} transform matrix that represent the transformation\n   * @param {Object} [pathOffset] the fabric.Path pathOffset\n   * @param {Number} pathOffset.x\n   * @param {Number} pathOffset.y\n   * @returns {Array} the transformed path\n   */function transformPath(path,transform,pathOffset){if(pathOffset){transform=fabric.util.multiplyTransformMatrices(transform,[1,0,0,1,-pathOffset.x,-pathOffset.y]);}return path.map(function(pathSegment){var newSegment=pathSegment.slice(0),point={};for(var i=1;i<pathSegment.length-1;i+=2){point.x=pathSegment[i];point.y=pathSegment[i+1];point=fabric.util.transformPoint(point,transform);newSegment[i]=point.x;newSegment[i+1]=point.y;}return newSegment;});}/**\n   * Calculate bounding box of a elliptic-arc\n   * @deprecated\n   * @param {Number} fx start point of arc\n   * @param {Number} fy\n   * @param {Number} rx horizontal radius\n   * @param {Number} ry vertical radius\n   * @param {Number} rot angle of horizontal axis\n   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points\n   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction\n   * @param {Number} tx end point of arc\n   * @param {Number} ty\n   */function getBoundsOfArc(fx,fy,rx,ry,rot,large,sweep,tx,ty){var fromX=0,fromY=0,bound,bounds=[],segs=arcToSegments(tx-fx,ty-fy,rx,ry,large,sweep,rot);for(var i=0,len=segs.length;i<len;i++){bound=getBoundsOfCurve(fromX,fromY,segs[i][1],segs[i][2],segs[i][3],segs[i][4],segs[i][5],segs[i][6]);bounds.push({x:bound[0].x+fx,y:bound[0].y+fy});bounds.push({x:bound[1].x+fx,y:bound[1].y+fy});fromX=segs[i][5];fromY=segs[i][6];}return bounds;};/**\n   * Draws arc\n   * @deprecated\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {Number} fx\n   * @param {Number} fy\n   * @param {Array} coords coords of the arc, without the front 'A/a'\n   */function drawArc(ctx,fx,fy,coords){coords=coords.slice(0).unshift('X');// command A or a does not matter\nvar beziers=fromArcToBeziers(fx,fy,coords);beziers.forEach(function(bezier){ctx.bezierCurveTo.apply(ctx,bezier.slice(1));});};/**\n   * Join path commands to go back to svg format\n   * @param {Array} pathData fabricJS parsed path commands\n   * @return {String} joined path 'M 0 0 L 20 30'\n   */fabric.util.joinPath=function(pathData){return pathData.map(function(segment){return segment.join(' ');}).join(' ');};fabric.util.parsePath=parsePath;fabric.util.makePathSimpler=makePathSimpler;fabric.util.getSmoothPathFromPoints=getSmoothPathFromPoints;fabric.util.getPathSegmentsInfo=getPathSegmentsInfo;fabric.util.getBoundsOfCurve=getBoundsOfCurve;fabric.util.getPointOnPath=getPointOnPath;fabric.util.transformPath=transformPath;/**\n   * Typo of `fromArcToBeziers` kept for not breaking the api once corrected.\n   * Will be removed in fabric 5.0\n   * @deprecated\n   */fabric.util.fromArcToBeizers=fromArcToBeziers;// kept because we do not want to make breaking changes.\n// but useless and deprecated.\nfabric.util.getBoundsOfArc=getBoundsOfArc;fabric.util.drawArc=drawArc;})();(function(){var slice=Array.prototype.slice;/**\n   * Invokes method on all items in a given array\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} method Name of a method to invoke\n   * @return {Array}\n   */function invoke(array,method){var args=slice.call(arguments,2),result=[];for(var i=0,len=array.length;i<len;i++){result[i]=args.length?array[i][method].apply(array[i],args):array[i][method].call(array[i]);}return result;}/**\n   * Finds maximum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */function max(array,byProperty){return find(array,byProperty,function(value1,value2){return value1>=value2;});}/**\n   * Finds minimum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */function min(array,byProperty){return find(array,byProperty,function(value1,value2){return value1<value2;});}/**\n   * @private\n   */function fill(array,value){var k=array.length;while(k--){array[k]=value;}return array;}/**\n   * @private\n   */function find(array,byProperty,condition){if(!array||array.length===0){return;}var i=array.length-1,result=byProperty?array[i][byProperty]:array[i];if(byProperty){while(i--){if(condition(array[i][byProperty],result)){result=array[i][byProperty];}}}else{while(i--){if(condition(array[i],result)){result=array[i];}}}return result;}/**\n   * @namespace fabric.util.array\n   */fabric.util.array={fill:fill,invoke:invoke,min:min,max:max};})();(function(){/**\n   * Copies all enumerable properties of one js object to another\n   * this does not and cannot compete with generic utils.\n   * Does not clone or extend fabric.Object subclasses.\n   * This is mostly for internal use and has extra handling for fabricJS objects\n   * it skips the canvas and group properties in deep cloning.\n   * @memberOf fabric.util.object\n   * @param {Object} destination Where to copy to\n   * @param {Object} source Where to copy from\n   * @param {Boolean} [deep] Whether to extend nested objects\n   * @return {Object}\n   */function extend(destination,source,deep){// JScript DontEnum bug is not taken care of\n// the deep clone is for internal use, is not meant to avoid\n// javascript traps or cloning html element or self referenced objects.\nif(deep){if(!fabric.isLikelyNode&&source instanceof Element){// avoid cloning deep images, canvases,\ndestination=source;}else if(source instanceof Array){destination=[];for(var i=0,len=source.length;i<len;i++){destination[i]=extend({},source[i],deep);}}else if(source&&typeof source==='object'){for(var property in source){if(property==='canvas'||property==='group'){// we do not want to clone this props at all.\n// we want to keep the keys in the copy\ndestination[property]=null;}else if(source.hasOwnProperty(property)){destination[property]=extend({},source[property],deep);}}}else{// this sounds odd for an extend but is ok for recursive use\ndestination=source;}}else{for(var property in source){destination[property]=source[property];}}return destination;}/**\n   * Creates an empty object and copies all enumerable properties of another object to it\n   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. \n   * @memberOf fabric.util.object\n   * @param {Object} object Object to clone\n   * @param {Boolean} [deep] Whether to clone nested objects\n   * @return {Object}\n   */ //TODO: this function return an empty object if you try to clone null\nfunction clone(object,deep){return extend({},object,deep);}/** @namespace fabric.util.object */fabric.util.object={extend:extend,clone:clone};fabric.util.object.extend(fabric.util,fabric.Observable);})();(function(){/**\n   * Camelizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to camelize\n   * @return {String} Camelized version of a string\n   */function camelize(string){return string.replace(/-+(.)?/g,function(match,character){return character?character.toUpperCase():'';});}/**\n   * Capitalizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to capitalize\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\n   * and other letters stay untouched, if false first letter is capitalized\n   * and other letters are converted to lowercase.\n   * @return {String} Capitalized version of a string\n   */function capitalize(string,firstLetterOnly){return string.charAt(0).toUpperCase()+(firstLetterOnly?string.slice(1):string.slice(1).toLowerCase());}/**\n   * Escapes XML in a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to escape\n   * @return {String} Escaped version of a string\n   */function escapeXml(string){return string.replace(/&/g,'&amp;').replace(/\"/g,'&quot;').replace(/'/g,'&apos;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}/**\n   * Divide a string in the user perceived single units\n   * @memberOf fabric.util.string\n   * @param {String} textstring String to escape\n   * @return {Array} array containing the graphemes\n   */function graphemeSplit(textstring){var i=0,chr,graphemes=[];for(i=0,chr;i<textstring.length;i++){if((chr=getWholeChar(textstring,i))===false){continue;}graphemes.push(chr);}return graphemes;}// taken from mdn in the charAt doc page.\nfunction getWholeChar(str,i){var code=str.charCodeAt(i);if(isNaN(code)){return'';// Position not found\n}if(code<0xD800||code>0xDFFF){return str.charAt(i);}// High surrogate (could change last hex to 0xDB7F to treat high private\n// surrogates as single characters)\nif(0xD800<=code&&code<=0xDBFF){if(str.length<=i+1){throw'High surrogate without following low surrogate';}var next=str.charCodeAt(i+1);if(0xDC00>next||next>0xDFFF){throw'High surrogate without following low surrogate';}return str.charAt(i)+str.charAt(i+1);}// Low surrogate (0xDC00 <= code && code <= 0xDFFF)\nif(i===0){throw'Low surrogate without preceding high surrogate';}var prev=str.charCodeAt(i-1);// (could change last hex to 0xDB7F to treat high private\n// surrogates as single characters)\nif(0xD800>prev||prev>0xDBFF){throw'Low surrogate without preceding high surrogate';}// We can pass over low surrogates now as the second component\n// in a pair which we have already processed\nreturn false;}/**\n   * String utilities\n   * @namespace fabric.util.string\n   */fabric.util.string={camelize:camelize,capitalize:capitalize,escapeXml:escapeXml,graphemeSplit:graphemeSplit};})();(function(){var slice=Array.prototype.slice,emptyFunction=function(){},IS_DONTENUM_BUGGY=function(){for(var p in{toString:1}){if(p==='toString'){return false;}}return true;}(),/** @ignore */addMethods=function(klass,source,parent){for(var property in source){if(property in klass.prototype&&typeof klass.prototype[property]==='function'&&(source[property]+'').indexOf('callSuper')>-1){klass.prototype[property]=function(property){return function(){var superclass=this.constructor.superclass;this.constructor.superclass=parent;var returnValue=source[property].apply(this,arguments);this.constructor.superclass=superclass;if(property!=='initialize'){return returnValue;}};}(property);}else{klass.prototype[property]=source[property];}if(IS_DONTENUM_BUGGY){if(source.toString!==Object.prototype.toString){klass.prototype.toString=source.toString;}if(source.valueOf!==Object.prototype.valueOf){klass.prototype.valueOf=source.valueOf;}}}};function Subclass(){}function callSuper(methodName){var parentMethod=null,_this=this;// climb prototype chain to find method not equal to callee's method\nwhile(_this.constructor.superclass){var superClassMethod=_this.constructor.superclass.prototype[methodName];if(_this[methodName]!==superClassMethod){parentMethod=superClassMethod;break;}// eslint-disable-next-line\n_this=_this.constructor.superclass.prototype;}if(!parentMethod){return console.log('tried to callSuper '+methodName+', method not found in prototype chain',this);}return arguments.length>1?parentMethod.apply(this,slice.call(arguments,1)):parentMethod.call(this);}/**\n   * Helper for creation of \"classes\".\n   * @memberOf fabric.util\n   * @param {Function} [parent] optional \"Class\" to inherit from\n   * @param {Object} [properties] Properties shared by all instances of this class\n   *                  (be careful modifying objects defined here as this would affect all instances)\n   */function createClass(){var parent=null,properties=slice.call(arguments,0);if(typeof properties[0]==='function'){parent=properties.shift();}function klass(){this.initialize.apply(this,arguments);}klass.superclass=parent;klass.subclasses=[];if(parent){Subclass.prototype=parent.prototype;klass.prototype=new Subclass();parent.subclasses.push(klass);}for(var i=0,length=properties.length;i<length;i++){addMethods(klass,properties[i],parent);}if(!klass.prototype.initialize){klass.prototype.initialize=emptyFunction;}klass.prototype.constructor=klass;klass.prototype.callSuper=callSuper;return klass;}fabric.util.createClass=createClass;})();(function(){// since ie11 can use addEventListener but they do not support options, i need to check\nvar couldUseAttachEvent=!!fabric.document.createElement('div').attachEvent,touchEvents=['touchstart','touchmove','touchend'];/**\n   * Adds an event listener to an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */fabric.util.addListener=function(element,eventName,handler,options){element&&element.addEventListener(eventName,handler,couldUseAttachEvent?false:options);};/**\n   * Removes an event listener from an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */fabric.util.removeListener=function(element,eventName,handler,options){element&&element.removeEventListener(eventName,handler,couldUseAttachEvent?false:options);};function getTouchInfo(event){var touchProp=event.changedTouches;if(touchProp&&touchProp[0]){return touchProp[0];}return event;}fabric.util.getPointer=function(event){var element=event.target,scroll=fabric.util.getScrollLeftTop(element),_evt=getTouchInfo(event);return{x:_evt.clientX+scroll.left,y:_evt.clientY+scroll.top};};fabric.util.isTouchEvent=function(event){return touchEvents.indexOf(event.type)>-1||event.pointerType==='touch';};})();(function(){/**\n   * Cross-browser wrapper for setting element's style\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {HTMLElement} Element that was passed as a first argument\n   */function setStyle(element,styles){var elementStyle=element.style;if(!elementStyle){return element;}if(typeof styles==='string'){element.style.cssText+=';'+styles;return styles.indexOf('opacity')>-1?setOpacity(element,styles.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1]):element;}for(var property in styles){if(property==='opacity'){setOpacity(element,styles[property]);}else{var normalizedProperty=property==='float'||property==='cssFloat'?typeof elementStyle.styleFloat==='undefined'?'cssFloat':'styleFloat':property;elementStyle[normalizedProperty]=styles[property];}}return element;}var parseEl=fabric.document.createElement('div'),supportsOpacity=typeof parseEl.style.opacity==='string',supportsFilters=typeof parseEl.style.filter==='string',reOpacity=/alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/,/** @ignore */setOpacity=function(element){return element;};if(supportsOpacity){/** @ignore */setOpacity=function(element,value){element.style.opacity=value;return element;};}else if(supportsFilters){/** @ignore */setOpacity=function(element,value){var es=element.style;if(element.currentStyle&&!element.currentStyle.hasLayout){es.zoom=1;}if(reOpacity.test(es.filter)){value=value>=0.9999?'':'alpha(opacity='+value*100+')';es.filter=es.filter.replace(reOpacity,value);}else{es.filter+=' alpha(opacity='+value*100+')';}return element;};}fabric.util.setStyle=setStyle;})();(function(){var _slice=Array.prototype.slice;/**\n   * Takes id and returns an element with that id (if one exists in a document)\n   * @memberOf fabric.util\n   * @param {String|HTMLElement} id\n   * @return {HTMLElement|null}\n   */function getById(id){return typeof id==='string'?fabric.document.getElementById(id):id;}var sliceCanConvertNodelists,/**\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\n       * @memberOf fabric.util\n       * @param {Object} arrayLike\n       * @return {Array}\n       */toArray=function(arrayLike){return _slice.call(arrayLike,0);};try{sliceCanConvertNodelists=toArray(fabric.document.childNodes)instanceof Array;}catch(err){}if(!sliceCanConvertNodelists){toArray=function(arrayLike){var arr=new Array(arrayLike.length),i=arrayLike.length;while(i--){arr[i]=arrayLike[i];}return arr;};}/**\n   * Creates specified element with specified attributes\n   * @memberOf fabric.util\n   * @param {String} tagName Type of an element to create\n   * @param {Object} [attributes] Attributes to set on an element\n   * @return {HTMLElement} Newly created element\n   */function makeElement(tagName,attributes){var el=fabric.document.createElement(tagName);for(var prop in attributes){if(prop==='class'){el.className=attributes[prop];}else if(prop==='for'){el.htmlFor=attributes[prop];}else{el.setAttribute(prop,attributes[prop]);}}return el;}/**\n   * Adds class to an element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to add class to\n   * @param {String} className Class to add to an element\n   */function addClass(element,className){if(element&&(' '+element.className+' ').indexOf(' '+className+' ')===-1){element.className+=(element.className?' ':'')+className;}}/**\n   * Wraps element with another element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to wrap\n   * @param {HTMLElement|String} wrapper Element to wrap with\n   * @param {Object} [attributes] Attributes to set on a wrapper\n   * @return {HTMLElement} wrapper\n   */function wrapElement(element,wrapper,attributes){if(typeof wrapper==='string'){wrapper=makeElement(wrapper,attributes);}if(element.parentNode){element.parentNode.replaceChild(wrapper,element);}wrapper.appendChild(element);return wrapper;}/**\n   * Returns element scroll offsets\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to operate on\n   * @return {Object} Object with left/top values\n   */function getScrollLeftTop(element){var left=0,top=0,docElement=fabric.document.documentElement,body=fabric.document.body||{scrollLeft:0,scrollTop:0};// While loop checks (and then sets element to) .parentNode OR .host\n//  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,\n//  but the .parentNode of a root ShadowDOM node will always be null, instead\n//  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938\nwhile(element&&(element.parentNode||element.host)){// Set element to element parent, or 'host' in case of ShadowDOM\nelement=element.parentNode||element.host;if(element===fabric.document){left=body.scrollLeft||docElement.scrollLeft||0;top=body.scrollTop||docElement.scrollTop||0;}else{left+=element.scrollLeft||0;top+=element.scrollTop||0;}if(element.nodeType===1&&element.style.position==='fixed'){break;}}return{left:left,top:top};}/**\n   * Returns offset for a given element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get offset for\n   * @return {Object} Object with \"left\" and \"top\" properties\n   */function getElementOffset(element){var docElem,doc=element&&element.ownerDocument,box={left:0,top:0},offset={left:0,top:0},scrollLeftTop,offsetAttributes={borderLeftWidth:'left',borderTopWidth:'top',paddingLeft:'left',paddingTop:'top'};if(!doc){return offset;}for(var attr in offsetAttributes){offset[offsetAttributes[attr]]+=parseInt(getElementStyle(element,attr),10)||0;}docElem=doc.documentElement;if(typeof element.getBoundingClientRect!=='undefined'){box=element.getBoundingClientRect();}scrollLeftTop=getScrollLeftTop(element);return{left:box.left+scrollLeftTop.left-(docElem.clientLeft||0)+offset.left,top:box.top+scrollLeftTop.top-(docElem.clientTop||0)+offset.top};}/**\n   * Returns style attribute value of a given element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get style attribute for\n   * @param {String} attr Style attribute to get for element\n   * @return {String} Style attribute value of the given element.\n   */var getElementStyle;if(fabric.document.defaultView&&fabric.document.defaultView.getComputedStyle){getElementStyle=function(element,attr){var style=fabric.document.defaultView.getComputedStyle(element,null);return style?style[attr]:undefined;};}else{getElementStyle=function(element,attr){var value=element.style[attr];if(!value&&element.currentStyle){value=element.currentStyle[attr];}return value;};}(function(){var style=fabric.document.documentElement.style,selectProp='userSelect'in style?'userSelect':'MozUserSelect'in style?'MozUserSelect':'WebkitUserSelect'in style?'WebkitUserSelect':'KhtmlUserSelect'in style?'KhtmlUserSelect':'';/**\n     * Makes element unselectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make unselectable\n     * @return {HTMLElement} Element that was passed in\n     */function makeElementUnselectable(element){if(typeof element.onselectstart!=='undefined'){element.onselectstart=fabric.util.falseFunction;}if(selectProp){element.style[selectProp]='none';}else if(typeof element.unselectable==='string'){element.unselectable='on';}return element;}/**\n     * Makes element selectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make selectable\n     * @return {HTMLElement} Element that was passed in\n     */function makeElementSelectable(element){if(typeof element.onselectstart!=='undefined'){element.onselectstart=null;}if(selectProp){element.style[selectProp]='';}else if(typeof element.unselectable==='string'){element.unselectable='';}return element;}fabric.util.makeElementUnselectable=makeElementUnselectable;fabric.util.makeElementSelectable=makeElementSelectable;})();function getNodeCanvas(element){var impl=fabric.jsdomImplForWrapper(element);return impl._canvas||impl._image;};function cleanUpJsdomNode(element){if(!fabric.isLikelyNode){return;}var impl=fabric.jsdomImplForWrapper(element);if(impl){impl._image=null;impl._canvas=null;// unsure if necessary\nimpl._currentSrc=null;impl._attributes=null;impl._classList=null;}}function setImageSmoothing(ctx,value){ctx.imageSmoothingEnabled=ctx.imageSmoothingEnabled||ctx.webkitImageSmoothingEnabled||ctx.mozImageSmoothingEnabled||ctx.msImageSmoothingEnabled||ctx.oImageSmoothingEnabled;ctx.imageSmoothingEnabled=value;}/**\n   * setImageSmoothing sets the context imageSmoothingEnabled property.\n   * Used by canvas and by ImageObject.\n   * @memberOf fabric.util\n   * @since 4.0.0\n   * @param {HTMLRenderingContext2D} ctx to set on\n   * @param {Boolean} value true or false\n   */fabric.util.setImageSmoothing=setImageSmoothing;fabric.util.getById=getById;fabric.util.toArray=toArray;fabric.util.addClass=addClass;fabric.util.makeElement=makeElement;fabric.util.wrapElement=wrapElement;fabric.util.getScrollLeftTop=getScrollLeftTop;fabric.util.getElementOffset=getElementOffset;fabric.util.getNodeCanvas=getNodeCanvas;fabric.util.cleanUpJsdomNode=cleanUpJsdomNode;})();(function(){function addParamToUrl(url,param){return url+(/\\?/.test(url)?'&':'?')+param;}function emptyFn(){}/**\n   * Cross-browser abstraction for sending XMLHttpRequest\n   * @memberOf fabric.util\n   * @param {String} url URL to send XMLHttpRequest to\n   * @param {Object} [options] Options object\n   * @param {String} [options.method=\"GET\"]\n   * @param {String} [options.parameters] parameters to append to url in GET or in body\n   * @param {String} [options.body] body to send with POST or PUT request\n   * @param {Function} options.onComplete Callback to invoke when request is completed\n   * @return {XMLHttpRequest} request\n   */function request(url,options){options||(options={});var method=options.method?options.method.toUpperCase():'GET',onComplete=options.onComplete||function(){},xhr=new fabric.window.XMLHttpRequest(),body=options.body||options.parameters;/** @ignore */xhr.onreadystatechange=function(){if(xhr.readyState===4){onComplete(xhr);xhr.onreadystatechange=emptyFn;}};if(method==='GET'){body=null;if(typeof options.parameters==='string'){url=addParamToUrl(url,options.parameters);}}xhr.open(method,url,true);if(method==='POST'||method==='PUT'){xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');}xhr.send(body);return xhr;}fabric.util.request=request;})();/**\n * Wrapper around `console.log` (when available)\n * @param {*} [values] Values to log\n */fabric.log=console.log;/**\n * Wrapper around `console.warn` (when available)\n * @param {*} [values] Values to log as a warning\n */fabric.warn=console.warn;(function(){function noop(){return false;}function defaultEasing(t,b,c,d){return-c*Math.cos(t/d*(Math.PI/2))+c+b;}/**\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {Object} [options] Animation options\n   * @param {Function} [options.onChange] Callback; invoked on every value change\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\n   * @param {Number} [options.startValue=0] Starting value\n   * @param {Number} [options.endValue=100] Ending value\n   * @param {Number} [options.byValue=100] Value to modify the property by\n   * @param {Function} [options.easing] Easing function\n   * @param {Number} [options.duration=500] Duration of change (in ms)\n   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.\n   * @returns {Function} abort function\n   */function animate(options){var cancel=false;requestAnimFrame(function(timestamp){options||(options={});var start=timestamp||+new Date(),duration=options.duration||500,finish=start+duration,time,onChange=options.onChange||noop,abort=options.abort||noop,onComplete=options.onComplete||noop,easing=options.easing||defaultEasing,startValue='startValue'in options?options.startValue:0,endValue='endValue'in options?options.endValue:100,byValue=options.byValue||endValue-startValue;options.onStart&&options.onStart();(function tick(ticktime){// TODO: move abort call after calculation\n// and pass (current,valuePerc, timePerc) as arguments\ntime=ticktime||+new Date();var currentTime=time>finish?duration:time-start,timePerc=currentTime/duration,current=easing(currentTime,startValue,byValue,duration),valuePerc=Math.abs((current-startValue)/byValue);if(cancel){return;}if(abort(current,valuePerc,timePerc)){// remove this in 4.0\n// does to even make sense to abort and run onComplete?\nonComplete(endValue,1,1);return;}if(time>finish){onChange(endValue,1,1);onComplete(endValue,1,1);return;}else{onChange(current,valuePerc,timePerc);requestAnimFrame(tick);}})(start);});return function(){cancel=true;};}var _requestAnimFrame=fabric.window.requestAnimationFrame||fabric.window.webkitRequestAnimationFrame||fabric.window.mozRequestAnimationFrame||fabric.window.oRequestAnimationFrame||fabric.window.msRequestAnimationFrame||function(callback){return fabric.window.setTimeout(callback,1000/60);};var _cancelAnimFrame=fabric.window.cancelAnimationFrame||fabric.window.clearTimeout;/**\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\n   * @memberOf fabric.util\n   * @param {Function} callback Callback to invoke\n   * @param {DOMElement} element optional Element to associate with animation\n   */function requestAnimFrame(){return _requestAnimFrame.apply(fabric.window,arguments);}function cancelAnimFrame(){return _cancelAnimFrame.apply(fabric.window,arguments);}fabric.util.animate=animate;fabric.util.requestAnimFrame=requestAnimFrame;fabric.util.cancelAnimFrame=cancelAnimFrame;})();(function(){// Calculate an in-between color. Returns a \"rgba()\" string.\n// Credit: Edwin Martin <edwin@bitstorm.org>\n//         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js\nfunction calculateColor(begin,end,pos){var color='rgba('+parseInt(begin[0]+pos*(end[0]-begin[0]),10)+','+parseInt(begin[1]+pos*(end[1]-begin[1]),10)+','+parseInt(begin[2]+pos*(end[2]-begin[2]),10);color+=','+(begin&&end?parseFloat(begin[3]+pos*(end[3]-begin[3])):1);color+=')';return color;}/**\n   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {String} fromColor The starting color in hex or rgb(a) format.\n   * @param {String} toColor The starting color in hex or rgb(a) format.\n   * @param {Number} [duration] Duration of change (in ms).\n   * @param {Object} [options] Animation options\n   * @param {Function} [options.onChange] Callback; invoked on every value change\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\n   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.\n   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.\n   * @returns {Function} abort function\n   */function animateColor(fromColor,toColor,duration,options){var startColor=new fabric.Color(fromColor).getSource(),endColor=new fabric.Color(toColor).getSource(),originalOnComplete=options.onComplete,originalOnChange=options.onChange;options=options||{};return fabric.util.animate(fabric.util.object.extend(options,{duration:duration||500,startValue:startColor,endValue:endColor,byValue:endColor,easing:function(currentTime,startValue,byValue,duration){var posValue=options.colorEasing?options.colorEasing(currentTime,duration):1-Math.cos(currentTime/duration*(Math.PI/2));return calculateColor(startValue,byValue,posValue);},// has to take in account for color restoring;\nonComplete:function(current,valuePerc,timePerc){if(originalOnComplete){return originalOnComplete(calculateColor(endColor,endColor,0),valuePerc,timePerc);}},onChange:function(current,valuePerc,timePerc){if(originalOnChange){if(Array.isArray(current)){return originalOnChange(calculateColor(current,current,0),valuePerc,timePerc);}originalOnChange(current,valuePerc,timePerc);}}}));}fabric.util.animateColor=animateColor;})();(function(){function normalize(a,c,p,s){if(a<Math.abs(c)){a=c;s=p/4;}else{//handle the 0/0 case:\nif(c===0&&a===0){s=p/(2*Math.PI)*Math.asin(1);}else{s=p/(2*Math.PI)*Math.asin(c/a);}}return{a:a,c:c,p:p,s:s};}function elastic(opts,t,d){return opts.a*Math.pow(2,10*(t-=1))*Math.sin((t*d-opts.s)*(2*Math.PI)/opts.p);}/**\n   * Cubic easing out\n   * @memberOf fabric.util.ease\n   */function easeOutCubic(t,b,c,d){return c*((t=t/d-1)*t*t+1)+b;}/**\n   * Cubic easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutCubic(t,b,c,d){t/=d/2;if(t<1){return c/2*t*t*t+b;}return c/2*((t-=2)*t*t+2)+b;}/**\n   * Quartic easing in\n   * @memberOf fabric.util.ease\n   */function easeInQuart(t,b,c,d){return c*(t/=d)*t*t*t+b;}/**\n   * Quartic easing out\n   * @memberOf fabric.util.ease\n   */function easeOutQuart(t,b,c,d){return-c*((t=t/d-1)*t*t*t-1)+b;}/**\n   * Quartic easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutQuart(t,b,c,d){t/=d/2;if(t<1){return c/2*t*t*t*t+b;}return-c/2*((t-=2)*t*t*t-2)+b;}/**\n   * Quintic easing in\n   * @memberOf fabric.util.ease\n   */function easeInQuint(t,b,c,d){return c*(t/=d)*t*t*t*t+b;}/**\n   * Quintic easing out\n   * @memberOf fabric.util.ease\n   */function easeOutQuint(t,b,c,d){return c*((t=t/d-1)*t*t*t*t+1)+b;}/**\n   * Quintic easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutQuint(t,b,c,d){t/=d/2;if(t<1){return c/2*t*t*t*t*t+b;}return c/2*((t-=2)*t*t*t*t+2)+b;}/**\n   * Sinusoidal easing in\n   * @memberOf fabric.util.ease\n   */function easeInSine(t,b,c,d){return-c*Math.cos(t/d*(Math.PI/2))+c+b;}/**\n   * Sinusoidal easing out\n   * @memberOf fabric.util.ease\n   */function easeOutSine(t,b,c,d){return c*Math.sin(t/d*(Math.PI/2))+b;}/**\n   * Sinusoidal easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutSine(t,b,c,d){return-c/2*(Math.cos(Math.PI*t/d)-1)+b;}/**\n   * Exponential easing in\n   * @memberOf fabric.util.ease\n   */function easeInExpo(t,b,c,d){return t===0?b:c*Math.pow(2,10*(t/d-1))+b;}/**\n   * Exponential easing out\n   * @memberOf fabric.util.ease\n   */function easeOutExpo(t,b,c,d){return t===d?b+c:c*(-Math.pow(2,-10*t/d)+1)+b;}/**\n   * Exponential easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutExpo(t,b,c,d){if(t===0){return b;}if(t===d){return b+c;}t/=d/2;if(t<1){return c/2*Math.pow(2,10*(t-1))+b;}return c/2*(-Math.pow(2,-10*--t)+2)+b;}/**\n   * Circular easing in\n   * @memberOf fabric.util.ease\n   */function easeInCirc(t,b,c,d){return-c*(Math.sqrt(1-(t/=d)*t)-1)+b;}/**\n   * Circular easing out\n   * @memberOf fabric.util.ease\n   */function easeOutCirc(t,b,c,d){return c*Math.sqrt(1-(t=t/d-1)*t)+b;}/**\n   * Circular easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutCirc(t,b,c,d){t/=d/2;if(t<1){return-c/2*(Math.sqrt(1-t*t)-1)+b;}return c/2*(Math.sqrt(1-(t-=2)*t)+1)+b;}/**\n   * Elastic easing in\n   * @memberOf fabric.util.ease\n   */function easeInElastic(t,b,c,d){var s=1.70158,p=0,a=c;if(t===0){return b;}t/=d;if(t===1){return b+c;}if(!p){p=d*0.3;}var opts=normalize(a,c,p,s);return-elastic(opts,t,d)+b;}/**\n   * Elastic easing out\n   * @memberOf fabric.util.ease\n   */function easeOutElastic(t,b,c,d){var s=1.70158,p=0,a=c;if(t===0){return b;}t/=d;if(t===1){return b+c;}if(!p){p=d*0.3;}var opts=normalize(a,c,p,s);return opts.a*Math.pow(2,-10*t)*Math.sin((t*d-opts.s)*(2*Math.PI)/opts.p)+opts.c+b;}/**\n   * Elastic easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutElastic(t,b,c,d){var s=1.70158,p=0,a=c;if(t===0){return b;}t/=d/2;if(t===2){return b+c;}if(!p){p=d*(0.3*1.5);}var opts=normalize(a,c,p,s);if(t<1){return-0.5*elastic(opts,t,d)+b;}return opts.a*Math.pow(2,-10*(t-=1))*Math.sin((t*d-opts.s)*(2*Math.PI)/opts.p)*0.5+opts.c+b;}/**\n   * Backwards easing in\n   * @memberOf fabric.util.ease\n   */function easeInBack(t,b,c,d,s){if(s===undefined){s=1.70158;}return c*(t/=d)*t*((s+1)*t-s)+b;}/**\n   * Backwards easing out\n   * @memberOf fabric.util.ease\n   */function easeOutBack(t,b,c,d,s){if(s===undefined){s=1.70158;}return c*((t=t/d-1)*t*((s+1)*t+s)+1)+b;}/**\n   * Backwards easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutBack(t,b,c,d,s){if(s===undefined){s=1.70158;}t/=d/2;if(t<1){return c/2*(t*t*(((s*=1.525)+1)*t-s))+b;}return c/2*((t-=2)*t*(((s*=1.525)+1)*t+s)+2)+b;}/**\n   * Bouncing easing in\n   * @memberOf fabric.util.ease\n   */function easeInBounce(t,b,c,d){return c-easeOutBounce(d-t,0,c,d)+b;}/**\n   * Bouncing easing out\n   * @memberOf fabric.util.ease\n   */function easeOutBounce(t,b,c,d){if((t/=d)<1/2.75){return c*(7.5625*t*t)+b;}else if(t<2/2.75){return c*(7.5625*(t-=1.5/2.75)*t+0.75)+b;}else if(t<2.5/2.75){return c*(7.5625*(t-=2.25/2.75)*t+0.9375)+b;}else{return c*(7.5625*(t-=2.625/2.75)*t+0.984375)+b;}}/**\n   * Bouncing easing in and out\n   * @memberOf fabric.util.ease\n   */function easeInOutBounce(t,b,c,d){if(t<d/2){return easeInBounce(t*2,0,c,d)*0.5+b;}return easeOutBounce(t*2-d,0,c,d)*0.5+c*0.5+b;}/**\n   * Easing functions\n   * See <a href=\"http://gizma.com/easing/\">Easing Equations by Robert Penner</a>\n   * @namespace fabric.util.ease\n   */fabric.util.ease={/**\n     * Quadratic easing in\n     * @memberOf fabric.util.ease\n     */easeInQuad:function(t,b,c,d){return c*(t/=d)*t+b;},/**\n     * Quadratic easing out\n     * @memberOf fabric.util.ease\n     */easeOutQuad:function(t,b,c,d){return-c*(t/=d)*(t-2)+b;},/**\n     * Quadratic easing in and out\n     * @memberOf fabric.util.ease\n     */easeInOutQuad:function(t,b,c,d){t/=d/2;if(t<1){return c/2*t*t+b;}return-c/2*(--t*(t-2)-1)+b;},/**\n     * Cubic easing in\n     * @memberOf fabric.util.ease\n     */easeInCubic:function(t,b,c,d){return c*(t/=d)*t*t+b;},easeOutCubic:easeOutCubic,easeInOutCubic:easeInOutCubic,easeInQuart:easeInQuart,easeOutQuart:easeOutQuart,easeInOutQuart:easeInOutQuart,easeInQuint:easeInQuint,easeOutQuint:easeOutQuint,easeInOutQuint:easeInOutQuint,easeInSine:easeInSine,easeOutSine:easeOutSine,easeInOutSine:easeInOutSine,easeInExpo:easeInExpo,easeOutExpo:easeOutExpo,easeInOutExpo:easeInOutExpo,easeInCirc:easeInCirc,easeOutCirc:easeOutCirc,easeInOutCirc:easeInOutCirc,easeInElastic:easeInElastic,easeOutElastic:easeOutElastic,easeInOutElastic:easeInOutElastic,easeInBack:easeInBack,easeOutBack:easeOutBack,easeInOutBack:easeInOutBack,easeInBounce:easeInBounce,easeOutBounce:easeOutBounce,easeInOutBounce:easeInOutBounce};})();(function(global){'use strict';/**\n   * @name fabric\n   * @namespace\n   */var fabric=global.fabric||(global.fabric={}),extend=fabric.util.object.extend,clone=fabric.util.object.clone,toFixed=fabric.util.toFixed,parseUnit=fabric.util.parseUnit,multiplyTransformMatrices=fabric.util.multiplyTransformMatrices,svgValidTagNames=['path','circle','polygon','polyline','ellipse','rect','line','image','text'],svgViewBoxElements=['symbol','image','marker','pattern','view','svg'],svgInvalidAncestors=['pattern','defs','symbol','metadata','clipPath','mask','desc'],svgValidParents=['symbol','g','a','svg','clipPath','defs'],attributesMap={cx:'left',x:'left',r:'radius',cy:'top',y:'top',display:'visible',visibility:'visible',transform:'transformMatrix','fill-opacity':'fillOpacity','fill-rule':'fillRule','font-family':'fontFamily','font-size':'fontSize','font-style':'fontStyle','font-weight':'fontWeight','letter-spacing':'charSpacing','paint-order':'paintFirst','stroke-dasharray':'strokeDashArray','stroke-dashoffset':'strokeDashOffset','stroke-linecap':'strokeLineCap','stroke-linejoin':'strokeLineJoin','stroke-miterlimit':'strokeMiterLimit','stroke-opacity':'strokeOpacity','stroke-width':'strokeWidth','text-decoration':'textDecoration','text-anchor':'textAnchor',opacity:'opacity','clip-path':'clipPath','clip-rule':'clipRule','vector-effect':'strokeUniform','image-rendering':'imageSmoothing'},colorAttributes={stroke:'strokeOpacity',fill:'fillOpacity'},fSize='font-size',cPath='clip-path';fabric.svgValidTagNamesRegEx=getSvgRegex(svgValidTagNames);fabric.svgViewBoxElementsRegEx=getSvgRegex(svgViewBoxElements);fabric.svgInvalidAncestorsRegEx=getSvgRegex(svgInvalidAncestors);fabric.svgValidParentsRegEx=getSvgRegex(svgValidParents);fabric.cssRules={};fabric.gradientDefs={};fabric.clipPaths={};function normalizeAttr(attr){// transform attribute names\nif(attr in attributesMap){return attributesMap[attr];}return attr;}function normalizeValue(attr,value,parentAttributes,fontSize){var isArray=Object.prototype.toString.call(value)==='[object Array]',parsed;if((attr==='fill'||attr==='stroke')&&value==='none'){value='';}else if(attr==='strokeUniform'){return value==='non-scaling-stroke';}else if(attr==='strokeDashArray'){if(value==='none'){value=null;}else{value=value.replace(/,/g,' ').split(/\\s+/).map(parseFloat);}}else if(attr==='transformMatrix'){if(parentAttributes&&parentAttributes.transformMatrix){value=multiplyTransformMatrices(parentAttributes.transformMatrix,fabric.parseTransformAttribute(value));}else{value=fabric.parseTransformAttribute(value);}}else if(attr==='visible'){value=value!=='none'&&value!=='hidden';// display=none on parent element always takes precedence over child element\nif(parentAttributes&&parentAttributes.visible===false){value=false;}}else if(attr==='opacity'){value=parseFloat(value);if(parentAttributes&&typeof parentAttributes.opacity!=='undefined'){value*=parentAttributes.opacity;}}else if(attr==='textAnchor'/* text-anchor */){value=value==='start'?'left':value==='end'?'right':'center';}else if(attr==='charSpacing'){// parseUnit returns px and we convert it to em\nparsed=parseUnit(value,fontSize)/fontSize*1000;}else if(attr==='paintFirst'){var fillIndex=value.indexOf('fill');var strokeIndex=value.indexOf('stroke');var value='fill';if(fillIndex>-1&&strokeIndex>-1&&strokeIndex<fillIndex){value='stroke';}else if(fillIndex===-1&&strokeIndex>-1){value='stroke';}}else if(attr==='href'||attr==='xlink:href'||attr==='font'){return value;}else if(attr==='imageSmoothing'){return value==='optimizeQuality';}else{parsed=isArray?value.map(parseUnit):parseUnit(value,fontSize);}return!isArray&&isNaN(parsed)?value:parsed;}/**\n    * @private\n    */function getSvgRegex(arr){return new RegExp('^('+arr.join('|')+')\\\\b','i');}/**\n   * @private\n   * @param {Object} attributes Array of attributes to parse\n   */function _setStrokeFillOpacity(attributes){for(var attr in colorAttributes){if(typeof attributes[colorAttributes[attr]]==='undefined'||attributes[attr]===''){continue;}if(typeof attributes[attr]==='undefined'){if(!fabric.Object.prototype[attr]){continue;}attributes[attr]=fabric.Object.prototype[attr];}if(attributes[attr].indexOf('url(')===0){continue;}var color=new fabric.Color(attributes[attr]);attributes[attr]=color.setAlpha(toFixed(color.getAlpha()*attributes[colorAttributes[attr]],2)).toRgba();}return attributes;}/**\n   * @private\n   */function _getMultipleNodes(doc,nodeNames){var nodeName,nodeArray=[],nodeList,i,len;for(i=0,len=nodeNames.length;i<len;i++){nodeName=nodeNames[i];nodeList=doc.getElementsByTagName(nodeName);nodeArray=nodeArray.concat(Array.prototype.slice.call(nodeList));}return nodeArray;}/**\n   * Parses \"transform\" attribute, returning an array of values\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {String} attributeValue String containing attribute value\n   * @return {Array} Array of 6 elements representing transformation matrix\n   */fabric.parseTransformAttribute=function(){function rotateMatrix(matrix,args){var cos=fabric.util.cos(args[0]),sin=fabric.util.sin(args[0]),x=0,y=0;if(args.length===3){x=args[1];y=args[2];}matrix[0]=cos;matrix[1]=sin;matrix[2]=-sin;matrix[3]=cos;matrix[4]=x-(cos*x-sin*y);matrix[5]=y-(sin*x+cos*y);}function scaleMatrix(matrix,args){var multiplierX=args[0],multiplierY=args.length===2?args[1]:args[0];matrix[0]=multiplierX;matrix[3]=multiplierY;}function skewMatrix(matrix,args,pos){matrix[pos]=Math.tan(fabric.util.degreesToRadians(args[0]));}function translateMatrix(matrix,args){matrix[4]=args[0];if(args.length===2){matrix[5]=args[1];}}// identity matrix\nvar iMatrix=fabric.iMatrix,// == begin transform regexp\nnumber=fabric.reNum,commaWsp=fabric.commaWsp,skewX='(?:(skewX)\\\\s*\\\\(\\\\s*('+number+')\\\\s*\\\\))',skewY='(?:(skewY)\\\\s*\\\\(\\\\s*('+number+')\\\\s*\\\\))',rotate='(?:(rotate)\\\\s*\\\\(\\\\s*('+number+')(?:'+commaWsp+'('+number+')'+commaWsp+'('+number+'))?\\\\s*\\\\))',scale='(?:(scale)\\\\s*\\\\(\\\\s*('+number+')(?:'+commaWsp+'('+number+'))?\\\\s*\\\\))',translate='(?:(translate)\\\\s*\\\\(\\\\s*('+number+')(?:'+commaWsp+'('+number+'))?\\\\s*\\\\))',matrix='(?:(matrix)\\\\s*\\\\(\\\\s*'+'('+number+')'+commaWsp+'('+number+')'+commaWsp+'('+number+')'+commaWsp+'('+number+')'+commaWsp+'('+number+')'+commaWsp+'('+number+')'+'\\\\s*\\\\))',transform='(?:'+matrix+'|'+translate+'|'+scale+'|'+rotate+'|'+skewX+'|'+skewY+')',transforms='(?:'+transform+'(?:'+commaWsp+'*'+transform+')*'+')',transformList='^\\\\s*(?:'+transforms+'?)\\\\s*$',// http://www.w3.org/TR/SVG/coords.html#TransformAttribute\nreTransformList=new RegExp(transformList),// == end transform regexp\nreTransform=new RegExp(transform,'g');return function(attributeValue){// start with identity matrix\nvar matrix=iMatrix.concat(),matrices=[];// return if no argument was given or\n// an argument does not match transform attribute regexp\nif(!attributeValue||attributeValue&&!reTransformList.test(attributeValue)){return matrix;}attributeValue.replace(reTransform,function(match){var m=new RegExp(transform).exec(match).filter(function(match){// match !== '' && match != null\nreturn!!match;}),operation=m[1],args=m.slice(2).map(parseFloat);switch(operation){case'translate':translateMatrix(matrix,args);break;case'rotate':args[0]=fabric.util.degreesToRadians(args[0]);rotateMatrix(matrix,args);break;case'scale':scaleMatrix(matrix,args);break;case'skewX':skewMatrix(matrix,args,2);break;case'skewY':skewMatrix(matrix,args,1);break;case'matrix':matrix=args;break;}// snapshot current matrix into matrices array\nmatrices.push(matrix.concat());// reset\nmatrix=iMatrix.concat();});var combinedMatrix=matrices[0];while(matrices.length>1){matrices.shift();combinedMatrix=fabric.util.multiplyTransformMatrices(combinedMatrix,matrices[0]);}return combinedMatrix;};}();/**\n   * @private\n   */function parseStyleString(style,oStyle){var attr,value;style.replace(/;\\s*$/,'').split(';').forEach(function(chunk){var pair=chunk.split(':');attr=pair[0].trim().toLowerCase();value=pair[1].trim();oStyle[attr]=value;});}/**\n   * @private\n   */function parseStyleObject(style,oStyle){var attr,value;for(var prop in style){if(typeof style[prop]==='undefined'){continue;}attr=prop.toLowerCase();value=style[prop];oStyle[attr]=value;}}/**\n   * @private\n   */function getGlobalStylesForElement(element,svgUid){var styles={};for(var rule in fabric.cssRules[svgUid]){if(elementMatchesRule(element,rule.split(' '))){for(var property in fabric.cssRules[svgUid][rule]){styles[property]=fabric.cssRules[svgUid][rule][property];}}}return styles;}/**\n   * @private\n   */function elementMatchesRule(element,selectors){var firstMatching,parentMatching=true;//start from rightmost selector.\nfirstMatching=selectorMatches(element,selectors.pop());if(firstMatching&&selectors.length){parentMatching=doesSomeParentMatch(element,selectors);}return firstMatching&&parentMatching&&selectors.length===0;}function doesSomeParentMatch(element,selectors){var selector,parentMatching=true;while(element.parentNode&&element.parentNode.nodeType===1&&selectors.length){if(parentMatching){selector=selectors.pop();}element=element.parentNode;parentMatching=selectorMatches(element,selector);}return selectors.length===0;}/**\n   * @private\n   */function selectorMatches(element,selector){var nodeName=element.nodeName,classNames=element.getAttribute('class'),id=element.getAttribute('id'),matcher,i;// i check if a selector matches slicing away part from it.\n// if i get empty string i should match\nmatcher=new RegExp('^'+nodeName,'i');selector=selector.replace(matcher,'');if(id&&selector.length){matcher=new RegExp('#'+id+'(?![a-zA-Z\\\\-]+)','i');selector=selector.replace(matcher,'');}if(classNames&&selector.length){classNames=classNames.split(' ');for(i=classNames.length;i--;){matcher=new RegExp('\\\\.'+classNames[i]+'(?![a-zA-Z\\\\-]+)','i');selector=selector.replace(matcher,'');}}return selector.length===0;}/**\n   * @private\n   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM\n   */function elementById(doc,id){var el;doc.getElementById&&(el=doc.getElementById(id));if(el){return el;}var node,i,len,nodelist=doc.getElementsByTagName('*');for(i=0,len=nodelist.length;i<len;i++){node=nodelist[i];if(id===node.getAttribute('id')){return node;}}}/**\n   * @private\n   */function parseUseDirectives(doc){var nodelist=_getMultipleNodes(doc,['use','svg:use']),i=0;while(nodelist.length&&i<nodelist.length){var el=nodelist[i],xlinkAttribute=el.getAttribute('xlink:href')||el.getAttribute('href');if(xlinkAttribute===null){return;}var xlink=xlinkAttribute.substr(1),x=el.getAttribute('x')||0,y=el.getAttribute('y')||0,el2=elementById(doc,xlink).cloneNode(true),currentTrans=(el2.getAttribute('transform')||'')+' translate('+x+', '+y+')',parentNode,oldLength=nodelist.length,attr,j,attrs,len,namespace=fabric.svgNS;applyViewboxTransform(el2);if(/^svg$/i.test(el2.nodeName)){var el3=el2.ownerDocument.createElementNS(namespace,'g');for(j=0,attrs=el2.attributes,len=attrs.length;j<len;j++){attr=attrs.item(j);el3.setAttributeNS(namespace,attr.nodeName,attr.nodeValue);}// el2.firstChild != null\nwhile(el2.firstChild){el3.appendChild(el2.firstChild);}el2=el3;}for(j=0,attrs=el.attributes,len=attrs.length;j<len;j++){attr=attrs.item(j);if(attr.nodeName==='x'||attr.nodeName==='y'||attr.nodeName==='xlink:href'||attr.nodeName==='href'){continue;}if(attr.nodeName==='transform'){currentTrans=attr.nodeValue+' '+currentTrans;}else{el2.setAttribute(attr.nodeName,attr.nodeValue);}}el2.setAttribute('transform',currentTrans);el2.setAttribute('instantiated_by_use','1');el2.removeAttribute('id');parentNode=el.parentNode;parentNode.replaceChild(el2,el);// some browsers do not shorten nodelist after replaceChild (IE8)\nif(nodelist.length===oldLength){i++;}}}// http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\n// matches, e.g.: +14.56e-12, etc.\nvar reViewBoxAttrValue=new RegExp('^'+'\\\\s*('+fabric.reNum+'+)\\\\s*,?'+'\\\\s*('+fabric.reNum+'+)\\\\s*,?'+'\\\\s*('+fabric.reNum+'+)\\\\s*,?'+'\\\\s*('+fabric.reNum+'+)\\\\s*'+'$');/**\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\n   */function applyViewboxTransform(element){if(!fabric.svgViewBoxElementsRegEx.test(element.nodeName)){return{};}var viewBoxAttr=element.getAttribute('viewBox'),scaleX=1,scaleY=1,minX=0,minY=0,viewBoxWidth,viewBoxHeight,matrix,el,widthAttr=element.getAttribute('width'),heightAttr=element.getAttribute('height'),x=element.getAttribute('x')||0,y=element.getAttribute('y')||0,preserveAspectRatio=element.getAttribute('preserveAspectRatio')||'',missingViewBox=!viewBoxAttr||!(viewBoxAttr=viewBoxAttr.match(reViewBoxAttrValue)),missingDimAttr=!widthAttr||!heightAttr||widthAttr==='100%'||heightAttr==='100%',toBeParsed=missingViewBox&&missingDimAttr,parsedDim={},translateMatrix='',widthDiff=0,heightDiff=0;parsedDim.width=0;parsedDim.height=0;parsedDim.toBeParsed=toBeParsed;if(missingViewBox){if((x||y)&&element.parentNode&&element.parentNode.nodeName!=='#document'){translateMatrix=' translate('+parseUnit(x)+' '+parseUnit(y)+') ';matrix=(element.getAttribute('transform')||'')+translateMatrix;element.setAttribute('transform',matrix);element.removeAttribute('x');element.removeAttribute('y');}}if(toBeParsed){return parsedDim;}if(missingViewBox){parsedDim.width=parseUnit(widthAttr);parsedDim.height=parseUnit(heightAttr);// set a transform for elements that have x y and are inner(only) SVGs\nreturn parsedDim;}minX=-parseFloat(viewBoxAttr[1]);minY=-parseFloat(viewBoxAttr[2]);viewBoxWidth=parseFloat(viewBoxAttr[3]);viewBoxHeight=parseFloat(viewBoxAttr[4]);parsedDim.minX=minX;parsedDim.minY=minY;parsedDim.viewBoxWidth=viewBoxWidth;parsedDim.viewBoxHeight=viewBoxHeight;if(!missingDimAttr){parsedDim.width=parseUnit(widthAttr);parsedDim.height=parseUnit(heightAttr);scaleX=parsedDim.width/viewBoxWidth;scaleY=parsedDim.height/viewBoxHeight;}else{parsedDim.width=viewBoxWidth;parsedDim.height=viewBoxHeight;}// default is to preserve aspect ratio\npreserveAspectRatio=fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);if(preserveAspectRatio.alignX!=='none'){//translate all container for the effect of Mid, Min, Max\nif(preserveAspectRatio.meetOrSlice==='meet'){scaleY=scaleX=scaleX>scaleY?scaleY:scaleX;// calculate additional translation to move the viewbox\n}if(preserveAspectRatio.meetOrSlice==='slice'){scaleY=scaleX=scaleX>scaleY?scaleX:scaleY;// calculate additional translation to move the viewbox\n}widthDiff=parsedDim.width-viewBoxWidth*scaleX;heightDiff=parsedDim.height-viewBoxHeight*scaleX;if(preserveAspectRatio.alignX==='Mid'){widthDiff/=2;}if(preserveAspectRatio.alignY==='Mid'){heightDiff/=2;}if(preserveAspectRatio.alignX==='Min'){widthDiff=0;}if(preserveAspectRatio.alignY==='Min'){heightDiff=0;}}if(scaleX===1&&scaleY===1&&minX===0&&minY===0&&x===0&&y===0){return parsedDim;}if((x||y)&&element.parentNode.nodeName!=='#document'){translateMatrix=' translate('+parseUnit(x)+' '+parseUnit(y)+') ';}matrix=translateMatrix+' matrix('+scaleX+' 0'+' 0 '+scaleY+' '+(minX*scaleX+widthDiff)+' '+(minY*scaleY+heightDiff)+') ';// seems unused.\n// parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);\nif(element.nodeName==='svg'){el=element.ownerDocument.createElementNS(fabric.svgNS,'g');// element.firstChild != null\nwhile(element.firstChild){el.appendChild(element.firstChild);}element.appendChild(el);}else{el=element;el.removeAttribute('x');el.removeAttribute('y');matrix=el.getAttribute('transform')+matrix;}el.setAttribute('transform',matrix);return parsedDim;}function hasAncestorWithNodeName(element,nodeName){while(element&&(element=element.parentNode)){if(element.nodeName&&nodeName.test(element.nodeName.replace('svg:',''))&&!element.getAttribute('instantiated_by_use')){return true;}}return false;}/**\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {SVGDocument} doc SVG document to parse\n   * @param {Function} callback Callback to call when parsing is finished;\n   * It's being passed an array of elements (parsed from a document).\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n   * @param {Object} [parsingOptions] options for parsing document\n   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings\n   */fabric.parseSVGDocument=function(doc,callback,reviver,parsingOptions){if(!doc){return;}parseUseDirectives(doc);var svgUid=fabric.Object.__uid++,i,len,options=applyViewboxTransform(doc),descendants=fabric.util.toArray(doc.getElementsByTagName('*'));options.crossOrigin=parsingOptions&&parsingOptions.crossOrigin;options.svgUid=svgUid;if(descendants.length===0&&fabric.isLikelyNode){// we're likely in node, where \"o3-xml\" library fails to gEBTN(\"*\")\n// https://github.com/ajaxorg/node-o3-xml/issues/21\ndescendants=doc.selectNodes('//*[name(.)!=\"svg\"]');var arr=[];for(i=0,len=descendants.length;i<len;i++){arr[i]=descendants[i];}descendants=arr;}var elements=descendants.filter(function(el){applyViewboxTransform(el);return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:',''))&&!hasAncestorWithNodeName(el,fabric.svgInvalidAncestorsRegEx);// http://www.w3.org/TR/SVG/struct.html#DefsElement\n});if(!elements||elements&&!elements.length){callback&&callback([],{});return;}var clipPaths={};descendants.filter(function(el){return el.nodeName.replace('svg:','')==='clipPath';}).forEach(function(el){var id=el.getAttribute('id');clipPaths[id]=fabric.util.toArray(el.getElementsByTagName('*')).filter(function(el){return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:',''));});});fabric.gradientDefs[svgUid]=fabric.getGradientDefs(doc);fabric.cssRules[svgUid]=fabric.getCSSRules(doc);fabric.clipPaths[svgUid]=clipPaths;// Precedence of rules:   style > class > attribute\nfabric.parseElements(elements,function(instances,elements){if(callback){callback(instances,options,elements,descendants);delete fabric.gradientDefs[svgUid];delete fabric.cssRules[svgUid];delete fabric.clipPaths[svgUid];}},clone(options),reviver,parsingOptions);};function recursivelyParseGradientsXlink(doc,gradient){var gradientsAttrs=['gradientTransform','x1','x2','y1','y2','gradientUnits','cx','cy','r','fx','fy'],xlinkAttr='xlink:href',xLink=gradient.getAttribute(xlinkAttr).substr(1),referencedGradient=elementById(doc,xLink);if(referencedGradient&&referencedGradient.getAttribute(xlinkAttr)){recursivelyParseGradientsXlink(doc,referencedGradient);}gradientsAttrs.forEach(function(attr){if(referencedGradient&&!gradient.hasAttribute(attr)&&referencedGradient.hasAttribute(attr)){gradient.setAttribute(attr,referencedGradient.getAttribute(attr));}});if(!gradient.children.length){var referenceClone=referencedGradient.cloneNode(true);while(referenceClone.firstChild){gradient.appendChild(referenceClone.firstChild);}}gradient.removeAttribute(xlinkAttr);}var reFontDeclaration=new RegExp('(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*'+'(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*('+fabric.reNum+'(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|'+fabric.reNum+'))?\\\\s+(.*)');extend(fabric,{/**\n     * Parses a short font declaration, building adding its properties to a style object\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {String} value font declaration\n     * @param {Object} oStyle definition\n     */parseFontDeclaration:function(value,oStyle){var match=value.match(reFontDeclaration);if(!match){return;}var fontStyle=match[1],// font variant is not used\n// fontVariant = match[2],\nfontWeight=match[3],fontSize=match[4],lineHeight=match[5],fontFamily=match[6];if(fontStyle){oStyle.fontStyle=fontStyle;}if(fontWeight){oStyle.fontWeight=isNaN(parseFloat(fontWeight))?fontWeight:parseFloat(fontWeight);}if(fontSize){oStyle.fontSize=parseUnit(fontSize);}if(fontFamily){oStyle.fontFamily=fontFamily;}if(lineHeight){oStyle.lineHeight=lineHeight==='normal'?1:lineHeight;}},/**\n     * Parses an SVG document, returning all of the gradient declarations found in it\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\n     */getGradientDefs:function(doc){var tagArray=['linearGradient','radialGradient','svg:linearGradient','svg:radialGradient'],elList=_getMultipleNodes(doc,tagArray),el,j=0,gradientDefs={};j=elList.length;while(j--){el=elList[j];if(el.getAttribute('xlink:href')){recursivelyParseGradientsXlink(doc,el);}gradientDefs[el.getAttribute('id')]=el;}return gradientDefs;},/**\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\n     * Parses parent \"g\" nodes recursively upwards.\n     * @static\n     * @memberOf fabric\n     * @param {DOMElement} element Element to parse\n     * @param {Array} attributes Array of attributes to parse\n     * @return {Object} object containing parsed attributes' names/values\n     */parseAttributes:function(element,attributes,svgUid){if(!element){return;}var value,parentAttributes={},fontSize,parentFontSize;if(typeof svgUid==='undefined'){svgUid=element.getAttribute('svgUid');}// if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\nif(element.parentNode&&fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)){parentAttributes=fabric.parseAttributes(element.parentNode,attributes,svgUid);}var ownAttributes=attributes.reduce(function(memo,attr){value=element.getAttribute(attr);if(value){// eslint-disable-line\nmemo[attr]=value;}return memo;},{});// add values parsed from style, which take precedence over attributes\n// (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\nvar cssAttrs=extend(getGlobalStylesForElement(element,svgUid),fabric.parseStyleAttribute(element));ownAttributes=extend(ownAttributes,cssAttrs);if(cssAttrs[cPath]){element.setAttribute(cPath,cssAttrs[cPath]);}fontSize=parentFontSize=parentAttributes.fontSize||fabric.Text.DEFAULT_SVG_FONT_SIZE;if(ownAttributes[fSize]){// looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.\nownAttributes[fSize]=fontSize=parseUnit(ownAttributes[fSize],parentFontSize);}var normalizedAttr,normalizedValue,normalizedStyle={};for(var attr in ownAttributes){normalizedAttr=normalizeAttr(attr);normalizedValue=normalizeValue(normalizedAttr,ownAttributes[attr],parentAttributes,fontSize);normalizedStyle[normalizedAttr]=normalizedValue;}if(normalizedStyle&&normalizedStyle.font){fabric.parseFontDeclaration(normalizedStyle.font,normalizedStyle);}var mergedAttrs=extend(parentAttributes,normalizedStyle);return fabric.svgValidParentsRegEx.test(element.nodeName)?mergedAttrs:_setStrokeFillOpacity(mergedAttrs);},/**\n     * Transforms an array of svg elements to corresponding fabric.* instances\n     * @static\n     * @memberOf fabric\n     * @param {Array} elements Array of elements to parse\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\n     * @param {Object} [options] Options object\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     */parseElements:function(elements,callback,options,reviver,parsingOptions){new fabric.ElementsParser(elements,callback,options,reviver,parsingOptions).parse();},/**\n     * Parses \"style\" attribute, retuning an object with values\n     * @static\n     * @memberOf fabric\n     * @param {SVGElement} element Element to parse\n     * @return {Object} Objects with values parsed from style attribute of an element\n     */parseStyleAttribute:function(element){var oStyle={},style=element.getAttribute('style');if(!style){return oStyle;}if(typeof style==='string'){parseStyleString(style,oStyle);}else{parseStyleObject(style,oStyle);}return oStyle;},/**\n     * Parses \"points\" attribute, returning an array of values\n     * @static\n     * @memberOf fabric\n     * @param {String} points points attribute string\n     * @return {Array} array of points\n     */parsePointsAttribute:function(points){// points attribute is required and must not be empty\nif(!points){return null;}// replace commas with whitespace and remove bookending whitespace\npoints=points.replace(/,/g,' ').trim();points=points.split(/\\s+/);var parsedPoints=[],i,len;for(i=0,len=points.length;i<len;i+=2){parsedPoints.push({x:parseFloat(points[i]),y:parseFloat(points[i+1])});}// odd number of points is an error\n// if (parsedPoints.length % 2 !== 0) {\n//   return null;\n// }\nreturn parsedPoints;},/**\n     * Returns CSS rules for a given SVG document\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} CSS rules of this document\n     */getCSSRules:function(doc){var styles=doc.getElementsByTagName('style'),i,len,allRules={},rules;// very crude parsing of style contents\nfor(i=0,len=styles.length;i<len;i++){var styleContents=styles[i].textContent;// remove comments\nstyleContents=styleContents.replace(/\\/\\*[\\s\\S]*?\\*\\//g,'');if(styleContents.trim()===''){continue;}rules=styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);rules=rules.map(function(rule){return rule.trim();});// eslint-disable-next-line no-loop-func\nrules.forEach(function(rule){var match=rule.match(/([\\s\\S]*?)\\s*\\{([^}]*)\\}/),ruleObj={},declaration=match[2].trim(),propertyValuePairs=declaration.replace(/;$/,'').split(/\\s*;\\s*/);for(i=0,len=propertyValuePairs.length;i<len;i++){var pair=propertyValuePairs[i].split(/\\s*:\\s*/),property=pair[0],value=pair[1];ruleObj[property]=value;}rule=match[1];rule.split(',').forEach(function(_rule){_rule=_rule.replace(/^svg/i,'').trim();if(_rule===''){return;}if(allRules[_rule]){fabric.util.object.extend(allRules[_rule],ruleObj);}else{allRules[_rule]=fabric.util.object.clone(ruleObj);}});});}return allRules;},/**\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.\n     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\n     * @memberOf fabric\n     * @param {String} url\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */loadSVGFromURL:function(url,callback,reviver,options){url=url.replace(/^\\n\\s*/,'').trim();new fabric.util.request(url,{method:'get',onComplete:onComplete});function onComplete(r){var xml=r.responseXML;if(!xml||!xml.documentElement){callback&&callback(null);return false;}fabric.parseSVGDocument(xml.documentElement,function(results,_options,elements,allElements){callback&&callback(results,_options,elements,allElements);},reviver,options);}},/**\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\n     * @memberOf fabric\n     * @param {String} string\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */loadSVGFromString:function(string,callback,reviver,options){var parser=new fabric.window.DOMParser(),doc=parser.parseFromString(string.trim(),'text/xml');fabric.parseSVGDocument(doc.documentElement,function(results,_options,elements,allElements){callback(results,_options,elements,allElements);},reviver,options);}});})( true?exports:0);fabric.ElementsParser=function(elements,callback,options,reviver,parsingOptions,doc){this.elements=elements;this.callback=callback;this.options=options;this.reviver=reviver;this.svgUid=options&&options.svgUid||0;this.parsingOptions=parsingOptions;this.regexUrl=/^url\\(['\"]?#([^'\"]+)['\"]?\\)/g;this.doc=doc;};(function(proto){proto.parse=function(){this.instances=new Array(this.elements.length);this.numElements=this.elements.length;this.createObjects();};proto.createObjects=function(){var _this=this;this.elements.forEach(function(element,i){element.setAttribute('svgUid',_this.svgUid);_this.createObject(element,i);});};proto.findTag=function(el){return fabric[fabric.util.string.capitalize(el.tagName.replace('svg:',''))];};proto.createObject=function(el,index){var klass=this.findTag(el);if(klass&&klass.fromElement){try{klass.fromElement(el,this.createCallback(index,el),this.options);}catch(err){fabric.log(err);}}else{this.checkIfDone();}};proto.createCallback=function(index,el){var _this=this;return function(obj){var _options;_this.resolveGradient(obj,el,'fill');_this.resolveGradient(obj,el,'stroke');if(obj instanceof fabric.Image&&obj._originalElement){_options=obj.parsePreserveAspectRatioAttribute(el);}obj._removeTransformMatrix(_options);_this.resolveClipPath(obj,el);_this.reviver&&_this.reviver(el,obj);_this.instances[index]=obj;_this.checkIfDone();};};proto.extractPropertyDefinition=function(obj,property,storage){var value=obj[property],regex=this.regexUrl;if(!regex.test(value)){return;}regex.lastIndex=0;var id=regex.exec(value)[1];regex.lastIndex=0;return fabric[storage][this.svgUid][id];};proto.resolveGradient=function(obj,el,property){var gradientDef=this.extractPropertyDefinition(obj,property,'gradientDefs');if(gradientDef){var opacityAttr=el.getAttribute(property+'-opacity');var gradient=fabric.Gradient.fromElement(gradientDef,obj,opacityAttr,this.options);obj.set(property,gradient);}};proto.createClipPathCallback=function(obj,container){return function(_newObj){_newObj._removeTransformMatrix();_newObj.fillRule=_newObj.clipRule;container.push(_newObj);};};proto.resolveClipPath=function(obj,usingElement){var clipPath=this.extractPropertyDefinition(obj,'clipPath','clipPaths'),element,klass,objTransformInv,container,gTransform,options;if(clipPath){container=[];objTransformInv=fabric.util.invertTransform(obj.calcTransformMatrix());// move the clipPath tag as sibling to the real element that is using it\nvar clipPathTag=clipPath[0].parentNode;var clipPathOwner=usingElement;while(clipPathOwner.parentNode&&clipPathOwner.getAttribute('clip-path')!==obj.clipPath){clipPathOwner=clipPathOwner.parentNode;}clipPathOwner.parentNode.appendChild(clipPathTag);for(var i=0;i<clipPath.length;i++){element=clipPath[i];klass=this.findTag(element);klass.fromElement(element,this.createClipPathCallback(obj,container),this.options);}if(container.length===1){clipPath=container[0];}else{clipPath=new fabric.Group(container);}gTransform=fabric.util.multiplyTransformMatrices(objTransformInv,clipPath.calcTransformMatrix());if(clipPath.clipPath){this.resolveClipPath(clipPath,clipPathOwner);}var options=fabric.util.qrDecompose(gTransform);clipPath.flipX=false;clipPath.flipY=false;clipPath.set('scaleX',options.scaleX);clipPath.set('scaleY',options.scaleY);clipPath.angle=options.angle;clipPath.skewX=options.skewX;clipPath.skewY=0;clipPath.setPositionByOrigin({x:options.translateX,y:options.translateY},'center','center');obj.clipPath=clipPath;}else{// if clip-path does not resolve to any element, delete the property.\ndelete obj.clipPath;}};proto.checkIfDone=function(){if(--this.numElements===0){this.instances=this.instances.filter(function(el){// eslint-disable-next-line no-eq-null, eqeqeq\nreturn el!=null;});this.callback(this.instances,this.elements);}};})(fabric.ElementsParser.prototype);(function(global){'use strict';/* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */var fabric=global.fabric||(global.fabric={});if(fabric.Point){fabric.warn('fabric.Point is already defined');return;}fabric.Point=Point;/**\n   * Point class\n   * @class fabric.Point\n   * @memberOf fabric\n   * @constructor\n   * @param {Number} x\n   * @param {Number} y\n   * @return {fabric.Point} thisArg\n   */function Point(x,y){this.x=x;this.y=y;}Point.prototype=/** @lends fabric.Point.prototype */{type:'point',constructor:Point,/**\n     * Adds another point to this one and returns another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point instance with added values\n     */add:function(that){return new Point(this.x+that.x,this.y+that.y);},/**\n     * Adds another point to this one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */addEquals:function(that){this.x+=that.x;this.y+=that.y;return this;},/**\n     * Adds value to this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point} new Point with added value\n     */scalarAdd:function(scalar){return new Point(this.x+scalar,this.y+scalar);},/**\n     * Adds value to this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */scalarAddEquals:function(scalar){this.x+=scalar;this.y+=scalar;return this;},/**\n     * Subtracts another point from this point and returns a new one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point object with subtracted values\n     */subtract:function(that){return new Point(this.x-that.x,this.y-that.y);},/**\n     * Subtracts another point from this point\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */subtractEquals:function(that){this.x-=that.x;this.y-=that.y;return this;},/**\n     * Subtracts value from this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */scalarSubtract:function(scalar){return new Point(this.x-scalar,this.y-scalar);},/**\n     * Subtracts value from this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */scalarSubtractEquals:function(scalar){this.x-=scalar;this.y-=scalar;return this;},/**\n     * Multiplies this point by a value and returns a new one\n     * TODO: rename in scalarMultiply in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */multiply:function(scalar){return new Point(this.x*scalar,this.y*scalar);},/**\n     * Multiplies this point by a value\n     * TODO: rename in scalarMultiplyEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */multiplyEquals:function(scalar){this.x*=scalar;this.y*=scalar;return this;},/**\n     * Divides this point by a value and returns a new one\n     * TODO: rename in scalarDivide in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */divide:function(scalar){return new Point(this.x/scalar,this.y/scalar);},/**\n     * Divides this point by a value\n     * TODO: rename in scalarDivideEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */divideEquals:function(scalar){this.x/=scalar;this.y/=scalar;return this;},/**\n     * Returns true if this point is equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */eq:function(that){return this.x===that.x&&this.y===that.y;},/**\n     * Returns true if this point is less than another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */lt:function(that){return this.x<that.x&&this.y<that.y;},/**\n     * Returns true if this point is less than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */lte:function(that){return this.x<=that.x&&this.y<=that.y;},/**\n\n     * Returns true if this point is greater another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */gt:function(that){return this.x>that.x&&this.y>that.y;},/**\n     * Returns true if this point is greater than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */gte:function(that){return this.x>=that.x&&this.y>=that.y;},/**\n     * Returns new point which is the result of linear interpolation with this one and another one\n     * @param {fabric.Point} that\n     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5\n     * @return {fabric.Point}\n     */lerp:function(that,t){if(typeof t==='undefined'){t=0.5;}t=Math.max(Math.min(1,t),0);return new Point(this.x+(that.x-this.x)*t,this.y+(that.y-this.y)*t);},/**\n     * Returns distance from this point and another one\n     * @param {fabric.Point} that\n     * @return {Number}\n     */distanceFrom:function(that){var dx=this.x-that.x,dy=this.y-that.y;return Math.sqrt(dx*dx+dy*dy);},/**\n     * Returns the point between this point and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */midPointFrom:function(that){return this.lerp(that);},/**\n     * Returns a new point which is the min of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */min:function(that){return new Point(Math.min(this.x,that.x),Math.min(this.y,that.y));},/**\n     * Returns a new point which is the max of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */max:function(that){return new Point(Math.max(this.x,that.x),Math.max(this.y,that.y));},/**\n     * Returns string representation of this point\n     * @return {String}\n     */toString:function(){return this.x+','+this.y;},/**\n     * Sets x/y of this point\n     * @param {Number} x\n     * @param {Number} y\n     * @chainable\n     */setXY:function(x,y){this.x=x;this.y=y;return this;},/**\n     * Sets x of this point\n     * @param {Number} x\n     * @chainable\n     */setX:function(x){this.x=x;return this;},/**\n     * Sets y of this point\n     * @param {Number} y\n     * @chainable\n     */setY:function(y){this.y=y;return this;},/**\n     * Sets x/y of this point from another point\n     * @param {fabric.Point} that\n     * @chainable\n     */setFromPoint:function(that){this.x=that.x;this.y=that.y;return this;},/**\n     * Swaps x/y of this point and another point\n     * @param {fabric.Point} that\n     */swap:function(that){var x=this.x,y=this.y;this.x=that.x;this.y=that.y;that.x=x;that.y=y;},/**\n     * return a cloned instance of the point\n     * @return {fabric.Point}\n     */clone:function(){return new Point(this.x,this.y);}};})( true?exports:0);(function(global){'use strict';/* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */var fabric=global.fabric||(global.fabric={});if(fabric.Intersection){fabric.warn('fabric.Intersection is already defined');return;}/**\n   * Intersection class\n   * @class fabric.Intersection\n   * @memberOf fabric\n   * @constructor\n   */function Intersection(status){this.status=status;this.points=[];}fabric.Intersection=Intersection;fabric.Intersection.prototype=/** @lends fabric.Intersection.prototype */{constructor:Intersection,/**\n     * Appends a point to intersection\n     * @param {fabric.Point} point\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */appendPoint:function(point){this.points.push(point);return this;},/**\n     * Appends points to intersection\n     * @param {Array} points\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */appendPoints:function(points){this.points=this.points.concat(points);return this;}};/**\n   * Checks if one line intersects another\n   * TODO: rename in intersectSegmentSegment\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {fabric.Point} b1\n   * @param {fabric.Point} b2\n   * @return {fabric.Intersection}\n   */fabric.Intersection.intersectLineLine=function(a1,a2,b1,b2){var result,uaT=(b2.x-b1.x)*(a1.y-b1.y)-(b2.y-b1.y)*(a1.x-b1.x),ubT=(a2.x-a1.x)*(a1.y-b1.y)-(a2.y-a1.y)*(a1.x-b1.x),uB=(b2.y-b1.y)*(a2.x-a1.x)-(b2.x-b1.x)*(a2.y-a1.y);if(uB!==0){var ua=uaT/uB,ub=ubT/uB;if(0<=ua&&ua<=1&&0<=ub&&ub<=1){result=new Intersection('Intersection');result.appendPoint(new fabric.Point(a1.x+ua*(a2.x-a1.x),a1.y+ua*(a2.y-a1.y)));}else{result=new Intersection();}}else{if(uaT===0||ubT===0){result=new Intersection('Coincident');}else{result=new Intersection('Parallel');}}return result;};/**\n   * Checks if line intersects polygon\n   * TODO: rename in intersectSegmentPolygon\n   * fix detection of coincident\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {Array} points\n   * @return {fabric.Intersection}\n   */fabric.Intersection.intersectLinePolygon=function(a1,a2,points){var result=new Intersection(),length=points.length,b1,b2,inter,i;for(i=0;i<length;i++){b1=points[i];b2=points[(i+1)%length];inter=Intersection.intersectLineLine(a1,a2,b1,b2);result.appendPoints(inter.points);}if(result.points.length>0){result.status='Intersection';}return result;};/**\n   * Checks if polygon intersects another polygon\n   * @static\n   * @param {Array} points1\n   * @param {Array} points2\n   * @return {fabric.Intersection}\n   */fabric.Intersection.intersectPolygonPolygon=function(points1,points2){var result=new Intersection(),length=points1.length,i;for(i=0;i<length;i++){var a1=points1[i],a2=points1[(i+1)%length],inter=Intersection.intersectLinePolygon(a1,a2,points2);result.appendPoints(inter.points);}if(result.points.length>0){result.status='Intersection';}return result;};/**\n   * Checks if polygon intersects rectangle\n   * @static\n   * @param {Array} points\n   * @param {fabric.Point} r1\n   * @param {fabric.Point} r2\n   * @return {fabric.Intersection}\n   */fabric.Intersection.intersectPolygonRectangle=function(points,r1,r2){var min=r1.min(r2),max=r1.max(r2),topRight=new fabric.Point(max.x,min.y),bottomLeft=new fabric.Point(min.x,max.y),inter1=Intersection.intersectLinePolygon(min,topRight,points),inter2=Intersection.intersectLinePolygon(topRight,max,points),inter3=Intersection.intersectLinePolygon(max,bottomLeft,points),inter4=Intersection.intersectLinePolygon(bottomLeft,min,points),result=new Intersection();result.appendPoints(inter1.points);result.appendPoints(inter2.points);result.appendPoints(inter3.points);result.appendPoints(inter4.points);if(result.points.length>0){result.status='Intersection';}return result;};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={});if(fabric.Color){fabric.warn('fabric.Color is already defined.');return;}/**\n   * Color class\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\n   *\n   * @class fabric.Color\n   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list\n   * @return {fabric.Color} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\n   */function Color(color){if(!color){this.setSource([0,0,0,1]);}else{this._tryParsingColor(color);}}fabric.Color=Color;fabric.Color.prototype=/** @lends fabric.Color.prototype */{/**\n     * @private\n     * @param {String|Array} color Color value to parse\n     */_tryParsingColor:function(color){var source;if(color in Color.colorNameMap){color=Color.colorNameMap[color];}if(color==='transparent'){source=[255,255,255,0];}if(!source){source=Color.sourceFromHex(color);}if(!source){source=Color.sourceFromRgb(color);}if(!source){source=Color.sourceFromHsl(color);}if(!source){//if color is not recognize let's make black as canvas does\nsource=[0,0,0,1];}if(source){this.setSource(source);}},/**\n     * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n     * @private\n     * @param {Number} r Red color value\n     * @param {Number} g Green color value\n     * @param {Number} b Blue color value\n     * @return {Array} Hsl color\n     */_rgbToHsl:function(r,g,b){r/=255;g/=255;b/=255;var h,s,l,max=fabric.util.array.max([r,g,b]),min=fabric.util.array.min([r,g,b]);l=(max+min)/2;if(max===min){h=s=0;// achromatic\n}else{var d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return[Math.round(h*360),Math.round(s*100),Math.round(l*100)];},/**\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @return {Array}\n     */getSource:function(){return this._source;},/**\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @param {Array} source\n     */setSource:function(source){this._source=source;},/**\n     * Returns color representation in RGB format\n     * @return {String} ex: rgb(0-255,0-255,0-255)\n     */toRgb:function(){var source=this.getSource();return'rgb('+source[0]+','+source[1]+','+source[2]+')';},/**\n     * Returns color representation in RGBA format\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\n     */toRgba:function(){var source=this.getSource();return'rgba('+source[0]+','+source[1]+','+source[2]+','+source[3]+')';},/**\n     * Returns color representation in HSL format\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\n     */toHsl:function(){var source=this.getSource(),hsl=this._rgbToHsl(source[0],source[1],source[2]);return'hsl('+hsl[0]+','+hsl[1]+'%,'+hsl[2]+'%)';},/**\n     * Returns color representation in HSLA format\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\n     */toHsla:function(){var source=this.getSource(),hsl=this._rgbToHsl(source[0],source[1],source[2]);return'hsla('+hsl[0]+','+hsl[1]+'%,'+hsl[2]+'%,'+source[3]+')';},/**\n     * Returns color representation in HEX format\n     * @return {String} ex: FF5555\n     */toHex:function(){var source=this.getSource(),r,g,b;r=source[0].toString(16);r=r.length===1?'0'+r:r;g=source[1].toString(16);g=g.length===1?'0'+g:g;b=source[2].toString(16);b=b.length===1?'0'+b:b;return r.toUpperCase()+g.toUpperCase()+b.toUpperCase();},/**\n     * Returns color representation in HEXA format\n     * @return {String} ex: FF5555CC\n     */toHexa:function(){var source=this.getSource(),a;a=Math.round(source[3]*255);a=a.toString(16);a=a.length===1?'0'+a:a;return this.toHex()+a.toUpperCase();},/**\n     * Gets value of alpha channel for this color\n     * @return {Number} 0-1\n     */getAlpha:function(){return this.getSource()[3];},/**\n     * Sets value of alpha channel for this color\n     * @param {Number} alpha Alpha value 0-1\n     * @return {fabric.Color} thisArg\n     */setAlpha:function(alpha){var source=this.getSource();source[3]=alpha;this.setSource(source);return this;},/**\n     * Transforms color to its grayscale representation\n     * @return {fabric.Color} thisArg\n     */toGrayscale:function(){var source=this.getSource(),average=parseInt((source[0]*0.3+source[1]*0.59+source[2]*0.11).toFixed(0),10),currentAlpha=source[3];this.setSource([average,average,average,currentAlpha]);return this;},/**\n     * Transforms color to its black and white representation\n     * @param {Number} threshold\n     * @return {fabric.Color} thisArg\n     */toBlackWhite:function(threshold){var source=this.getSource(),average=(source[0]*0.3+source[1]*0.59+source[2]*0.11).toFixed(0),currentAlpha=source[3];threshold=threshold||127;average=Number(average)<Number(threshold)?0:255;this.setSource([average,average,average,currentAlpha]);return this;},/**\n     * Overlays color with another color\n     * @param {String|fabric.Color} otherColor\n     * @return {fabric.Color} thisArg\n     */overlayWith:function(otherColor){if(!(otherColor instanceof Color)){otherColor=new Color(otherColor);}var result=[],alpha=this.getAlpha(),otherAlpha=0.5,source=this.getSource(),otherSource=otherColor.getSource(),i;for(i=0;i<3;i++){result.push(Math.round(source[i]*(1-otherAlpha)+otherSource[i]*otherAlpha));}result[3]=alpha;this.setSource(result);return this;}};/**\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ // eslint-disable-next-line max-len\nfabric.Color.reRGBa=/^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*((?:\\d*\\.?\\d+)?)\\s*)?\\)$/i;/**\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */fabric.Color.reHSLa=/^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i;/**\n   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */fabric.Color.reHex=/^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;/**\n   * Map of the 148 color names with HEX code\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   * @see: https://www.w3.org/TR/css3-color/#svg-color\n   */fabric.Color.colorNameMap={aliceblue:'#F0F8FF',antiquewhite:'#FAEBD7',aqua:'#00FFFF',aquamarine:'#7FFFD4',azure:'#F0FFFF',beige:'#F5F5DC',bisque:'#FFE4C4',black:'#000000',blanchedalmond:'#FFEBCD',blue:'#0000FF',blueviolet:'#8A2BE2',brown:'#A52A2A',burlywood:'#DEB887',cadetblue:'#5F9EA0',chartreuse:'#7FFF00',chocolate:'#D2691E',coral:'#FF7F50',cornflowerblue:'#6495ED',cornsilk:'#FFF8DC',crimson:'#DC143C',cyan:'#00FFFF',darkblue:'#00008B',darkcyan:'#008B8B',darkgoldenrod:'#B8860B',darkgray:'#A9A9A9',darkgrey:'#A9A9A9',darkgreen:'#006400',darkkhaki:'#BDB76B',darkmagenta:'#8B008B',darkolivegreen:'#556B2F',darkorange:'#FF8C00',darkorchid:'#9932CC',darkred:'#8B0000',darksalmon:'#E9967A',darkseagreen:'#8FBC8F',darkslateblue:'#483D8B',darkslategray:'#2F4F4F',darkslategrey:'#2F4F4F',darkturquoise:'#00CED1',darkviolet:'#9400D3',deeppink:'#FF1493',deepskyblue:'#00BFFF',dimgray:'#696969',dimgrey:'#696969',dodgerblue:'#1E90FF',firebrick:'#B22222',floralwhite:'#FFFAF0',forestgreen:'#228B22',fuchsia:'#FF00FF',gainsboro:'#DCDCDC',ghostwhite:'#F8F8FF',gold:'#FFD700',goldenrod:'#DAA520',gray:'#808080',grey:'#808080',green:'#008000',greenyellow:'#ADFF2F',honeydew:'#F0FFF0',hotpink:'#FF69B4',indianred:'#CD5C5C',indigo:'#4B0082',ivory:'#FFFFF0',khaki:'#F0E68C',lavender:'#E6E6FA',lavenderblush:'#FFF0F5',lawngreen:'#7CFC00',lemonchiffon:'#FFFACD',lightblue:'#ADD8E6',lightcoral:'#F08080',lightcyan:'#E0FFFF',lightgoldenrodyellow:'#FAFAD2',lightgray:'#D3D3D3',lightgrey:'#D3D3D3',lightgreen:'#90EE90',lightpink:'#FFB6C1',lightsalmon:'#FFA07A',lightseagreen:'#20B2AA',lightskyblue:'#87CEFA',lightslategray:'#778899',lightslategrey:'#778899',lightsteelblue:'#B0C4DE',lightyellow:'#FFFFE0',lime:'#00FF00',limegreen:'#32CD32',linen:'#FAF0E6',magenta:'#FF00FF',maroon:'#800000',mediumaquamarine:'#66CDAA',mediumblue:'#0000CD',mediumorchid:'#BA55D3',mediumpurple:'#9370DB',mediumseagreen:'#3CB371',mediumslateblue:'#7B68EE',mediumspringgreen:'#00FA9A',mediumturquoise:'#48D1CC',mediumvioletred:'#C71585',midnightblue:'#191970',mintcream:'#F5FFFA',mistyrose:'#FFE4E1',moccasin:'#FFE4B5',navajowhite:'#FFDEAD',navy:'#000080',oldlace:'#FDF5E6',olive:'#808000',olivedrab:'#6B8E23',orange:'#FFA500',orangered:'#FF4500',orchid:'#DA70D6',palegoldenrod:'#EEE8AA',palegreen:'#98FB98',paleturquoise:'#AFEEEE',palevioletred:'#DB7093',papayawhip:'#FFEFD5',peachpuff:'#FFDAB9',peru:'#CD853F',pink:'#FFC0CB',plum:'#DDA0DD',powderblue:'#B0E0E6',purple:'#800080',rebeccapurple:'#663399',red:'#FF0000',rosybrown:'#BC8F8F',royalblue:'#4169E1',saddlebrown:'#8B4513',salmon:'#FA8072',sandybrown:'#F4A460',seagreen:'#2E8B57',seashell:'#FFF5EE',sienna:'#A0522D',silver:'#C0C0C0',skyblue:'#87CEEB',slateblue:'#6A5ACD',slategray:'#708090',slategrey:'#708090',snow:'#FFFAFA',springgreen:'#00FF7F',steelblue:'#4682B4',tan:'#D2B48C',teal:'#008080',thistle:'#D8BFD8',tomato:'#FF6347',turquoise:'#40E0D0',violet:'#EE82EE',wheat:'#F5DEB3',white:'#FFFFFF',whitesmoke:'#F5F5F5',yellow:'#FFFF00',yellowgreen:'#9ACD32'};/**\n   * @private\n   * @param {Number} p\n   * @param {Number} q\n   * @param {Number} t\n   * @return {Number}\n   */function hue2rgb(p,q,t){if(t<0){t+=1;}if(t>1){t-=1;}if(t<1/6){return p+(q-p)*6*t;}if(t<1/2){return q;}if(t<2/3){return p+(q-p)*(2/3-t)*6;}return p;}/**\n   * Returns new color object, when given a color in RGB format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\n   * @return {fabric.Color}\n   */fabric.Color.fromRgb=function(color){return Color.fromSource(Color.sourceFromRgb(color));};/**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\n   * @return {Array} source\n   */fabric.Color.sourceFromRgb=function(color){var match=color.match(Color.reRGBa);if(match){var r=parseInt(match[1],10)/(/%$/.test(match[1])?100:1)*(/%$/.test(match[1])?255:1),g=parseInt(match[2],10)/(/%$/.test(match[2])?100:1)*(/%$/.test(match[2])?255:1),b=parseInt(match[3],10)/(/%$/.test(match[3])?100:1)*(/%$/.test(match[3])?255:1);return[parseInt(r,10),parseInt(g,10),parseInt(b,10),match[4]?parseFloat(match[4]):1];}};/**\n   * Returns new color object, when given a color in RGBA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */fabric.Color.fromRgba=Color.fromRgb;/**\n   * Returns new color object, when given a color in HSL format\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\n   * @memberOf fabric.Color\n   * @return {fabric.Color}\n   */fabric.Color.fromHsl=function(color){return Color.fromSource(Color.sourceFromHsl(color));};/**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\n   * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\n   * @return {Array} source\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\n   */fabric.Color.sourceFromHsl=function(color){var match=color.match(Color.reHSLa);if(!match){return;}var h=(parseFloat(match[1])%360+360)%360/360,s=parseFloat(match[2])/(/%$/.test(match[2])?100:1),l=parseFloat(match[3])/(/%$/.test(match[3])?100:1),r,g,b;if(s===0){r=g=b=l;}else{var q=l<=0.5?l*(s+1):l+s-l*s,p=l*2-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return[Math.round(r*255),Math.round(g*255),Math.round(b*255),match[4]?parseFloat(match[4]):1];};/**\n   * Returns new color object, when given a color in HSLA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */fabric.Color.fromHsla=Color.fromHsl;/**\n   * Returns new color object, when given a color in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: FF5555\n   * @return {fabric.Color}\n   */fabric.Color.fromHex=function(color){return Color.fromSource(Color.sourceFromHex(color));};/**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color ex: FF5555 or FF5544CC (RGBa)\n   * @return {Array} source\n   */fabric.Color.sourceFromHex=function(color){if(color.match(Color.reHex)){var value=color.slice(color.indexOf('#')+1),isShortNotation=value.length===3||value.length===4,isRGBa=value.length===8||value.length===4,r=isShortNotation?value.charAt(0)+value.charAt(0):value.substring(0,2),g=isShortNotation?value.charAt(1)+value.charAt(1):value.substring(2,4),b=isShortNotation?value.charAt(2)+value.charAt(2):value.substring(4,6),a=isRGBa?isShortNotation?value.charAt(3)+value.charAt(3):value.substring(6,8):'FF';return[parseInt(r,16),parseInt(g,16),parseInt(b,16),parseFloat((parseInt(a,16)/255).toFixed(2))];}};/**\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\n   * @static\n   * @memberOf fabric.Color\n   * @param {Array} source\n   * @return {fabric.Color}\n   */fabric.Color.fromSource=function(source){var oColor=new Color();oColor.setSource(source);return oColor;};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),scaleMap=['e','se','s','sw','w','nw','n','ne','e'],skewMap=['ns','nesw','ew','nwse'],controls={},LEFT='left',TOP='top',RIGHT='right',BOTTOM='bottom',CENTER='center',opposite={top:BOTTOM,bottom:TOP,left:RIGHT,right:LEFT,center:CENTER},radiansToDegrees=fabric.util.radiansToDegrees,sign=Math.sign||function(x){return(x>0)-(x<0)||+x;};/**\n   * Combine control position and object angle to find the control direction compared\n   * to the object center.\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   * @param {fabric.Control} control the control class\n   * @return {Number} 0 - 7 a quadrant number\n   */function findCornerQuadrant(fabricObject,control){var cornerAngle=fabricObject.angle+radiansToDegrees(Math.atan2(control.y,control.x))+360;return Math.round(cornerAngle%360/45);}function fireEvent(eventName,options){var target=options.transform.target,canvas=target.canvas,canvasOptions=fabric.util.object.clone(options);canvasOptions.target=target;canvas&&canvas.fire('object:'+eventName,canvasOptions);target.fire(eventName,options);}/**\n   * Inspect event and fabricObject properties to understand if the scaling action\n   * @param {Event} eventData from the user action\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @return {Boolean} true if scale is proportional\n   */function scaleIsProportional(eventData,fabricObject){var canvas=fabricObject.canvas,uniScaleKey=canvas.uniScaleKey,uniformIsToggled=eventData[uniScaleKey];return canvas.uniformScaling&&!uniformIsToggled||!canvas.uniformScaling&&uniformIsToggled;}/**\n   * Checks if transform is centered\n   * @param {Object} transform transform data\n   * @return {Boolean} true if transform is centered\n   */function isTransformCentered(transform){return transform.originX===CENTER&&transform.originY===CENTER;}/**\n   * Inspect fabricObject to understand if the current scaling action is allowed\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @param {String} by 'x' or 'y' or ''\n   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally\n   * @return {Boolean} true if scaling is not allowed at current conditions\n   */function scalingIsForbidden(fabricObject,by,scaleProportionally){var lockX=fabricObject.lockScalingX,lockY=fabricObject.lockScalingY;if(lockX&&lockY){return true;}if(!by&&(lockX||lockY)&&scaleProportionally){return true;}if(lockX&&by==='x'){return true;}if(lockY&&by==='y'){return true;}return false;}/**\n   * return the correct cursor style for the scale action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */function scaleCursorStyleHandler(eventData,control,fabricObject){var notAllowed='not-allowed',scaleProportionally=scaleIsProportional(eventData,fabricObject),by='';if(control.x!==0&&control.y===0){by='x';}else if(control.x===0&&control.y!==0){by='y';}if(scalingIsForbidden(fabricObject,by,scaleProportionally)){return notAllowed;}var n=findCornerQuadrant(fabricObject,control);return scaleMap[n]+'-resize';}/**\n   * return the correct cursor style for the skew action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */function skewCursorStyleHandler(eventData,control,fabricObject){var notAllowed='not-allowed';if(control.x!==0&&fabricObject.lockSkewingY){return notAllowed;}if(control.y!==0&&fabricObject.lockSkewingX){return notAllowed;}var n=findCornerQuadrant(fabricObject,control)%4;return skewMap[n]+'-resize';}/**\n   * Combine skew and scale style handlers to cover fabric standard use case\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */function scaleSkewCursorStyleHandler(eventData,control,fabricObject){if(eventData[fabricObject.canvas.altActionKey]){return controls.skewCursorStyleHandler(eventData,control,fabricObject);}return controls.scaleCursorStyleHandler(eventData,control,fabricObject);}/**\n   * Inspect event, control and fabricObject to return the correct action name\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} an action name\n   */function scaleOrSkewActionName(eventData,control,fabricObject){var isAlternative=eventData[fabricObject.canvas.altActionKey];if(control.x===0){// then is scaleY or skewX\nreturn isAlternative?'skewX':'scaleY';}if(control.y===0){// then is scaleY or skewX\nreturn isAlternative?'skewY':'scaleX';}}/**\n   * Find the correct style for the control that is used for rotation.\n   * this function is very simple and it just take care of not-allowed or standard cursor\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */function rotationStyleHandler(eventData,control,fabricObject){if(fabricObject.lockRotation){return'not-allowed';}return control.cursorStyle;}function commonEventInfo(eventData,transform,x,y){return{e:eventData,transform:transform,pointer:{x:x,y:y}};}/**\n   * Wrap an action handler with saving/restoring object position on the transform.\n   * this is the code that permits to objects to keep their position while transforming.\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */function wrapWithFixedAnchor(actionHandler){return function(eventData,transform,x,y){var target=transform.target,centerPoint=target.getCenterPoint(),constraint=target.translateToOriginPoint(centerPoint,transform.originX,transform.originY),actionPerformed=actionHandler(eventData,transform,x,y);target.setPositionByOrigin(constraint,transform.originX,transform.originY);return actionPerformed;};}/**\n   * Wrap an action handler with firing an event if the action is performed\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */function wrapWithFireEvent(eventName,actionHandler){return function(eventData,transform,x,y){var actionPerformed=actionHandler(eventData,transform,x,y);if(actionPerformed){fireEvent(eventName,commonEventInfo(eventData,transform,x,y));}return actionPerformed;};}/**\n   * Transforms a point described by x and y in a distance from the top left corner of the object\n   * bounding box.\n   * @param {Object} transform\n   * @param {String} originX\n   * @param {String} originY\n   * @param {number} x\n   * @param {number} y\n   * @return {Fabric.Point} the normalized point\n   */function getLocalPoint(transform,originX,originY,x,y){var target=transform.target,control=target.controls[transform.corner],zoom=target.canvas.getZoom(),padding=target.padding/zoom,localPoint=target.toLocalPoint(new fabric.Point(x,y),originX,originY);if(localPoint.x>=padding){localPoint.x-=padding;}if(localPoint.x<=-padding){localPoint.x+=padding;}if(localPoint.y>=padding){localPoint.y-=padding;}if(localPoint.y<=padding){localPoint.y+=padding;}localPoint.x-=control.offsetX;localPoint.y-=control.offsetY;return localPoint;}/**\n   * Detect if the fabric object is flipped on one side.\n   * @param {fabric.Object} target\n   * @return {Boolean} true if one flip, but not two.\n   */function targetHasOneFlip(target){return target.flipX!==target.flipY;}/**\n   * Utility function to compensate the scale factor when skew is applied on both axes\n   * @private\n   */function compensateScaleForSkew(target,oppositeSkew,scaleToCompensate,axis,reference){if(target[oppositeSkew]!==0){var newDim=target._getTransformedDimensions()[axis];var newValue=reference/newDim*target[scaleToCompensate];target.set(scaleToCompensate,newValue);}}/**\n   * Action handler for skewing on the X axis\n   * @private\n   */function skewObjectX(eventData,transform,x,y){var target=transform.target,// find how big the object would be, if there was no skewX. takes in account scaling\ndimNoSkew=target._getTransformedDimensions(0,target.skewY),localPoint=getLocalPoint(transform,transform.originX,transform.originY,x,y),// the mouse is in the center of the object, and we want it to stay there.\n// so the object will grow twice as much as the mouse.\n// this makes the skew growth to localPoint * 2 - dimNoSkew.\ntotalSkewSize=Math.abs(localPoint.x*2)-dimNoSkew.x,currentSkew=target.skewX,newSkew;if(totalSkewSize<2){// let's make it easy to go back to position 0.\nnewSkew=0;}else{newSkew=radiansToDegrees(Math.atan2(totalSkewSize/target.scaleX,dimNoSkew.y/target.scaleY));// now we have to find the sign of the skew.\n// it mostly depend on the origin of transformation.\nif(transform.originX===LEFT&&transform.originY===BOTTOM){newSkew=-newSkew;}if(transform.originX===RIGHT&&transform.originY===TOP){newSkew=-newSkew;}if(targetHasOneFlip(target)){newSkew=-newSkew;}}var hasSkewed=currentSkew!==newSkew;if(hasSkewed){var dimBeforeSkewing=target._getTransformedDimensions().y;target.set('skewX',newSkew);compensateScaleForSkew(target,'skewY','scaleY','y',dimBeforeSkewing);}return hasSkewed;}/**\n   * Action handler for skewing on the Y axis\n   * @private\n   */function skewObjectY(eventData,transform,x,y){var target=transform.target,// find how big the object would be, if there was no skewX. takes in account scaling\ndimNoSkew=target._getTransformedDimensions(target.skewX,0),localPoint=getLocalPoint(transform,transform.originX,transform.originY,x,y),// the mouse is in the center of the object, and we want it to stay there.\n// so the object will grow twice as much as the mouse.\n// this makes the skew growth to localPoint * 2 - dimNoSkew.\ntotalSkewSize=Math.abs(localPoint.y*2)-dimNoSkew.y,currentSkew=target.skewY,newSkew;if(totalSkewSize<2){// let's make it easy to go back to position 0.\nnewSkew=0;}else{newSkew=radiansToDegrees(Math.atan2(totalSkewSize/target.scaleY,dimNoSkew.x/target.scaleX));// now we have to find the sign of the skew.\n// it mostly depend on the origin of transformation.\nif(transform.originX===LEFT&&transform.originY===BOTTOM){newSkew=-newSkew;}if(transform.originX===RIGHT&&transform.originY===TOP){newSkew=-newSkew;}if(targetHasOneFlip(target)){newSkew=-newSkew;}}var hasSkewed=currentSkew!==newSkew;if(hasSkewed){var dimBeforeSkewing=target._getTransformedDimensions().x;target.set('skewY',newSkew);compensateScaleForSkew(target,'skewX','scaleX','x',dimBeforeSkewing);}return hasSkewed;}/**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */function skewHandlerX(eventData,transform,x,y){// step1 figure out and change transform origin.\n// if skewX > 0 and originY bottom we anchor on right\n// if skewX > 0 and originY top we anchor on left\n// if skewX < 0 and originY bottom we anchor on left\n// if skewX < 0 and originY top we anchor on right\n// if skewX is 0, we look for mouse position to understand where are we going.\nvar target=transform.target,currentSkew=target.skewX,originX,originY=transform.originY;if(target.lockSkewingX){return false;}if(currentSkew===0){var localPointFromCenter=getLocalPoint(transform,CENTER,CENTER,x,y);if(localPointFromCenter.x>0){// we are pulling right, anchor left;\noriginX=LEFT;}else{// we are pulling right, anchor right\noriginX=RIGHT;}}else{if(currentSkew>0){originX=originY===TOP?LEFT:RIGHT;}if(currentSkew<0){originX=originY===TOP?RIGHT:LEFT;}// is the object flipped on one side only? swap the origin.\nif(targetHasOneFlip(target)){originX=originX===LEFT?RIGHT:LEFT;}}// once we have the origin, we find the anchor point\ntransform.originX=originX;var finalHandler=wrapWithFireEvent('skewing',wrapWithFixedAnchor(skewObjectX));return finalHandler(eventData,transform,x,y);}/**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */function skewHandlerY(eventData,transform,x,y){// step1 figure out and change transform origin.\n// if skewY > 0 and originX left we anchor on top\n// if skewY > 0 and originX right we anchor on bottom\n// if skewY < 0 and originX left we anchor on bottom\n// if skewY < 0 and originX right we anchor on top\n// if skewY is 0, we look for mouse position to understand where are we going.\nvar target=transform.target,currentSkew=target.skewY,originY,originX=transform.originX;if(target.lockSkewingY){return false;}if(currentSkew===0){var localPointFromCenter=getLocalPoint(transform,CENTER,CENTER,x,y);if(localPointFromCenter.y>0){// we are pulling down, anchor up;\noriginY=TOP;}else{// we are pulling up, anchor down\noriginY=BOTTOM;}}else{if(currentSkew>0){originY=originX===LEFT?TOP:BOTTOM;}if(currentSkew<0){originY=originX===LEFT?BOTTOM:TOP;}// is the object flipped on one side only? swap the origin.\nif(targetHasOneFlip(target)){originY=originY===TOP?BOTTOM:TOP;}}// once we have the origin, we find the anchor point\ntransform.originY=originY;var finalHandler=wrapWithFireEvent('skewing',wrapWithFixedAnchor(skewObjectY));return finalHandler(eventData,transform,x,y);}/**\n   * Action handler for rotation and snapping, without anchor point.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   * @private\n   */function rotationWithSnapping(eventData,transform,x,y){var t=transform,target=t.target,pivotPoint=target.translateToOriginPoint(target.getCenterPoint(),t.originX,t.originY);if(target.lockRotation){return false;}var lastAngle=Math.atan2(t.ey-pivotPoint.y,t.ex-pivotPoint.x),curAngle=Math.atan2(y-pivotPoint.y,x-pivotPoint.x),angle=radiansToDegrees(curAngle-lastAngle+t.theta),hasRotated=true;if(target.snapAngle>0){var snapAngle=target.snapAngle,snapThreshold=target.snapThreshold||snapAngle,rightAngleLocked=Math.ceil(angle/snapAngle)*snapAngle,leftAngleLocked=Math.floor(angle/snapAngle)*snapAngle;if(Math.abs(angle-leftAngleLocked)<snapThreshold){angle=leftAngleLocked;}else if(Math.abs(angle-rightAngleLocked)<snapThreshold){angle=rightAngleLocked;}}// normalize angle to positive value\nif(angle<0){angle=360+angle;}angle%=360;hasRotated=target.angle!==angle;target.angle=angle;return hasRotated;}/**\n   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @param {Object} options additional information for scaling\n   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling\n   * @return {Boolean} true if some change happened\n   * @private\n   */function scaleObject(eventData,transform,x,y,options){options=options||{};var target=transform.target,lockScalingX=target.lockScalingX,lockScalingY=target.lockScalingY,by=options.by,newPoint,scaleX,scaleY,dim,scaleProportionally=scaleIsProportional(eventData,target),forbidScaling=scalingIsForbidden(target,by,scaleProportionally),signX,signY,gestureScale=transform.gestureScale;if(forbidScaling){return false;}if(gestureScale){scaleX=transform.scaleX*gestureScale;scaleY=transform.scaleY*gestureScale;}else{newPoint=getLocalPoint(transform,transform.originX,transform.originY,x,y);// use of sign: We use sign to detect change of direction of an action. sign usually change when\n// we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling\n// by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily\n// cross many time the origin point and flip the object. so we need a way to filter out the noise.\n// This ternary here should be ok to filter out X scaling when we want Y only and vice versa.\nsignX=by!=='y'?sign(newPoint.x):1;signY=by!=='x'?sign(newPoint.y):1;if(!transform.signX){transform.signX=signX;}if(!transform.signY){transform.signY=signY;}if(target.lockScalingFlip&&(transform.signX!==signX||transform.signY!==signY)){return false;}dim=target._getTransformedDimensions();// missing detection of flip and logic to switch the origin\nif(scaleProportionally&&!by){// uniform scaling\nvar distance=Math.abs(newPoint.x)+Math.abs(newPoint.y),original=transform.original,originalDistance=Math.abs(dim.x*original.scaleX/target.scaleX)+Math.abs(dim.y*original.scaleY/target.scaleY),scale=distance/originalDistance;scaleX=original.scaleX*scale;scaleY=original.scaleY*scale;}else{scaleX=Math.abs(newPoint.x*target.scaleX/dim.x);scaleY=Math.abs(newPoint.y*target.scaleY/dim.y);}// if we are scaling by center, we need to double the scale\nif(isTransformCentered(transform)){scaleX*=2;scaleY*=2;}if(transform.signX!==signX&&by!=='y'){transform.originX=opposite[transform.originX];scaleX*=-1;transform.signX=signX;}if(transform.signY!==signY&&by!=='x'){transform.originY=opposite[transform.originY];scaleY*=-1;transform.signY=signY;}}// minScale is taken are in the setter.\nvar oldScaleX=target.scaleX,oldScaleY=target.scaleY;if(!by){!lockScalingX&&target.set('scaleX',scaleX);!lockScalingY&&target.set('scaleY',scaleY);}else{// forbidden cases already handled on top here.\nby==='x'&&target.set('scaleX',scaleX);by==='y'&&target.set('scaleY',scaleY);}return oldScaleX!==target.scaleX||oldScaleY!==target.scaleY;}/**\n   * Generic scaling logic, to scale from corners either equally or freely.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */function scaleObjectFromCorner(eventData,transform,x,y){return scaleObject(eventData,transform,x,y);}/**\n   * Scaling logic for the X axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */function scaleObjectX(eventData,transform,x,y){return scaleObject(eventData,transform,x,y,{by:'x'});}/**\n   * Scaling logic for the Y axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */function scaleObjectY(eventData,transform,x,y){return scaleObject(eventData,transform,x,y,{by:'y'});}/**\n   * Composed action handler to either scale Y or skew X\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */function scalingYOrSkewingX(eventData,transform,x,y){// ok some safety needed here.\nif(eventData[transform.target.canvas.altActionKey]){return controls.skewHandlerX(eventData,transform,x,y);}return controls.scalingY(eventData,transform,x,y);}/**\n   * Composed action handler to either scale X or skew Y\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */function scalingXOrSkewingY(eventData,transform,x,y){// ok some safety needed here.\nif(eventData[transform.target.canvas.altActionKey]){return controls.skewHandlerY(eventData,transform,x,y);}return controls.scalingX(eventData,transform,x,y);}/**\n   * Action handler to change textbox width\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */function changeWidth(eventData,transform,x,y){var target=transform.target,localPoint=getLocalPoint(transform,transform.originX,transform.originY,x,y),strokePadding=target.strokeWidth/(target.strokeUniform?target.scaleX:1),multiplier=isTransformCentered(transform)?2:1,oldWidth=target.width,newWidth=Math.abs(localPoint.x*multiplier/target.scaleX)-strokePadding;target.set('width',Math.max(newWidth,0));return oldWidth!==newWidth;}/**\n   * Action handler\n   * @private\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if the translation occurred\n   */function dragHandler(eventData,transform,x,y){var target=transform.target,newLeft=x-transform.offsetX,newTop=y-transform.offsetY,moveX=!target.get('lockMovementX')&&target.left!==newLeft,moveY=!target.get('lockMovementY')&&target.top!==newTop;moveX&&target.set('left',newLeft);moveY&&target.set('top',newTop);if(moveX||moveY){fireEvent('moving',commonEventInfo(eventData,transform,x,y));}return moveX||moveY;}controls.scaleCursorStyleHandler=scaleCursorStyleHandler;controls.skewCursorStyleHandler=skewCursorStyleHandler;controls.scaleSkewCursorStyleHandler=scaleSkewCursorStyleHandler;controls.rotationWithSnapping=wrapWithFireEvent('rotating',wrapWithFixedAnchor(rotationWithSnapping));controls.scalingEqually=wrapWithFireEvent('scaling',wrapWithFixedAnchor(scaleObjectFromCorner));controls.scalingX=wrapWithFireEvent('scaling',wrapWithFixedAnchor(scaleObjectX));controls.scalingY=wrapWithFireEvent('scaling',wrapWithFixedAnchor(scaleObjectY));controls.scalingYOrSkewingX=scalingYOrSkewingX;controls.scalingXOrSkewingY=scalingXOrSkewingY;controls.changeWidth=wrapWithFireEvent('resizing',wrapWithFixedAnchor(changeWidth));controls.skewHandlerX=skewHandlerX;controls.skewHandlerY=skewHandlerY;controls.dragHandler=dragHandler;controls.scaleOrSkewActionName=scaleOrSkewActionName;controls.rotationStyleHandler=rotationStyleHandler;controls.fireEvent=fireEvent;controls.wrapWithFixedAnchor=wrapWithFixedAnchor;controls.wrapWithFireEvent=wrapWithFireEvent;controls.getLocalPoint=getLocalPoint;fabric.controlsUtils=controls;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),degreesToRadians=fabric.util.degreesToRadians,controls=fabric.controlsUtils;/**\n   * Render a round control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */function renderCircleControl(ctx,left,top,styleOverride,fabricObject){styleOverride=styleOverride||{};var xSize=this.sizeX||styleOverride.cornerSize||fabricObject.cornerSize,ySize=this.sizeY||styleOverride.cornerSize||fabricObject.cornerSize,transparentCorners=typeof styleOverride.transparentCorners!=='undefined'?styleOverride.transparentCorners:fabricObject.transparentCorners,methodName=transparentCorners?'stroke':'fill',stroke=!transparentCorners&&(styleOverride.cornerStrokeColor||fabricObject.cornerStrokeColor),myLeft=left,myTop=top,size;ctx.save();ctx.fillStyle=styleOverride.cornerColor||fabricObject.cornerColor;ctx.strokeStyle=styleOverride.cornerStrokeColor||fabricObject.cornerStrokeColor;// as soon as fabric react v5, remove ie11, use proper ellipse code.\nif(xSize>ySize){size=xSize;ctx.scale(1.0,ySize/xSize);myTop=top*xSize/ySize;}else if(ySize>xSize){size=ySize;ctx.scale(xSize/ySize,1.0);myLeft=left*ySize/xSize;}else{size=xSize;}// this is still wrong\nctx.lineWidth=1;ctx.beginPath();ctx.arc(myLeft,myTop,size/2,0,2*Math.PI,false);ctx[methodName]();if(stroke){ctx.stroke();}ctx.restore();}/**\n   * Render a square control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */function renderSquareControl(ctx,left,top,styleOverride,fabricObject){styleOverride=styleOverride||{};var xSize=this.sizeX||styleOverride.cornerSize||fabricObject.cornerSize,ySize=this.sizeY||styleOverride.cornerSize||fabricObject.cornerSize,transparentCorners=typeof styleOverride.transparentCorners!=='undefined'?styleOverride.transparentCorners:fabricObject.transparentCorners,methodName=transparentCorners?'stroke':'fill',stroke=!transparentCorners&&(styleOverride.cornerStrokeColor||fabricObject.cornerStrokeColor),xSizeBy2=xSize/2,ySizeBy2=ySize/2;ctx.save();ctx.fillStyle=styleOverride.cornerColor||fabricObject.cornerColor;ctx.strokeStyle=styleOverride.cornerStrokeColor||fabricObject.cornerStrokeColor;// this is still wrong\nctx.lineWidth=1;ctx.translate(left,top);ctx.rotate(degreesToRadians(fabricObject.angle));// this does not work, and fixed with ( && ) does not make sense.\n// to have real transparent corners we need the controls on upperCanvas\n// transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\nctx[methodName+'Rect'](-xSizeBy2,-ySizeBy2,xSize,ySize);if(stroke){ctx.strokeRect(-xSizeBy2,-ySizeBy2,xSize,ySize);}ctx.restore();}controls.renderCircleControl=renderCircleControl;controls.renderSquareControl=renderSquareControl;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={});function Control(options){for(var i in options){this[i]=options[i];}}fabric.Control=Control;fabric.Control.prototype=/** @lends fabric.Control.prototype */{/**\n     * keep track of control visibility.\n     * mainly for backward compatibility.\n     * if you do not want to see a control, you can remove it\n     * from the controlset.\n     * @type {Boolean}\n     * @default true\n     */visible:true,/**\n     * Name of the action that the control will likely execute.\n     * This is optional. FabricJS uses to identify what the user is doing for some\n     * extra optimizations. If you are writing a custom control and you want to know\n     * somewhere else in the code what is going on, you can use this string here.\n     * you can also provide a custom getActionName if your control run multiple actions\n     * depending on some external state.\n     * default to scale since is the most common, used on 4 corners by default\n     * @type {String}\n     * @default 'scale'\n     */actionName:'scale',/**\n     * Drawing angle of the control.\n     * NOT used for now, but name marked as needed for internal logic\n     * example: to reuse the same drawing function for different rotated controls\n     * @type {Number}\n     * @default 0\n     */angle:0,/**\n     * Relative position of the control. X\n     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */x:0,/**\n     * Relative position of the control. Y\n     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */y:0,/**\n     * Horizontal offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the right, negative to the left.\n     * It used when you want to have position of control that does not scale with\n     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on\n     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will\n     * stay 30 pixels no matter how the object is big. Another example is having 2\n     * controls in the corner, that stay in the same position when the object scale.\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */offsetX:0,/**\n     * Vertical offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the bottom, negative to the top.\n     * @type {Number}\n     * @default 0\n     */offsetY:0,/**\n     * Sets the length of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */sizeX:null,/**\n     * Sets the height of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */sizeY:null,/**\n     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */touchSizeX:null,/**\n     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */touchSizeY:null,/**\n     * Css cursor style to display when the control is hovered.\n     * if the method `cursorStyleHandler` is provided, this property is ignored.\n     * @type {String}\n     * @default 'crosshair'\n     */cursorStyle:'crosshair',/**\n     * If controls has an offsetY or offsetX, draw a line that connects\n     * the control to the bounding box\n     * @type {Boolean}\n     * @default false\n     */withConnection:false,/**\n     * The control actionHandler, provide one to handle action ( control being moved )\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */actionHandler:function/* eventData, transformData, x, y */(){},/**\n     * The control handler for mouse down, provide one to handle mouse down on control\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */mouseDownHandler:function/* eventData, transformData, x, y */(){},/**\n     * The control mouseUpHandler, provide one to handle an effect on mouse up.\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */mouseUpHandler:function/* eventData, transformData, x, y */(){},/**\n     * Returns control actionHandler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */getActionHandler:function/* eventData, fabricObject, control */(){return this.actionHandler;},/**\n     * Returns control mouseDown handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */getMouseDownHandler:function/* eventData, fabricObject, control */(){return this.mouseDownHandler;},/**\n     * Returns control mouseUp handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */getMouseUpHandler:function/* eventData, fabricObject, control */(){return this.mouseUpHandler;},/**\n     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate\n     * function you can pass one in the constructor\n     * the cursorStyle property\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */cursorStyleHandler:function(eventData,control/* fabricObject */){return control.cursorStyle;},/**\n     * Returns the action name. The basic implementation just return the actionName property.\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */getActionName:function(eventData,control/* fabricObject */){return control.actionName;},/**\n     * Returns controls visibility\n     * @param {fabric.Object} object on which the control is displayed\n     * @param {String} controlKey key where the control is memorized on the\n     * @return {Boolean}\n     */getVisibility:function(fabricObject,controlKey){var objectVisibility=fabricObject._controlsVisibility;if(objectVisibility&&typeof objectVisibility[controlKey]!=='undefined'){return objectVisibility[controlKey];}return this.visible;},/**\n     * Sets controls visibility\n     * @param {Boolean} visibility for the object\n     * @return {Void}\n     */setVisibility:function(visibility/* name, fabricObject */){this.visible=visibility;},positionHandler:function(dim,finalMatrix/*, fabricObject, currentControl */){var point=fabric.util.transformPoint({x:this.x*dim.x+this.offsetX,y:this.y*dim.y+this.offsetY},finalMatrix);return point;},/**\n     * Returns the coords for this control based on object values.\n     * @param {Number} objectAngle angle from the fabric object holding the control\n     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if\n     *   isTouch is true)\n     * @param {Number} centerX x coordinate where the control center should be\n     * @param {Number} centerY y coordinate where the control center should be\n     * @param {boolean} isTouch true if touch corner, false if normal corner\n     */calcCornerCoords:function(objectAngle,objectCornerSize,centerX,centerY,isTouch){var cosHalfOffset,sinHalfOffset,cosHalfOffsetComp,sinHalfOffsetComp,xSize=isTouch?this.touchSizeX:this.sizeX,ySize=isTouch?this.touchSizeY:this.sizeY;if(xSize&&ySize&&xSize!==ySize){// handle rectangular corners\nvar controlTriangleAngle=Math.atan2(ySize,xSize);var cornerHypotenuse=Math.sqrt(xSize*xSize+ySize*ySize)/2;var newTheta=controlTriangleAngle-fabric.util.degreesToRadians(objectAngle);var newThetaComp=Math.PI/2-controlTriangleAngle-fabric.util.degreesToRadians(objectAngle);cosHalfOffset=cornerHypotenuse*fabric.util.cos(newTheta);sinHalfOffset=cornerHypotenuse*fabric.util.sin(newTheta);// use complementary angle for two corners\ncosHalfOffsetComp=cornerHypotenuse*fabric.util.cos(newThetaComp);sinHalfOffsetComp=cornerHypotenuse*fabric.util.sin(newThetaComp);}else{// handle square corners\n// use default object corner size unless size is defined\nvar cornerSize=xSize&&ySize?xSize:objectCornerSize;/* 0.7071067812 stands for sqrt(2)/2 */cornerHypotenuse=cornerSize*0.7071067812;// complementary angles are equal since they're both 45 degrees\nvar newTheta=fabric.util.degreesToRadians(45-objectAngle);cosHalfOffset=cosHalfOffsetComp=cornerHypotenuse*fabric.util.cos(newTheta);sinHalfOffset=sinHalfOffsetComp=cornerHypotenuse*fabric.util.sin(newTheta);}return{tl:{x:centerX-sinHalfOffsetComp,y:centerY-cosHalfOffsetComp},tr:{x:centerX+cosHalfOffset,y:centerY-sinHalfOffset},bl:{x:centerX-cosHalfOffset,y:centerY+sinHalfOffset},br:{x:centerX+sinHalfOffsetComp,y:centerY+cosHalfOffsetComp}};},/**\n    * Render function for the control.\n    * When this function runs the context is unscaled. unrotate. Just retina scaled.\n    * all the functions will have to translate to the point left,top before starting Drawing\n    * if they want to draw a control where the position is detected.\n    * left and top are the result of the positionHandler function\n    * @param {RenderingContext2D} ctx the context where the control will be drawn\n    * @param {Number} left position of the canvas where we are about to render the control.\n    * @param {Number} top position of the canvas where we are about to render the control.\n    * @param {Object} styleOverride\n    * @param {fabric.Object} fabricObject the object where the control is about to be rendered\n    */render:function(ctx,left,top,styleOverride,fabricObject){styleOverride=styleOverride||{};switch(styleOverride.cornerStyle||fabricObject.cornerStyle){case'circle':fabric.controlsUtils.renderCircleControl.call(this,ctx,left,top,styleOverride,fabricObject);break;default:fabric.controlsUtils.renderSquareControl.call(this,ctx,left,top,styleOverride,fabricObject);}}};})( true?exports:0);(function(){/* _FROM_SVG_START_ */function getColorStop(el,multiplier){var style=el.getAttribute('style'),offset=el.getAttribute('offset')||0,color,colorAlpha,opacity,i;// convert percents to absolute values\noffset=parseFloat(offset)/(/%$/.test(offset)?100:1);offset=offset<0?0:offset>1?1:offset;if(style){var keyValuePairs=style.split(/\\s*;\\s*/);if(keyValuePairs[keyValuePairs.length-1]===''){keyValuePairs.pop();}for(i=keyValuePairs.length;i--;){var split=keyValuePairs[i].split(/\\s*:\\s*/),key=split[0].trim(),value=split[1].trim();if(key==='stop-color'){color=value;}else if(key==='stop-opacity'){opacity=value;}}}if(!color){color=el.getAttribute('stop-color')||'rgb(0,0,0)';}if(!opacity){opacity=el.getAttribute('stop-opacity');}color=new fabric.Color(color);colorAlpha=color.getAlpha();opacity=isNaN(parseFloat(opacity))?1:parseFloat(opacity);opacity*=colorAlpha*multiplier;return{offset:offset,color:color.toRgb(),opacity:opacity};}function getLinearCoords(el){return{x1:el.getAttribute('x1')||0,y1:el.getAttribute('y1')||0,x2:el.getAttribute('x2')||'100%',y2:el.getAttribute('y2')||0};}function getRadialCoords(el){return{x1:el.getAttribute('fx')||el.getAttribute('cx')||'50%',y1:el.getAttribute('fy')||el.getAttribute('cy')||'50%',r1:0,x2:el.getAttribute('cx')||'50%',y2:el.getAttribute('cy')||'50%',r2:el.getAttribute('r')||'50%'};}/* _FROM_SVG_END_ */var clone=fabric.util.object.clone;/**\n   * Gradient class\n   * @class fabric.Gradient\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}\n   * @see {@link fabric.Gradient#initialize} for constructor definition\n   */fabric.Gradient=fabric.util.createClass(/** @lends fabric.Gradient.prototype */{/**\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */offsetX:0,/**\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */offsetY:0,/**\n     * A transform matrix to apply to the gradient before painting.\n     * Imported from svg gradients, is not applied with the current transform in the center.\n     * Before this transform is applied, the origin point is at the top left corner of the object\n     * plus the addition of offsetY and offsetX.\n     * @type Number[]\n     * @default null\n     */gradientTransform:null,/**\n     * coordinates units for coords.\n     * If `pixels`, the number of coords are in the same unit of width / height.\n     * If set as `percentage` the coords are still a number, but 1 means 100% of width\n     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.\n     * allowed values pixels or percentage.\n     * @type String\n     * @default 'pixels'\n     */gradientUnits:'pixels',/**\n     * Gradient type linear or radial\n     * @type String\n     * @default 'pixels'\n     */type:'linear',/**\n     * Constructor\n     * @param {Object} options Options object with type, coords, gradientUnits and colorStops\n     * @param {Object} [options.type] gradient type linear or radial\n     * @param {Object} [options.gradientUnits] gradient units\n     * @param {Object} [options.offsetX] SVG import compatibility\n     * @param {Object} [options.offsetY] SVG import compatibility\n     * @param {Object[]} options.colorStops contains the colorstops.\n     * @param {Object} options.coords contains the coords of the gradient\n     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle\n     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle\n     * @return {fabric.Gradient} thisArg\n     */initialize:function(options){options||(options={});options.coords||(options.coords={});var coords,_this=this;// sets everything, then coords and colorstops get sets again\nObject.keys(options).forEach(function(option){_this[option]=options[option];});if(this.id){this.id+='_'+fabric.Object.__uid++;}else{this.id=fabric.Object.__uid++;}coords={x1:options.coords.x1||0,y1:options.coords.y1||0,x2:options.coords.x2||0,y2:options.coords.y2||0};if(this.type==='radial'){coords.r1=options.coords.r1||0;coords.r2=options.coords.r2||0;}this.coords=coords;this.colorStops=options.colorStops.slice();},/**\n     * Adds another colorStop\n     * @param {Object} colorStop Object with offset and color\n     * @return {fabric.Gradient} thisArg\n     */addColorStop:function(colorStops){for(var position in colorStops){var color=new fabric.Color(colorStops[position]);this.colorStops.push({offset:parseFloat(position),color:color.toRgb(),opacity:color.getAlpha()});}return this;},/**\n     * Returns object representation of a gradient\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object}\n     */toObject:function(propertiesToInclude){var object={type:this.type,coords:this.coords,colorStops:this.colorStops,offsetX:this.offsetX,offsetY:this.offsetY,gradientUnits:this.gradientUnits,gradientTransform:this.gradientTransform?this.gradientTransform.concat():this.gradientTransform};fabric.util.populateWithProperties(this,object,propertiesToInclude);return object;},/* _TO_SVG_START_ */ /**\n     * Returns SVG representation of an gradient\n     * @param {Object} object Object to create a gradient for\n     * @return {String} SVG representation of an gradient (linear/radial)\n     */toSVG:function(object,options){var coords=clone(this.coords,true),i,len,options=options||{},markup,commonAttributes,colorStops=clone(this.colorStops,true),needsSwap=coords.r1>coords.r2,transform=this.gradientTransform?this.gradientTransform.concat():fabric.iMatrix.concat(),offsetX=-this.offsetX,offsetY=-this.offsetY,withViewport=!!options.additionalTransform,gradientUnits=this.gradientUnits==='pixels'?'userSpaceOnUse':'objectBoundingBox';// colorStops must be sorted ascending\ncolorStops.sort(function(a,b){return a.offset-b.offset;});if(gradientUnits==='objectBoundingBox'){offsetX/=object.width;offsetY/=object.height;}else{offsetX+=object.width/2;offsetY+=object.height/2;}if(object.type==='path'&&this.gradientUnits!=='percentage'){offsetX-=object.pathOffset.x;offsetY-=object.pathOffset.y;}transform[4]-=offsetX;transform[5]-=offsetY;commonAttributes='id=\"SVGID_'+this.id+'\" gradientUnits=\"'+gradientUnits+'\"';commonAttributes+=' gradientTransform=\"'+(withViewport?options.additionalTransform+' ':'')+fabric.util.matrixToSVG(transform)+'\" ';if(this.type==='linear'){markup=['<linearGradient ',commonAttributes,' x1=\"',coords.x1,'\" y1=\"',coords.y1,'\" x2=\"',coords.x2,'\" y2=\"',coords.y2,'\">\\n'];}else if(this.type==='radial'){// svg radial gradient has just 1 radius. the biggest.\nmarkup=['<radialGradient ',commonAttributes,' cx=\"',needsSwap?coords.x1:coords.x2,'\" cy=\"',needsSwap?coords.y1:coords.y2,'\" r=\"',needsSwap?coords.r1:coords.r2,'\" fx=\"',needsSwap?coords.x2:coords.x1,'\" fy=\"',needsSwap?coords.y2:coords.y1,'\">\\n'];}if(this.type==='radial'){if(needsSwap){// svg goes from internal to external radius. if radius are inverted, swap color stops.\ncolorStops=colorStops.concat();colorStops.reverse();for(i=0,len=colorStops.length;i<len;i++){colorStops[i].offset=1-colorStops[i].offset;}}var minRadius=Math.min(coords.r1,coords.r2);if(minRadius>0){// i have to shift all colorStops and add new one in 0.\nvar maxRadius=Math.max(coords.r1,coords.r2),percentageShift=minRadius/maxRadius;for(i=0,len=colorStops.length;i<len;i++){colorStops[i].offset+=percentageShift*(1-colorStops[i].offset);}}}for(i=0,len=colorStops.length;i<len;i++){var colorStop=colorStops[i];markup.push('<stop ','offset=\"',colorStop.offset*100+'%','\" style=\"stop-color:',colorStop.color,typeof colorStop.opacity!=='undefined'?';stop-opacity: '+colorStop.opacity:';','\"/>\\n');}markup.push(this.type==='linear'?'</linearGradient>\\n':'</radialGradient>\\n');return markup.join('');},/* _TO_SVG_END_ */ /**\n     * Returns an instance of CanvasGradient\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {CanvasGradient}\n     */toLive:function(ctx){var gradient,coords=fabric.util.object.clone(this.coords),i,len;if(!this.type){return;}if(this.type==='linear'){gradient=ctx.createLinearGradient(coords.x1,coords.y1,coords.x2,coords.y2);}else if(this.type==='radial'){gradient=ctx.createRadialGradient(coords.x1,coords.y1,coords.r1,coords.x2,coords.y2,coords.r2);}for(i=0,len=this.colorStops.length;i<len;i++){var color=this.colorStops[i].color,opacity=this.colorStops[i].opacity,offset=this.colorStops[i].offset;if(typeof opacity!=='undefined'){color=new fabric.Color(color).setAlpha(opacity).toRgba();}gradient.addColorStop(offset,color);}return gradient;}});fabric.util.object.extend(fabric.Gradient,{/* _FROM_SVG_START_ */ /**\n     * Returns {@link fabric.Gradient} instance from an SVG element\n     * @static\n     * @memberOf fabric.Gradient\n     * @param {SVGGradientElement} el SVG gradient element\n     * @param {fabric.Object} instance\n     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.\n     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients\n     * that uses gradientUnits as 'userSpaceOnUse' and percentages.\n     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg\n     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg\n     * @param {Object.number} width width part of the svg tag if viewBox is not specified\n     * @param {Object.number} height height part of the svg tag if viewBox is not specified\n     * @return {fabric.Gradient} Gradient instance\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\n     */fromElement:function(el,instance,opacityAttr,svgOptions){/**\n       *  @example:\n       *\n       *  <linearGradient id=\"linearGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\"/>\n       *    <stop offset=\"100%\" stop-color=\"black\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <linearGradient id=\"linearGrad2\">\n       *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\n       *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\n       *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *  </radialGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad2\">\n       *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\n       *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\n       *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\n       *  </radialGradient>\n       *\n       */var multiplier=parseFloat(opacityAttr)/(/%$/.test(opacityAttr)?100:1);multiplier=multiplier<0?0:multiplier>1?1:multiplier;if(isNaN(multiplier)){multiplier=1;}var colorStopEls=el.getElementsByTagName('stop'),type,gradientUnits=el.getAttribute('gradientUnits')==='userSpaceOnUse'?'pixels':'percentage',gradientTransform=el.getAttribute('gradientTransform')||'',colorStops=[],coords,i,offsetX=0,offsetY=0,transformMatrix;if(el.nodeName==='linearGradient'||el.nodeName==='LINEARGRADIENT'){type='linear';coords=getLinearCoords(el);}else{type='radial';coords=getRadialCoords(el);}for(i=colorStopEls.length;i--;){colorStops.push(getColorStop(colorStopEls[i],multiplier));}transformMatrix=fabric.parseTransformAttribute(gradientTransform);__convertPercentUnitsToValues(instance,coords,svgOptions,gradientUnits);if(gradientUnits==='pixels'){offsetX=-instance.left;offsetY=-instance.top;}var gradient=new fabric.Gradient({id:el.getAttribute('id'),type:type,coords:coords,colorStops:colorStops,gradientUnits:gradientUnits,gradientTransform:transformMatrix,offsetX:offsetX,offsetY:offsetY});return gradient;}/* _FROM_SVG_END_ */});/**\n   * @private\n   */function __convertPercentUnitsToValues(instance,options,svgOptions,gradientUnits){var propValue,finalValue;Object.keys(options).forEach(function(prop){propValue=options[prop];if(propValue==='Infinity'){finalValue=1;}else if(propValue==='-Infinity'){finalValue=0;}else{finalValue=parseFloat(options[prop],10);if(typeof propValue==='string'&&/^(\\d+\\.\\d+)%|(\\d+)%$/.test(propValue)){finalValue*=0.01;if(gradientUnits==='pixels'){// then we need to fix those percentages here in svg parsing\nif(prop==='x1'||prop==='x2'||prop==='r2'){finalValue*=svgOptions.viewBoxWidth||svgOptions.width;}if(prop==='y1'||prop==='y2'){finalValue*=svgOptions.viewBoxHeight||svgOptions.height;}}}}options[prop]=finalValue;});}})();(function(){'use strict';var toFixed=fabric.util.toFixed;/**\n   * Pattern class\n   * @class fabric.Pattern\n   * @see {@link http://fabricjs.com/patterns|Pattern demo}\n   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}\n   * @see {@link fabric.Pattern#initialize} for constructor definition\n   */fabric.Pattern=fabric.util.createClass(/** @lends fabric.Pattern.prototype */{/**\n     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\n     * @type String\n     * @default\n     */repeat:'repeat',/**\n     * Pattern horizontal offset from object's left/top corner\n     * @type Number\n     * @default\n     */offsetX:0,/**\n     * Pattern vertical offset from object's left/top corner\n     * @type Number\n     * @default\n     */offsetY:0,/**\n     * crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @type String\n     * @default\n     */crossOrigin:'',/**\n     * transform matrix to change the pattern, imported from svgs.\n     * @type Array\n     * @default\n     */patternTransform:null,/**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @param {Function} [callback] function to invoke after callback init.\n     * @return {fabric.Pattern} thisArg\n     */initialize:function(options,callback){options||(options={});this.id=fabric.Object.__uid++;this.setOptions(options);if(!options.source||options.source&&typeof options.source!=='string'){callback&&callback(this);return;}else{// img src string\nvar _this=this;this.source=fabric.util.createImage();fabric.util.loadImage(options.source,function(img,isError){_this.source=img;callback&&callback(_this,isError);},null,this.crossOrigin);}},/**\n     * Returns object representation of a pattern\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of a pattern instance\n     */toObject:function(propertiesToInclude){var NUM_FRACTION_DIGITS=fabric.Object.NUM_FRACTION_DIGITS,source,object;// <img> element\nif(typeof this.source.src==='string'){source=this.source.src;}// <canvas> element\nelse if(typeof this.source==='object'&&this.source.toDataURL){source=this.source.toDataURL();}object={type:'pattern',source:source,repeat:this.repeat,crossOrigin:this.crossOrigin,offsetX:toFixed(this.offsetX,NUM_FRACTION_DIGITS),offsetY:toFixed(this.offsetY,NUM_FRACTION_DIGITS),patternTransform:this.patternTransform?this.patternTransform.concat():null};fabric.util.populateWithProperties(this,object,propertiesToInclude);return object;},/* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a pattern\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a pattern\n     */toSVG:function(object){var patternSource=typeof this.source==='function'?this.source():this.source,patternWidth=patternSource.width/object.width,patternHeight=patternSource.height/object.height,patternOffsetX=this.offsetX/object.width,patternOffsetY=this.offsetY/object.height,patternImgSrc='';if(this.repeat==='repeat-x'||this.repeat==='no-repeat'){patternHeight=1;if(patternOffsetY){patternHeight+=Math.abs(patternOffsetY);}}if(this.repeat==='repeat-y'||this.repeat==='no-repeat'){patternWidth=1;if(patternOffsetX){patternWidth+=Math.abs(patternOffsetX);}}if(patternSource.src){patternImgSrc=patternSource.src;}else if(patternSource.toDataURL){patternImgSrc=patternSource.toDataURL();}return'<pattern id=\"SVGID_'+this.id+'\" x=\"'+patternOffsetX+'\" y=\"'+patternOffsetY+'\" width=\"'+patternWidth+'\" height=\"'+patternHeight+'\">\\n'+'<image x=\"0\" y=\"0\"'+' width=\"'+patternSource.width+'\" height=\"'+patternSource.height+'\" xlink:href=\"'+patternImgSrc+'\"></image>\\n'+'</pattern>\\n';},/* _TO_SVG_END_ */setOptions:function(options){for(var prop in options){this[prop]=options[prop];}},/**\n     * Returns an instance of CanvasPattern\n     * @param {CanvasRenderingContext2D} ctx Context to create pattern\n     * @return {CanvasPattern}\n     */toLive:function(ctx){var source=this.source;// if the image failed to load, return, and allow rest to continue loading\nif(!source){return'';}// if an image\nif(typeof source.src!=='undefined'){if(!source.complete){return'';}if(source.naturalWidth===0||source.naturalHeight===0){return'';}}return ctx.createPattern(source,this.repeat);}});})();(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),toFixed=fabric.util.toFixed;if(fabric.Shadow){fabric.warn('fabric.Shadow is already defined.');return;}/**\n   * Shadow class\n   * @class fabric.Shadow\n   * @see {@link http://fabricjs.com/shadows|Shadow demo}\n   * @see {@link fabric.Shadow#initialize} for constructor definition\n   */fabric.Shadow=fabric.util.createClass(/** @lends fabric.Shadow.prototype */{/**\n     * Shadow color\n     * @type String\n     * @default\n     */color:'rgb(0,0,0)',/**\n     * Shadow blur\n     * @type Number\n     */blur:0,/**\n     * Shadow horizontal offset\n     * @type Number\n     * @default\n     */offsetX:0,/**\n     * Shadow vertical offset\n     * @type Number\n     * @default\n     */offsetY:0,/**\n     * Whether the shadow should affect stroke operations\n     * @type Boolean\n     * @default\n     */affectStroke:false,/**\n     * Indicates whether toObject should include default values\n     * @type Boolean\n     * @default\n     */includeDefaultValues:true,/**\n     * When `false`, the shadow will scale with the object.\n     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.\n     * default to false\n     * @type Boolean\n     * @default\n     */nonScaling:false,/**\n     * Constructor\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px\")\n     * @return {fabric.Shadow} thisArg\n     */initialize:function(options){if(typeof options==='string'){options=this._parseShadow(options);}for(var prop in options){this[prop]=options[prop];}this.id=fabric.Object.__uid++;},/**\n     * @private\n     * @param {String} shadow Shadow value to parse\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\n     */_parseShadow:function(shadow){var shadowStr=shadow.trim(),offsetsAndBlur=fabric.Shadow.reOffsetsAndBlur.exec(shadowStr)||[],color=shadowStr.replace(fabric.Shadow.reOffsetsAndBlur,'')||'rgb(0,0,0)';return{color:color.trim(),offsetX:parseFloat(offsetsAndBlur[1],10)||0,offsetY:parseFloat(offsetsAndBlur[2],10)||0,blur:parseFloat(offsetsAndBlur[3],10)||0};},/**\n     * Returns a string representation of an instance\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\n     * @return {String} Returns CSS3 text-shadow declaration\n     */toString:function(){return[this.offsetX,this.offsetY,this.blur,this.color].join('px ');},/* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a shadow\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a shadow\n     */toSVG:function(object){var fBoxX=40,fBoxY=40,NUM_FRACTION_DIGITS=fabric.Object.NUM_FRACTION_DIGITS,offset=fabric.util.rotateVector({x:this.offsetX,y:this.offsetY},fabric.util.degreesToRadians(-object.angle)),BLUR_BOX=20,color=new fabric.Color(this.color);if(object.width&&object.height){//http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\n// we add some extra space to filter box to contain the blur ( 20 )\nfBoxX=toFixed((Math.abs(offset.x)+this.blur)/object.width,NUM_FRACTION_DIGITS)*100+BLUR_BOX;fBoxY=toFixed((Math.abs(offset.y)+this.blur)/object.height,NUM_FRACTION_DIGITS)*100+BLUR_BOX;}if(object.flipX){offset.x*=-1;}if(object.flipY){offset.y*=-1;}return'<filter id=\"SVGID_'+this.id+'\" y=\"-'+fBoxY+'%\" height=\"'+(100+2*fBoxY)+'%\" '+'x=\"-'+fBoxX+'%\" width=\"'+(100+2*fBoxX)+'%\" '+'>\\n'+'\\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"'+toFixed(this.blur?this.blur/2:0,NUM_FRACTION_DIGITS)+'\"></feGaussianBlur>\\n'+'\\t<feOffset dx=\"'+toFixed(offset.x,NUM_FRACTION_DIGITS)+'\" dy=\"'+toFixed(offset.y,NUM_FRACTION_DIGITS)+'\" result=\"oBlur\" ></feOffset>\\n'+'\\t<feFlood flood-color=\"'+color.toRgb()+'\" flood-opacity=\"'+color.getAlpha()+'\"/>\\n'+'\\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n'+'\\t<feMerge>\\n'+'\\t\\t<feMergeNode></feMergeNode>\\n'+'\\t\\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n'+'\\t</feMerge>\\n'+'</filter>\\n';},/* _TO_SVG_END_ */ /**\n     * Returns object representation of a shadow\n     * @return {Object} Object representation of a shadow instance\n     */toObject:function(){if(this.includeDefaultValues){return{color:this.color,blur:this.blur,offsetX:this.offsetX,offsetY:this.offsetY,affectStroke:this.affectStroke,nonScaling:this.nonScaling};}var obj={},proto=fabric.Shadow.prototype;['color','blur','offsetX','offsetY','affectStroke','nonScaling'].forEach(function(prop){if(this[prop]!==proto[prop]){obj[prop]=this[prop];}},this);return obj;}});/**\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\n   * @static\n   * @field\n   * @memberOf fabric.Shadow\n   */ // eslint-disable-next-line max-len\nfabric.Shadow.reOffsetsAndBlur=/(?:\\s|^)(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(\\d+(?:\\.\\d*)?(?:px)?)?(?:\\s?|$)(?:$|\\s)/;})( true?exports:0);(function(){'use strict';if(fabric.StaticCanvas){fabric.warn('fabric.StaticCanvas is already defined.');return;}// aliases for faster resolution\nvar extend=fabric.util.object.extend,getElementOffset=fabric.util.getElementOffset,removeFromArray=fabric.util.removeFromArray,toFixed=fabric.util.toFixed,transformPoint=fabric.util.transformPoint,invertTransform=fabric.util.invertTransform,getNodeCanvas=fabric.util.getNodeCanvas,createCanvasElement=fabric.util.createCanvasElement,CANVAS_INIT_ERROR=new Error('Could not initialize `canvas` element');/**\n   * Static canvas class\n   * @class fabric.StaticCanvas\n   * @mixes fabric.Collection\n   * @mixes fabric.Observable\n   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\n   * @fires before:render\n   * @fires after:render\n   * @fires canvas:cleared\n   * @fires object:added\n   * @fires object:removed\n   */fabric.StaticCanvas=fabric.util.createClass(fabric.CommonMethods,/** @lends fabric.StaticCanvas.prototype */{/**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */initialize:function(el,options){options||(options={});this.renderAndResetBound=this.renderAndReset.bind(this);this.requestRenderAllBound=this.requestRenderAll.bind(this);this._initStatic(el,options);},/**\n     * Background color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */backgroundColor:'',/**\n     * Background image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as background, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */backgroundImage:null,/**\n     * Overlay color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\n     * @since 1.3.9\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */overlayColor:'',/**\n     * Overlay image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */overlayImage:null,/**\n     * Indicates whether toObject/toDatalessObject should include default values\n     * if set to false, takes precedence over the object value.\n     * @type Boolean\n     * @default\n     */includeDefaultValues:true,/**\n     * Indicates whether objects' state should be saved\n     * @type Boolean\n     * @default\n     */stateful:false,/**\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},\n     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.\n     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once\n     * since the renders are quequed and executed one per frame.\n     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )\n     * Left default to true to do not break documentation and old app, fiddles.\n     * @type Boolean\n     * @default\n     */renderOnAddRemove:true,/**\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\n     * @type Boolean\n     * @default\n     */controlsAboveOverlay:false,/**\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\n     * @type Boolean\n     * @default\n     */allowTouchScrolling:false,/**\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\n     * @type Boolean\n     * @default\n     */imageSmoothingEnabled:true,/**\n     * The transformation (in the format of Canvas transform) which focuses the viewport\n     * @type Array\n     * @default\n     */viewportTransform:fabric.iMatrix.concat(),/**\n     * if set to false background image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */backgroundVpt:true,/**\n     * if set to false overlya image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */overlayVpt:true,/**\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\n     * @type Boolean\n     * @default\n     */enableRetinaScaling:true,/**\n     * Describe canvas element extension over design\n     * properties are tl,tr,bl,br.\n     * if canvas is not zoomed/panned those points are the four corner of canvas\n     * if canvas is viewportTransformed you those points indicate the extension\n     * of canvas element in plain untrasformed coordinates\n     * The coordinates get updated with @method calcViewportBoundaries.\n     * @memberOf fabric.StaticCanvas.prototype\n     */vptCoords:{},/**\n     * Based on vptCoords and object.aCoords, skip rendering of objects that\n     * are not included in current viewport.\n     * May greatly help in applications with crowded canvas and use of zoom/pan\n     * If One of the corner of the bounding box of the object is on the canvas\n     * the objects get rendered.\n     * @memberOf fabric.StaticCanvas.prototype\n     * @type Boolean\n     * @default\n     */skipOffscreen:true,/**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the canvas has rendered, and the context is placed in the\n     * top left corner of the canvas.\n     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true\n     * @type fabric.Object\n     */clipPath:undefined,/**\n     * @private\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     */_initStatic:function(el,options){var cb=this.requestRenderAllBound;this._objects=[];this._createLowerCanvas(el);this._initOptions(options);// only initialize retina scaling once\nif(!this.interactive){this._initRetinaScaling();}if(options.overlayImage){this.setOverlayImage(options.overlayImage,cb);}if(options.backgroundImage){this.setBackgroundImage(options.backgroundImage,cb);}if(options.backgroundColor){this.setBackgroundColor(options.backgroundColor,cb);}if(options.overlayColor){this.setOverlayColor(options.overlayColor,cb);}this.calcOffset();},/**\n     * @private\n     */_isRetinaScaling:function(){return fabric.devicePixelRatio!==1&&this.enableRetinaScaling;},/**\n     * @private\n     * @return {Number} retinaScaling if applied, otherwise 1;\n     */getRetinaScaling:function(){return this._isRetinaScaling()?fabric.devicePixelRatio:1;},/**\n     * @private\n     */_initRetinaScaling:function(){if(!this._isRetinaScaling()){return;}var scaleRatio=fabric.devicePixelRatio;this.__initRetinaScaling(scaleRatio,this.lowerCanvasEl,this.contextContainer);if(this.upperCanvasEl){this.__initRetinaScaling(scaleRatio,this.upperCanvasEl,this.contextTop);}},__initRetinaScaling:function(scaleRatio,canvas,context){canvas.setAttribute('width',this.width*scaleRatio);canvas.setAttribute('height',this.height*scaleRatio);context.scale(scaleRatio,scaleRatio);},/**\n     * Calculates canvas element offset relative to the document\n     * This method is also attached as \"resize\" event handler of window\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */calcOffset:function(){this._offset=getElementOffset(this.lowerCanvasEl);return this;},/**\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage with different properties</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage loaded from cross-origin</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */setOverlayImage:function(image,callback,options){return this.__setBgOverlayImage('overlayImage',image,callback,options);},/**\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage with different properties</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ // TODO: fix stretched examples\nsetBackgroundImage:function(image,callback,options){return this.__setBgOverlayImage('backgroundImage',image,callback,options);},/**\n     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to\n     * @param {Function} callback Callback to invoke when foreground color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\n     * @example <caption>Normal overlayColor - color value</caption>\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */setOverlayColor:function(overlayColor,callback){return this.__setBgOverlayColor('overlayColor',overlayColor,callback);},/**\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\n     * @param {Function} callback Callback to invoke when background color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\n     * @example <caption>Normal backgroundColor - color value</caption>\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */setBackgroundColor:function(backgroundColor,callback){return this.__setBgOverlayColor('backgroundColor',backgroundColor,callback);},/**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\n     */__setBgOverlayImage:function(property,image,callback,options){if(typeof image==='string'){fabric.util.loadImage(image,function(img,isError){if(img){var instance=new fabric.Image(img,options);this[property]=instance;instance.canvas=this;}callback&&callback(img,isError);},this,options&&options.crossOrigin);}else{options&&image.setOptions(options);this[property]=image;image&&(image.canvas=this);callback&&callback(image,false);}return this;},/**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\n     * @param {Function} [callback] Callback is invoked when color is set\n     */__setBgOverlayColor:function(property,color,callback){this[property]=color;this._initGradient(color,property);this._initPattern(color,property,callback);return this;},/**\n     * @private\n     */_createCanvasElement:function(){var element=createCanvasElement();if(!element){throw CANVAS_INIT_ERROR;}if(!element.style){element.style={};}if(typeof element.getContext==='undefined'){throw CANVAS_INIT_ERROR;}return element;},/**\n     * @private\n     * @param {Object} [options] Options object\n     */_initOptions:function(options){var lowerCanvasEl=this.lowerCanvasEl;this._setOptions(options);this.width=this.width||parseInt(lowerCanvasEl.width,10)||0;this.height=this.height||parseInt(lowerCanvasEl.height,10)||0;if(!this.lowerCanvasEl.style){return;}lowerCanvasEl.width=this.width;lowerCanvasEl.height=this.height;lowerCanvasEl.style.width=this.width+'px';lowerCanvasEl.style.height=this.height+'px';this.viewportTransform=this.viewportTransform.slice();},/**\n     * Creates a bottom canvas\n     * @private\n     * @param {HTMLElement} [canvasEl]\n     */_createLowerCanvas:function(canvasEl){// canvasEl === 'HTMLCanvasElement' does not work on jsdom/node\nif(canvasEl&&canvasEl.getContext){this.lowerCanvasEl=canvasEl;}else{this.lowerCanvasEl=fabric.util.getById(canvasEl)||this._createCanvasElement();}fabric.util.addClass(this.lowerCanvasEl,'lower-canvas');this._originalCanvasStyle=this.lowerCanvasEl.style;if(this.interactive){this._applyCanvasStyle(this.lowerCanvasEl);}this.contextContainer=this.lowerCanvasEl.getContext('2d');},/**\n     * Returns canvas width (in px)\n     * @return {Number}\n     */getWidth:function(){return this.width;},/**\n     * Returns canvas height (in px)\n     * @return {Number}\n     */getHeight:function(){return this.height;},/**\n     * Sets width of this canvas instance\n     * @param {Number|String} value                         Value to set width to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */setWidth:function(value,options){return this.setDimensions({width:value},options);},/**\n     * Sets height of this canvas instance\n     * @param {Number|String} value                         Value to set height to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */setHeight:function(value,options){return this.setDimensions({height:value},options);},/**\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n     * @param {Object}        dimensions                    Object with width/height properties\n     * @param {Number|String} [dimensions.width]            Width of canvas element\n     * @param {Number|String} [dimensions.height]           Height of canvas element\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */setDimensions:function(dimensions,options){var cssValue;options=options||{};for(var prop in dimensions){cssValue=dimensions[prop];if(!options.cssOnly){this._setBackstoreDimension(prop,dimensions[prop]);cssValue+='px';this.hasLostContext=true;}if(!options.backstoreOnly){this._setCssDimension(prop,cssValue);}}if(this._isCurrentlyDrawing){this.freeDrawingBrush&&this.freeDrawingBrush._setBrushStyles();}this._initRetinaScaling();this.calcOffset();if(!options.cssOnly){this.requestRenderAll();}return this;},/**\n     * Helper for setting width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {Number} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */_setBackstoreDimension:function(prop,value){this.lowerCanvasEl[prop]=value;if(this.upperCanvasEl){this.upperCanvasEl[prop]=value;}if(this.cacheCanvasEl){this.cacheCanvasEl[prop]=value;}this[prop]=value;return this;},/**\n     * Helper for setting css width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {String} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */_setCssDimension:function(prop,value){this.lowerCanvasEl.style[prop]=value;if(this.upperCanvasEl){this.upperCanvasEl.style[prop]=value;}if(this.wrapperEl){this.wrapperEl.style[prop]=value;}return this;},/**\n     * Returns canvas zoom level\n     * @return {Number}\n     */getZoom:function(){return this.viewportTransform[0];},/**\n     * Sets viewport transform of this canvas instance\n     * @param {Array} vpt the transform in the form of context.transform\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */setViewportTransform:function(vpt){var activeObject=this._activeObject,backgroundObject=this.backgroundImage,overlayObject=this.overlayImage,object,i,len;this.viewportTransform=vpt;for(i=0,len=this._objects.length;i<len;i++){object=this._objects[i];object.group||object.setCoords(true);}if(activeObject){activeObject.setCoords();}if(backgroundObject){backgroundObject.setCoords(true);}if(overlayObject){overlayObject.setCoords(true);}this.calcViewportBoundaries();this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n     * Sets zoom level of this canvas instance, the zoom centered around point\n     * meaning that following zoom to point with the same point will have the visual\n     * effect of the zoom originating from that point. The point won't move.\n     * It has nothing to do with canvas center or visual center of the viewport.\n     * @param {fabric.Point} point to zoom with respect to\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */zoomToPoint:function(point,value){// TODO: just change the scale, preserve other transformations\nvar before=point,vpt=this.viewportTransform.slice(0);point=transformPoint(point,invertTransform(this.viewportTransform));vpt[0]=value;vpt[3]=value;var after=transformPoint(point,vpt);vpt[4]+=before.x-after.x;vpt[5]+=before.y-after.y;return this.setViewportTransform(vpt);},/**\n     * Sets zoom level of this canvas instance\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */setZoom:function(value){this.zoomToPoint(new fabric.Point(0,0),value);return this;},/**\n     * Pan viewport so as to place point at top left corner of canvas\n     * @param {fabric.Point} point to move to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */absolutePan:function(point){var vpt=this.viewportTransform.slice(0);vpt[4]=-point.x;vpt[5]=-point.y;return this.setViewportTransform(vpt);},/**\n     * Pans viewpoint relatively\n     * @param {fabric.Point} point (position vector) to move by\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */relativePan:function(point){return this.absolutePan(new fabric.Point(-point.x-this.viewportTransform[4],-point.y-this.viewportTransform[5]));},/**\n     * Returns &lt;canvas> element corresponding to this instance\n     * @return {HTMLCanvasElement}\n     */getElement:function(){return this.lowerCanvasEl;},/**\n     * @private\n     * @param {fabric.Object} obj Object that was added\n     */_onObjectAdded:function(obj){this.stateful&&obj.setupState();obj._set('canvas',this);obj.setCoords();this.fire('object:added',{target:obj});obj.fire('added');},/**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */_onObjectRemoved:function(obj){this.fire('object:removed',{target:obj});obj.fire('removed');delete obj.canvas;},/**\n     * Clears specified context of canvas element\n     * @param {CanvasRenderingContext2D} ctx Context to clear\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */clearContext:function(ctx){ctx.clearRect(0,0,this.width,this.height);return this;},/**\n     * Returns context of canvas where objects are drawn\n     * @return {CanvasRenderingContext2D}\n     */getContext:function(){return this.contextContainer;},/**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */clear:function(){this.remove.apply(this,this.getObjects());this.backgroundImage=null;this.overlayImage=null;this.backgroundColor='';this.overlayColor='';if(this._hasITextHandlers){this.off('mouse:up',this._mouseUpITextHandler);this._iTextInstances=null;this._hasITextHandlers=false;}this.clearContext(this.contextContainer);this.fire('canvas:cleared');this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n     * Renders the canvas\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */renderAll:function(){var canvasToDrawOn=this.contextContainer;this.renderCanvas(canvasToDrawOn,this._objects);return this;},/**\n     * Function created to be instance bound at initialization\n     * used in requestAnimationFrame rendering\n     * Let the fabricJS call it. If you call it manually you could have more\n     * animationFrame stacking on to of each other\n     * for an imperative rendering, use canvas.renderAll\n     * @private\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */renderAndReset:function(){this.isRendering=0;this.renderAll();},/**\n     * Append a renderAll request to next animation frame.\n     * unless one is already in progress, in that case nothing is done\n     * a boolean flag will avoid appending more.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */requestRenderAll:function(){if(!this.isRendering){this.isRendering=fabric.util.requestAnimFrame(this.renderAndResetBound);}return this;},/**\n     * Calculate the position of the 4 corner of canvas with current viewportTransform.\n     * helps to determinate when an object is in the current rendering viewport using\n     * object absolute coordinates ( aCoords )\n     * @return {Object} points.tl\n     * @chainable\n     */calcViewportBoundaries:function(){var points={},width=this.width,height=this.height,iVpt=invertTransform(this.viewportTransform);points.tl=transformPoint({x:0,y:0},iVpt);points.br=transformPoint({x:width,y:height},iVpt);points.tr=new fabric.Point(points.br.x,points.tl.y);points.bl=new fabric.Point(points.tl.x,points.br.y);this.vptCoords=points;return points;},cancelRequestedRender:function(){if(this.isRendering){fabric.util.cancelAnimFrame(this.isRendering);this.isRendering=0;}},/**\n     * Renders background, objects, overlay and controls.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array} objects to render\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */renderCanvas:function(ctx,objects){var v=this.viewportTransform,path=this.clipPath;this.cancelRequestedRender();this.calcViewportBoundaries();this.clearContext(ctx);fabric.util.setImageSmoothing(ctx,this.imageSmoothingEnabled);this.fire('before:render',{ctx:ctx});this._renderBackground(ctx);ctx.save();//apply viewport transform once for all rendering process\nctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]);this._renderObjects(ctx,objects);ctx.restore();if(!this.controlsAboveOverlay&&this.interactive){this.drawControls(ctx);}if(path){path.canvas=this;// needed to setup a couple of variables\npath.shouldCache();path._transformDone=true;path.renderCache({forClipping:true});this.drawClipPathOnCanvas(ctx);}this._renderOverlay(ctx);if(this.controlsAboveOverlay&&this.interactive){this.drawControls(ctx);}this.fire('after:render',{ctx:ctx});},/**\n     * Paint the cached clipPath on the lowerCanvasEl\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */drawClipPathOnCanvas:function(ctx){var v=this.viewportTransform,path=this.clipPath;ctx.save();ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]);// DEBUG: uncomment this line, comment the following\n// ctx.globalAlpha = 0.4;\nctx.globalCompositeOperation='destination-in';path.transform(ctx);ctx.scale(1/path.zoomX,1/path.zoomY);ctx.drawImage(path._cacheCanvas,-path.cacheTranslationX,-path.cacheTranslationY);ctx.restore();},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} objects to render\n     */_renderObjects:function(ctx,objects){var i,len;for(i=0,len=objects.length;i<len;++i){objects[i]&&objects[i].render(ctx);}},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {string} property 'background' or 'overlay'\n     */_renderBackgroundOrOverlay:function(ctx,property){var fill=this[property+'Color'],object=this[property+'Image'],v=this.viewportTransform,needsVpt=this[property+'Vpt'];if(!fill&&!object){return;}if(fill){ctx.save();ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(this.width,0);ctx.lineTo(this.width,this.height);ctx.lineTo(0,this.height);ctx.closePath();ctx.fillStyle=fill.toLive?fill.toLive(ctx,this):fill;if(needsVpt){ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]);}ctx.transform(1,0,0,1,fill.offsetX||0,fill.offsetY||0);var m=fill.gradientTransform||fill.patternTransform;m&&ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);ctx.fill();ctx.restore();}if(object){ctx.save();if(needsVpt){ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]);}object.render(ctx);ctx.restore();}},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderBackground:function(ctx){this._renderBackgroundOrOverlay(ctx,'background');},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderOverlay:function(ctx){this._renderBackgroundOrOverlay(ctx,'overlay');},/**\n     * Returns coordinates of a center of canvas.\n     * Returned value is an object with top and left properties\n     * @return {Object} object with \"top\" and \"left\" number values\n     */getCenter:function(){return{top:this.height/2,left:this.width/2};},/**\n     * Centers object horizontally in the canvas\n     * @param {fabric.Object} object Object to center horizontally\n     * @return {fabric.Canvas} thisArg\n     */centerObjectH:function(object){return this._centerObject(object,new fabric.Point(this.getCenter().left,object.getCenterPoint().y));},/**\n     * Centers object vertically in the canvas\n     * @param {fabric.Object} object Object to center vertically\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */centerObjectV:function(object){return this._centerObject(object,new fabric.Point(object.getCenterPoint().x,this.getCenter().top));},/**\n     * Centers object vertically and horizontally in the canvas\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */centerObject:function(object){var center=this.getCenter();return this._centerObject(object,new fabric.Point(center.left,center.top));},/**\n     * Centers object vertically and horizontally in the viewport\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */viewportCenterObject:function(object){var vpCenter=this.getVpCenter();return this._centerObject(object,vpCenter);},/**\n     * Centers object horizontally in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */viewportCenterObjectH:function(object){var vpCenter=this.getVpCenter();this._centerObject(object,new fabric.Point(vpCenter.x,object.getCenterPoint().y));return this;},/**\n     * Centers object Vertically in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */viewportCenterObjectV:function(object){var vpCenter=this.getVpCenter();return this._centerObject(object,new fabric.Point(object.getCenterPoint().x,vpCenter.y));},/**\n     * Calculate the point in canvas that correspond to the center of actual viewport.\n     * @return {fabric.Point} vpCenter, viewport center\n     * @chainable\n     */getVpCenter:function(){var center=this.getCenter(),iVpt=invertTransform(this.viewportTransform);return transformPoint({x:center.left,y:center.top},iVpt);},/**\n     * @private\n     * @param {fabric.Object} object Object to center\n     * @param {fabric.Point} center Center point\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */_centerObject:function(object,center){object.setPositionByOrigin(center,'center','center');object.setCoords();this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n     * Returns dataless JSON representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {String} json string\n     */toDatalessJSON:function(propertiesToInclude){return this.toDatalessObject(propertiesToInclude);},/**\n     * Returns object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toObject:function(propertiesToInclude){return this._toObjectMethod('toObject',propertiesToInclude);},/**\n     * Returns dataless object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toDatalessObject:function(propertiesToInclude){return this._toObjectMethod('toDatalessObject',propertiesToInclude);},/**\n     * @private\n     */_toObjectMethod:function(methodName,propertiesToInclude){var clipPath=this.clipPath,data={version:fabric.version,objects:this._toObjects(methodName,propertiesToInclude)};if(clipPath&&!clipPath.excludeFromExport){data.clipPath=this._toObject(this.clipPath,methodName,propertiesToInclude);}extend(data,this.__serializeBgOverlay(methodName,propertiesToInclude));fabric.util.populateWithProperties(this,data,propertiesToInclude);return data;},/**\n     * @private\n     */_toObjects:function(methodName,propertiesToInclude){return this._objects.filter(function(object){return!object.excludeFromExport;}).map(function(instance){return this._toObject(instance,methodName,propertiesToInclude);},this);},/**\n     * @private\n     */_toObject:function(instance,methodName,propertiesToInclude){var originalValue;if(!this.includeDefaultValues){originalValue=instance.includeDefaultValues;instance.includeDefaultValues=false;}var object=instance[methodName](propertiesToInclude);if(!this.includeDefaultValues){instance.includeDefaultValues=originalValue;}return object;},/**\n     * @private\n     */__serializeBgOverlay:function(methodName,propertiesToInclude){var data={},bgImage=this.backgroundImage,overlayImage=this.overlayImage,bgColor=this.backgroundColor,overlayColor=this.overlayColor;if(bgColor&&bgColor.toObject){if(!bgColor.excludeFromExport){data.background=bgColor.toObject(propertiesToInclude);}}else if(bgColor){data.background=bgColor;}if(overlayColor&&overlayColor.toObject){if(!overlayColor.excludeFromExport){data.overlay=overlayColor.toObject(propertiesToInclude);}}else if(overlayColor){data.overlay=overlayColor;}if(bgImage&&!bgImage.excludeFromExport){data.backgroundImage=this._toObject(bgImage,methodName,propertiesToInclude);}if(overlayImage&&!overlayImage.excludeFromExport){data.overlayImage=this._toObject(overlayImage,methodName,propertiesToInclude);}return data;},/* _TO_SVG_START_ */ /**\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\n     * a zoomed canvas will then produce zoomed SVG output.\n     * @type Boolean\n     * @default\n     */svgViewportTransformation:true,/**\n     * Returns SVG representation of canvas\n     * @function\n     * @param {Object} [options] Options object for SVG output\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\n     * @param {Object} [options.viewBox] SVG viewbox object\n     * @param {Number} [options.viewBox.x] x-coordinate of viewbox\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\n     * @param {Number} [options.viewBox.width] Width of viewbox\n     * @param {Number} [options.viewBox.height] Height of viewbox\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\n     * @param {String} [options.width] desired width of svg with or without units\n     * @param {String} [options.height] desired height of svg with or without units\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\n     * @return {String} SVG string\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\n     * @example <caption>Normal SVG output</caption>\n     * var svg = canvas.toSVG();\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\n     * var svg = canvas.toSVG({suppressPreamble: true});\n     * @example <caption>SVG output with viewBox attribute</caption>\n     * var svg = canvas.toSVG({\n     *   viewBox: {\n     *     x: 100,\n     *     y: 100,\n     *     width: 200,\n     *     height: 300\n     *   }\n     * });\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\n     * @example <caption>Modify SVG output with reviver function</caption>\n     * var svg = canvas.toSVG(null, function(svg) {\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\n     * });\n     */toSVG:function(options,reviver){options||(options={});options.reviver=reviver;var markup=[];this._setSVGPreamble(markup,options);this._setSVGHeader(markup,options);if(this.clipPath){markup.push('<g clip-path=\"url(#'+this.clipPath.clipPathId+')\" >\\n');}this._setSVGBgOverlayColor(markup,'background');this._setSVGBgOverlayImage(markup,'backgroundImage',reviver);this._setSVGObjects(markup,reviver);if(this.clipPath){markup.push('</g>\\n');}this._setSVGBgOverlayColor(markup,'overlay');this._setSVGBgOverlayImage(markup,'overlayImage',reviver);markup.push('</svg>');return markup.join('');},/**\n     * @private\n     */_setSVGPreamble:function(markup,options){if(options.suppressPreamble){return;}markup.push('<?xml version=\"1.0\" encoding=\"',options.encoding||'UTF-8','\" standalone=\"no\" ?>\\n','<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ','\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n');},/**\n     * @private\n     */_setSVGHeader:function(markup,options){var width=options.width||this.width,height=options.height||this.height,vpt,viewBox='viewBox=\"0 0 '+this.width+' '+this.height+'\" ',NUM_FRACTION_DIGITS=fabric.Object.NUM_FRACTION_DIGITS;if(options.viewBox){viewBox='viewBox=\"'+options.viewBox.x+' '+options.viewBox.y+' '+options.viewBox.width+' '+options.viewBox.height+'\" ';}else{if(this.svgViewportTransformation){vpt=this.viewportTransform;viewBox='viewBox=\"'+toFixed(-vpt[4]/vpt[0],NUM_FRACTION_DIGITS)+' '+toFixed(-vpt[5]/vpt[3],NUM_FRACTION_DIGITS)+' '+toFixed(this.width/vpt[0],NUM_FRACTION_DIGITS)+' '+toFixed(this.height/vpt[3],NUM_FRACTION_DIGITS)+'\" ';}}markup.push('<svg ','xmlns=\"http://www.w3.org/2000/svg\" ','xmlns:xlink=\"http://www.w3.org/1999/xlink\" ','version=\"1.1\" ','width=\"',width,'\" ','height=\"',height,'\" ',viewBox,'xml:space=\"preserve\">\\n','<desc>Created with Fabric.js ',fabric.version,'</desc>\\n','<defs>\\n',this.createSVGFontFacesMarkup(),this.createSVGRefElementsMarkup(),this.createSVGClipPathMarkup(options),'</defs>\\n');},createSVGClipPathMarkup:function(options){var clipPath=this.clipPath;if(clipPath){clipPath.clipPathId='CLIPPATH_'+fabric.Object.__uid++;return'<clipPath id=\"'+clipPath.clipPathId+'\" >\\n'+this.clipPath.toClipPathSVG(options.reviver)+'</clipPath>\\n';}return'';},/**\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\n     * @return {String}\n     */createSVGRefElementsMarkup:function(){var _this=this,markup=['background','overlay'].map(function(prop){var fill=_this[prop+'Color'];if(fill&&fill.toLive){var shouldTransform=_this[prop+'Vpt'],vpt=_this.viewportTransform,object={width:_this.width/(shouldTransform?vpt[0]:1),height:_this.height/(shouldTransform?vpt[3]:1)};return fill.toSVG(object,{additionalTransform:shouldTransform?fabric.util.matrixToSVG(vpt):''});}});return markup.join('');},/**\n     * Creates markup containing SVG font faces,\n     * font URLs for font faces must be collected by developers\n     * and are not extracted from the DOM by fabricjs\n     * @param {Array} objects Array of fabric objects\n     * @return {String}\n     */createSVGFontFacesMarkup:function(){var markup='',fontList={},obj,fontFamily,style,row,rowIndex,_char,charIndex,i,len,fontPaths=fabric.fontPaths,objects=[];this._objects.forEach(function add(object){objects.push(object);if(object._objects){object._objects.forEach(add);}});for(i=0,len=objects.length;i<len;i++){obj=objects[i];fontFamily=obj.fontFamily;if(obj.type.indexOf('text')===-1||fontList[fontFamily]||!fontPaths[fontFamily]){continue;}fontList[fontFamily]=true;if(!obj.styles){continue;}style=obj.styles;for(rowIndex in style){row=style[rowIndex];for(charIndex in row){_char=row[charIndex];fontFamily=_char.fontFamily;if(!fontList[fontFamily]&&fontPaths[fontFamily]){fontList[fontFamily]=true;}}}}for(var j in fontList){markup+=['\\t\\t@font-face {\\n','\\t\\t\\tfont-family: \\'',j,'\\';\\n','\\t\\t\\tsrc: url(\\'',fontPaths[j],'\\');\\n','\\t\\t}\\n'].join('');}if(markup){markup=['\\t<style type=\"text/css\">','<![CDATA[\\n',markup,']]>','</style>\\n'].join('');}return markup;},/**\n     * @private\n     */_setSVGObjects:function(markup,reviver){var instance,i,len,objects=this._objects;for(i=0,len=objects.length;i<len;i++){instance=objects[i];if(instance.excludeFromExport){continue;}this._setSVGObject(markup,instance,reviver);}},/**\n     * @private\n     */_setSVGObject:function(markup,instance,reviver){markup.push(instance.toSVG(reviver));},/**\n     * @private\n     */_setSVGBgOverlayImage:function(markup,property,reviver){if(this[property]&&!this[property].excludeFromExport&&this[property].toSVG){markup.push(this[property].toSVG(reviver));}},/**\n     * @private\n     */_setSVGBgOverlayColor:function(markup,property){var filler=this[property+'Color'],vpt=this.viewportTransform,finalWidth=this.width,finalHeight=this.height;if(!filler){return;}if(filler.toLive){var repeat=filler.repeat,iVpt=fabric.util.invertTransform(vpt),shouldInvert=this[property+'Vpt'],additionalTransform=shouldInvert?fabric.util.matrixToSVG(iVpt):'';markup.push('<rect transform=\"'+additionalTransform+' translate(',finalWidth/2,',',finalHeight/2,')\"',' x=\"',filler.offsetX-finalWidth/2,'\" y=\"',filler.offsetY-finalHeight/2,'\" ','width=\"',repeat==='repeat-y'||repeat==='no-repeat'?filler.source.width:finalWidth,'\" height=\"',repeat==='repeat-x'||repeat==='no-repeat'?filler.source.height:finalHeight,'\" fill=\"url(#SVGID_'+filler.id+')\"','></rect>\\n');}else{markup.push('<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ','fill=\"',filler,'\"','></rect>\\n');}},/* _TO_SVG_END_ */ /**\n     * Moves an object or the objects of a multiple selection\n     * to the bottom of the stack of drawn objects\n     * @param {fabric.Object} object Object to send to back\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */sendToBack:function(object){if(!object){return this;}var activeSelection=this._activeObject,i,obj,objs;if(object===activeSelection&&object.type==='activeSelection'){objs=activeSelection._objects;for(i=objs.length;i--;){obj=objs[i];removeFromArray(this._objects,obj);this._objects.unshift(obj);}}else{removeFromArray(this._objects,object);this._objects.unshift(object);}this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n     * Moves an object or the objects of a multiple selection\n     * to the top of the stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */bringToFront:function(object){if(!object){return this;}var activeSelection=this._activeObject,i,obj,objs;if(object===activeSelection&&object.type==='activeSelection'){objs=activeSelection._objects;for(i=0;i<objs.length;i++){obj=objs[i];removeFromArray(this._objects,obj);this._objects.push(obj);}}else{removeFromArray(this._objects,object);this._objects.push(object);}this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n     * Moves an object or a selection down in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in behind\n     * the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */sendBackwards:function(object,intersecting){if(!object){return this;}var activeSelection=this._activeObject,i,obj,idx,newIdx,objs,objsMoved=0;if(object===activeSelection&&object.type==='activeSelection'){objs=activeSelection._objects;for(i=0;i<objs.length;i++){obj=objs[i];idx=this._objects.indexOf(obj);if(idx>0+objsMoved){newIdx=idx-1;removeFromArray(this._objects,obj);this._objects.splice(newIdx,0,obj);}objsMoved++;}}else{idx=this._objects.indexOf(object);if(idx!==0){// if object is not on the bottom of stack\nnewIdx=this._findNewLowerIndex(object,idx,intersecting);removeFromArray(this._objects,object);this._objects.splice(newIdx,0,object);}}this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n     * @private\n     */_findNewLowerIndex:function(object,idx,intersecting){var newIdx,i;if(intersecting){newIdx=idx;// traverse down the stack looking for the nearest intersecting object\nfor(i=idx-1;i>=0;--i){var isIntersecting=object.intersectsWithObject(this._objects[i])||object.isContainedWithinObject(this._objects[i])||this._objects[i].isContainedWithinObject(object);if(isIntersecting){newIdx=i;break;}}}else{newIdx=idx-1;}return newIdx;},/**\n     * Moves an object or a selection up in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in front\n     * of the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */bringForward:function(object,intersecting){if(!object){return this;}var activeSelection=this._activeObject,i,obj,idx,newIdx,objs,objsMoved=0;if(object===activeSelection&&object.type==='activeSelection'){objs=activeSelection._objects;for(i=objs.length;i--;){obj=objs[i];idx=this._objects.indexOf(obj);if(idx<this._objects.length-1-objsMoved){newIdx=idx+1;removeFromArray(this._objects,obj);this._objects.splice(newIdx,0,obj);}objsMoved++;}}else{idx=this._objects.indexOf(object);if(idx!==this._objects.length-1){// if object is not on top of stack (last item in an array)\nnewIdx=this._findNewUpperIndex(object,idx,intersecting);removeFromArray(this._objects,object);this._objects.splice(newIdx,0,object);}}this.renderOnAddRemove&&this.requestRenderAll();return this;},/**\n     * @private\n     */_findNewUpperIndex:function(object,idx,intersecting){var newIdx,i,len;if(intersecting){newIdx=idx;// traverse up the stack looking for the nearest intersecting object\nfor(i=idx+1,len=this._objects.length;i<len;++i){var isIntersecting=object.intersectsWithObject(this._objects[i])||object.isContainedWithinObject(this._objects[i])||this._objects[i].isContainedWithinObject(object);if(isIntersecting){newIdx=i;break;}}}else{newIdx=idx+1;}return newIdx;},/**\n     * Moves an object to specified level in stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @param {Number} index Position to move to\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */moveTo:function(object,index){removeFromArray(this._objects,object);this._objects.splice(index,0,object);return this.renderOnAddRemove&&this.requestRenderAll();},/**\n     * Clears a canvas element and dispose objects\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */dispose:function(){// cancel eventually ongoing renders\nif(this.isRendering){fabric.util.cancelAnimFrame(this.isRendering);this.isRendering=0;}this.forEachObject(function(object){object.dispose&&object.dispose();});this._objects=[];if(this.backgroundImage&&this.backgroundImage.dispose){this.backgroundImage.dispose();}this.backgroundImage=null;if(this.overlayImage&&this.overlayImage.dispose){this.overlayImage.dispose();}this.overlayImage=null;this._iTextInstances=null;this.contextContainer=null;// restore canvas style\nthis.lowerCanvasEl.classList.remove('lower-canvas');this.lowerCanvasEl.style=this._originalCanvasStyle;delete this._originalCanvasStyle;// restore canvas size to original size in case retina scaling was applied\nthis.lowerCanvasEl.setAttribute('width',this.width);this.lowerCanvasEl.setAttribute('height',this.height);fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);this.lowerCanvasEl=undefined;return this;},/**\n     * Returns a string representation of an instance\n     * @return {String} string representation of an instance\n     */toString:function(){return'#<fabric.Canvas ('+this.complexity()+'): '+'{ objects: '+this._objects.length+' }>';}});extend(fabric.StaticCanvas.prototype,fabric.Observable);extend(fabric.StaticCanvas.prototype,fabric.Collection);extend(fabric.StaticCanvas.prototype,fabric.DataURLExporter);extend(fabric.StaticCanvas,/** @lends fabric.StaticCanvas */{/**\n     * @static\n     * @type String\n     * @default\n     */EMPTY_JSON:'{\"objects\": [], \"background\": \"white\"}',/**\n     * Provides a way to check support of some of the canvas methods\n     * (either those of HTMLCanvasElement itself, or rendering context)\n     *\n     * @param {String} methodName Method to check support for;\n     *                            Could be one of \"setLineDash\"\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\n     *                          `null` if canvas element or context can not be initialized\n     */supports:function(methodName){var el=createCanvasElement();if(!el||!el.getContext){return null;}var ctx=el.getContext('2d');if(!ctx){return null;}switch(methodName){case'setLineDash':return typeof ctx.setLineDash!=='undefined';default:return null;}}});/**\n   * Returns Object representation of canvas\n   * this alias is provided because if you call JSON.stringify on an instance,\n   * the toJSON object will be invoked if it exists.\n   * Having a toJSON method means you can do JSON.stringify(myCanvas)\n   * @function\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} JSON compatible object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\n   * @example <caption>JSON without additional properties</caption>\n   * var json = canvas.toJSON();\n   * @example <caption>JSON with additional properties included</caption>\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);\n   * @example <caption>JSON without default values</caption>\n   * canvas.includeDefaultValues = false;\n   * var json = canvas.toJSON();\n   */fabric.StaticCanvas.prototype.toJSON=fabric.StaticCanvas.prototype.toObject;if(fabric.isLikelyNode){fabric.StaticCanvas.prototype.createPNGStream=function(){var impl=getNodeCanvas(this.lowerCanvasEl);return impl&&impl.createPNGStream();};fabric.StaticCanvas.prototype.createJPEGStream=function(opts){var impl=getNodeCanvas(this.lowerCanvasEl);return impl&&impl.createJPEGStream(opts);};}})();/**\n * BaseBrush class\n * @class fabric.BaseBrush\n * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}\n */fabric.BaseBrush=fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */{/**\n   * Color of a brush\n   * @type String\n   * @default\n   */color:'rgb(0, 0, 0)',/**\n   * Width of a brush, has to be a Number, no string literals\n   * @type Number\n   * @default\n   */width:1,/**\n   * Shadow object representing shadow of this shape.\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\n   * @type fabric.Shadow\n   * @default\n   */shadow:null,/**\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\n   * @type String\n   * @default\n   */strokeLineCap:'round',/**\n   * Corner style of a brush (one of \"bevel\", \"round\", \"miter\")\n   * @type String\n   * @default\n   */strokeLineJoin:'round',/**\n   * Maximum miter length (used for strokeLineJoin = \"miter\") of a brush's\n   * @type Number\n   * @default\n   */strokeMiterLimit:10,/**\n   * Stroke Dash Array.\n   * @type Array\n   * @default\n   */strokeDashArray:null,/**\n   * When `true`, the free drawing is limited to the whiteboard size. Default to false.\n   * @type Boolean\n   * @default false\n  */limitedToCanvasSize:false,/**\n   * Sets brush styles\n   * @private\n   */_setBrushStyles:function(){var ctx=this.canvas.contextTop;ctx.strokeStyle=this.color;ctx.lineWidth=this.width;ctx.lineCap=this.strokeLineCap;ctx.miterLimit=this.strokeMiterLimit;ctx.lineJoin=this.strokeLineJoin;ctx.setLineDash(this.strokeDashArray||[]);},/**\n   * Sets the transformation on given context\n   * @param {RenderingContext2d} ctx context to render on\n   * @private\n   */_saveAndTransform:function(ctx){var v=this.canvas.viewportTransform;ctx.save();ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]);},/**\n   * Sets brush shadow styles\n   * @private\n   */_setShadow:function(){if(!this.shadow){return;}var canvas=this.canvas,shadow=this.shadow,ctx=canvas.contextTop,zoom=canvas.getZoom();if(canvas&&canvas._isRetinaScaling()){zoom*=fabric.devicePixelRatio;}ctx.shadowColor=shadow.color;ctx.shadowBlur=shadow.blur*zoom;ctx.shadowOffsetX=shadow.offsetX*zoom;ctx.shadowOffsetY=shadow.offsetY*zoom;},needsFullRender:function(){var color=new fabric.Color(this.color);return color.getAlpha()<1||!!this.shadow;},/**\n   * Removes brush shadow styles\n   * @private\n   */_resetShadow:function(){var ctx=this.canvas.contextTop;ctx.shadowColor='';ctx.shadowBlur=ctx.shadowOffsetX=ctx.shadowOffsetY=0;},/**\n   * Check is pointer is outside canvas boundaries\n   * @param {Object} pointer\n   * @private\n  */_isOutSideCanvas:function(pointer){return pointer.x<0||pointer.x>this.canvas.getWidth()||pointer.y<0||pointer.y>this.canvas.getHeight();}});(function(){/**\n   * PencilBrush class\n   * @class fabric.PencilBrush\n   * @extends fabric.BaseBrush\n   */fabric.PencilBrush=fabric.util.createClass(fabric.BaseBrush,/** @lends fabric.PencilBrush.prototype */{/**\n     * Discard points that are less than `decimate` pixel distant from each other\n     * @type Number\n     * @default 0.4\n     */decimate:0.4,/**\n     * Constructor\n     * @param {fabric.Canvas} canvas\n     * @return {fabric.PencilBrush} Instance of a pencil brush\n     */initialize:function(canvas){this.canvas=canvas;this._points=[];},/**\n     * Invoked inside on mouse down and mouse move\n     * @param {Object} pointer\n     */_drawSegment:function(ctx,p1,p2){var midPoint=p1.midPointFrom(p2);ctx.quadraticCurveTo(p1.x,p1.y,midPoint.x,midPoint.y);return midPoint;},/**\n     * Invoked on mouse down\n     * @param {Object} pointer\n     */onMouseDown:function(pointer,options){if(!this.canvas._isMainEvent(options.e)){return;}this._prepareForDrawing(pointer);// capture coordinates immediately\n// this allows to draw dots (when movement never occurs)\nthis._captureDrawingPath(pointer);this._render();},/**\n     * Invoked on mouse move\n     * @param {Object} pointer\n     */onMouseMove:function(pointer,options){if(!this.canvas._isMainEvent(options.e)){return;}if(this.limitedToCanvasSize===true&&this._isOutSideCanvas(pointer)){return;}if(this._captureDrawingPath(pointer)&&this._points.length>1){if(this.needsFullRender()){// redraw curve\n// clear top canvas\nthis.canvas.clearContext(this.canvas.contextTop);this._render();}else{var points=this._points,length=points.length,ctx=this.canvas.contextTop;// draw the curve update\nthis._saveAndTransform(ctx);if(this.oldEnd){ctx.beginPath();ctx.moveTo(this.oldEnd.x,this.oldEnd.y);}this.oldEnd=this._drawSegment(ctx,points[length-2],points[length-1],true);ctx.stroke();ctx.restore();}}},/**\n     * Invoked on mouse up\n     */onMouseUp:function(options){if(!this.canvas._isMainEvent(options.e)){return true;}this.oldEnd=undefined;this._finalizeAndAddPath();return false;},/**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */_prepareForDrawing:function(pointer){var p=new fabric.Point(pointer.x,pointer.y);this._reset();this._addPoint(p);this.canvas.contextTop.moveTo(p.x,p.y);},/**\n     * @private\n     * @param {fabric.Point} point Point to be added to points array\n     */_addPoint:function(point){if(this._points.length>1&&point.eq(this._points[this._points.length-1])){return false;}this._points.push(point);return true;},/**\n     * Clear points array and set contextTop canvas style.\n     * @private\n     */_reset:function(){this._points=[];this._setBrushStyles();this._setShadow();},/**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */_captureDrawingPath:function(pointer){var pointerPoint=new fabric.Point(pointer.x,pointer.y);return this._addPoint(pointerPoint);},/**\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\n     * @private\n     */_render:function(){var ctx=this.canvas.contextTop,i,len,p1=this._points[0],p2=this._points[1];this._saveAndTransform(ctx);ctx.beginPath();//if we only have 2 points in the path and they are the same\n//it means that the user only clicked the canvas without moving the mouse\n//then we should be drawing a dot. A path isn't drawn between two identical dots\n//that's why we set them apart a bit\nif(this._points.length===2&&p1.x===p2.x&&p1.y===p2.y){var width=this.width/1000;p1=new fabric.Point(p1.x,p1.y);p2=new fabric.Point(p2.x,p2.y);p1.x-=width;p2.x+=width;}ctx.moveTo(p1.x,p1.y);for(i=1,len=this._points.length;i<len;i++){// we pick the point between pi + 1 & pi + 2 as the\n// end point and p1 as our control point.\nthis._drawSegment(ctx,p1,p2);p1=this._points[i];p2=this._points[i+1];}// Draw last line as a straight line while\n// we wait for the next point to be able to calculate\n// the bezier control point\nctx.lineTo(p1.x,p1.y);ctx.stroke();ctx.restore();},/**\n     * Converts points to SVG path\n     * @param {Array} points Array of points\n     * @return {(string|number)[][]} SVG path commands\n     */convertPointsToSVGPath:function(points){var correction=this.width/1000;return fabric.util.getSmoothPathFromPoints(points,correction);},/**\n     * @private\n     * @param {(string|number)[][]} pathData SVG path commands\n     * @returns {boolean}\n     */_isEmptySVGPath:function(pathData){var pathString=fabric.util.joinPath(pathData);return pathString==='M 0 0 Q 0 0 0 0 L 0 0';},/**\n     * Creates fabric.Path object to add on canvas\n     * @param {(string|number)[][]} pathData Path data\n     * @return {fabric.Path} Path to add on canvas\n     */createPath:function(pathData){var path=new fabric.Path(pathData,{fill:null,stroke:this.color,strokeWidth:this.width,strokeLineCap:this.strokeLineCap,strokeMiterLimit:this.strokeMiterLimit,strokeLineJoin:this.strokeLineJoin,strokeDashArray:this.strokeDashArray});if(this.shadow){this.shadow.affectStroke=true;path.shadow=new fabric.Shadow(this.shadow);}return path;},/**\n     * Decimate points array with the decimate value\n     */decimatePoints:function(points,distance){if(points.length<=2){return points;}var zoom=this.canvas.getZoom(),adjustedDistance=Math.pow(distance/zoom,2),i,l=points.length-1,lastPoint=points[0],newPoints=[lastPoint],cDistance;for(i=1;i<l-1;i++){cDistance=Math.pow(lastPoint.x-points[i].x,2)+Math.pow(lastPoint.y-points[i].y,2);if(cDistance>=adjustedDistance){lastPoint=points[i];newPoints.push(lastPoint);}}/**\n       * Add the last point from the original line to the end of the array.\n       * This ensures decimate doesn't delete the last point on the line, and ensures the line is > 1 point.\n       */newPoints.push(points[l]);return newPoints;},/**\n     * On mouseup after drawing the path on contextTop canvas\n     * we use the points captured to create an new fabric path object\n     * and add it to the fabric canvas.\n     */_finalizeAndAddPath:function(){var ctx=this.canvas.contextTop;ctx.closePath();if(this.decimate){this._points=this.decimatePoints(this._points,this.decimate);}var pathData=this.convertPointsToSVGPath(this._points);if(this._isEmptySVGPath(pathData)){// do not create 0 width/height paths, as they are\n// rendered inconsistently across browsers\n// Firefox 4, for example, renders a dot,\n// whereas Chrome 10 renders nothing\nthis.canvas.requestRenderAll();return;}var path=this.createPath(pathData);this.canvas.clearContext(this.canvas.contextTop);this.canvas.fire('before:path:created',{path:path});this.canvas.add(path);this.canvas.requestRenderAll();path.setCoords();this._resetShadow();// fire event 'path' created\nthis.canvas.fire('path:created',{path:path});}});})();/**\n * CircleBrush class\n * @class fabric.CircleBrush\n */fabric.CircleBrush=fabric.util.createClass(fabric.BaseBrush,/** @lends fabric.CircleBrush.prototype */{/**\n   * Width of a brush\n   * @type Number\n   * @default\n   */width:10,/**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.CircleBrush} Instance of a circle brush\n   */initialize:function(canvas){this.canvas=canvas;this.points=[];},/**\n   * Invoked inside on mouse down and mouse move\n   * @param {Object} pointer\n   */drawDot:function(pointer){var point=this.addPoint(pointer),ctx=this.canvas.contextTop;this._saveAndTransform(ctx);this.dot(ctx,point);ctx.restore();},dot:function(ctx,point){ctx.fillStyle=point.fill;ctx.beginPath();ctx.arc(point.x,point.y,point.radius,0,Math.PI*2,false);ctx.closePath();ctx.fill();},/**\n   * Invoked on mouse down\n   */onMouseDown:function(pointer){this.points.length=0;this.canvas.clearContext(this.canvas.contextTop);this._setShadow();this.drawDot(pointer);},/**\n   * Render the full state of the brush\n   * @private\n   */_render:function(){var ctx=this.canvas.contextTop,i,len,points=this.points;this._saveAndTransform(ctx);for(i=0,len=points.length;i<len;i++){this.dot(ctx,points[i]);}ctx.restore();},/**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */onMouseMove:function(pointer){if(this.limitedToCanvasSize===true&&this._isOutSideCanvas(pointer)){return;}if(this.needsFullRender()){this.canvas.clearContext(this.canvas.contextTop);this.addPoint(pointer);this._render();}else{this.drawDot(pointer);}},/**\n   * Invoked on mouse up\n   */onMouseUp:function(){var originalRenderOnAddRemove=this.canvas.renderOnAddRemove,i,len;this.canvas.renderOnAddRemove=false;var circles=[];for(i=0,len=this.points.length;i<len;i++){var point=this.points[i],circle=new fabric.Circle({radius:point.radius,left:point.x,top:point.y,originX:'center',originY:'center',fill:point.fill});this.shadow&&(circle.shadow=new fabric.Shadow(this.shadow));circles.push(circle);}var group=new fabric.Group(circles);group.canvas=this.canvas;this.canvas.fire('before:path:created',{path:group});this.canvas.add(group);this.canvas.fire('path:created',{path:group});this.canvas.clearContext(this.canvas.contextTop);this._resetShadow();this.canvas.renderOnAddRemove=originalRenderOnAddRemove;this.canvas.requestRenderAll();},/**\n   * @param {Object} pointer\n   * @return {fabric.Point} Just added pointer point\n   */addPoint:function(pointer){var pointerPoint=new fabric.Point(pointer.x,pointer.y),circleRadius=fabric.util.getRandomInt(Math.max(0,this.width-20),this.width+20)/2,circleColor=new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0,100)/100).toRgba();pointerPoint.radius=circleRadius;pointerPoint.fill=circleColor;this.points.push(pointerPoint);return pointerPoint;}});/**\n * SprayBrush class\n * @class fabric.SprayBrush\n */fabric.SprayBrush=fabric.util.createClass(fabric.BaseBrush,/** @lends fabric.SprayBrush.prototype */{/**\n   * Width of a spray\n   * @type Number\n   * @default\n   */width:10,/**\n   * Density of a spray (number of dots per chunk)\n   * @type Number\n   * @default\n   */density:20,/**\n   * Width of spray dots\n   * @type Number\n   * @default\n   */dotWidth:1,/**\n   * Width variance of spray dots\n   * @type Number\n   * @default\n   */dotWidthVariance:1,/**\n   * Whether opacity of a dot should be random\n   * @type Boolean\n   * @default\n   */randomOpacity:false,/**\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\n   * @type Boolean\n   * @default\n   */optimizeOverlapping:true,/**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.SprayBrush} Instance of a spray brush\n   */initialize:function(canvas){this.canvas=canvas;this.sprayChunks=[];},/**\n   * Invoked on mouse down\n   * @param {Object} pointer\n   */onMouseDown:function(pointer){this.sprayChunks.length=0;this.canvas.clearContext(this.canvas.contextTop);this._setShadow();this.addSprayChunk(pointer);this.render(this.sprayChunkPoints);},/**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */onMouseMove:function(pointer){if(this.limitedToCanvasSize===true&&this._isOutSideCanvas(pointer)){return;}this.addSprayChunk(pointer);this.render(this.sprayChunkPoints);},/**\n   * Invoked on mouse up\n   */onMouseUp:function(){var originalRenderOnAddRemove=this.canvas.renderOnAddRemove;this.canvas.renderOnAddRemove=false;var rects=[];for(var i=0,ilen=this.sprayChunks.length;i<ilen;i++){var sprayChunk=this.sprayChunks[i];for(var j=0,jlen=sprayChunk.length;j<jlen;j++){var rect=new fabric.Rect({width:sprayChunk[j].width,height:sprayChunk[j].width,left:sprayChunk[j].x+1,top:sprayChunk[j].y+1,originX:'center',originY:'center',fill:this.color});rects.push(rect);}}if(this.optimizeOverlapping){rects=this._getOptimizedRects(rects);}var group=new fabric.Group(rects);this.shadow&&group.set('shadow',new fabric.Shadow(this.shadow));this.canvas.fire('before:path:created',{path:group});this.canvas.add(group);this.canvas.fire('path:created',{path:group});this.canvas.clearContext(this.canvas.contextTop);this._resetShadow();this.canvas.renderOnAddRemove=originalRenderOnAddRemove;this.canvas.requestRenderAll();},/**\n   * @private\n   * @param {Array} rects\n   */_getOptimizedRects:function(rects){// avoid creating duplicate rects at the same coordinates\nvar uniqueRects={},key,i,len;for(i=0,len=rects.length;i<len;i++){key=rects[i].left+''+rects[i].top;if(!uniqueRects[key]){uniqueRects[key]=rects[i];}}var uniqueRectsArray=[];for(key in uniqueRects){uniqueRectsArray.push(uniqueRects[key]);}return uniqueRectsArray;},/**\n   * Render new chunk of spray brush\n   */render:function(sprayChunk){var ctx=this.canvas.contextTop,i,len;ctx.fillStyle=this.color;this._saveAndTransform(ctx);for(i=0,len=sprayChunk.length;i<len;i++){var point=sprayChunk[i];if(typeof point.opacity!=='undefined'){ctx.globalAlpha=point.opacity;}ctx.fillRect(point.x,point.y,point.width,point.width);}ctx.restore();},/**\n   * Render all spray chunks\n   */_render:function(){var ctx=this.canvas.contextTop,i,ilen;ctx.fillStyle=this.color;this._saveAndTransform(ctx);for(i=0,ilen=this.sprayChunks.length;i<ilen;i++){this.render(this.sprayChunks[i]);}ctx.restore();},/**\n   * @param {Object} pointer\n   */addSprayChunk:function(pointer){this.sprayChunkPoints=[];var x,y,width,radius=this.width/2,i;for(i=0;i<this.density;i++){x=fabric.util.getRandomInt(pointer.x-radius,pointer.x+radius);y=fabric.util.getRandomInt(pointer.y-radius,pointer.y+radius);if(this.dotWidthVariance){width=fabric.util.getRandomInt(// bottom clamp width to 1\nMath.max(1,this.dotWidth-this.dotWidthVariance),this.dotWidth+this.dotWidthVariance);}else{width=this.dotWidth;}var point=new fabric.Point(x,y);point.width=width;if(this.randomOpacity){point.opacity=fabric.util.getRandomInt(0,100)/100;}this.sprayChunkPoints.push(point);}this.sprayChunks.push(this.sprayChunkPoints);}});/**\n * PatternBrush class\n * @class fabric.PatternBrush\n * @extends fabric.BaseBrush\n */fabric.PatternBrush=fabric.util.createClass(fabric.PencilBrush,/** @lends fabric.PatternBrush.prototype */{getPatternSrc:function(){var dotWidth=20,dotDistance=5,patternCanvas=fabric.util.createCanvasElement(),patternCtx=patternCanvas.getContext('2d');patternCanvas.width=patternCanvas.height=dotWidth+dotDistance;patternCtx.fillStyle=this.color;patternCtx.beginPath();patternCtx.arc(dotWidth/2,dotWidth/2,dotWidth/2,0,Math.PI*2,false);patternCtx.closePath();patternCtx.fill();return patternCanvas;},getPatternSrcFunction:function(){return String(this.getPatternSrc).replace('this.color','\"'+this.color+'\"');},/**\n   * Creates \"pattern\" instance property\n   */getPattern:function(){return this.canvas.contextTop.createPattern(this.source||this.getPatternSrc(),'repeat');},/**\n   * Sets brush styles\n   */_setBrushStyles:function(){this.callSuper('_setBrushStyles');this.canvas.contextTop.strokeStyle=this.getPattern();},/**\n   * Creates path\n   */createPath:function(pathData){var path=this.callSuper('createPath',pathData),topLeft=path._getLeftTopCoords().scalarAdd(path.strokeWidth/2);path.stroke=new fabric.Pattern({source:this.source||this.getPatternSrcFunction(),offsetX:-topLeft.x,offsetY:-topLeft.y});return path;}});(function(){var getPointer=fabric.util.getPointer,degreesToRadians=fabric.util.degreesToRadians,isTouchEvent=fabric.util.isTouchEvent;/**\n   * Canvas class\n   * @class fabric.Canvas\n   * @extends fabric.StaticCanvas\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}\n   * @see {@link fabric.Canvas#initialize} for constructor definition\n   *\n   * @fires object:modified at the end of a transform or any change when statefull is true\n   * @fires object:rotating while an object is being rotated from the control\n   * @fires object:scaling while an object is being scaled by controls\n   * @fires object:moving while an object is being dragged\n   * @fires object:skewing while an object is being skewed from the controls\n   *\n   * @fires before:transform before a transform is is started\n   * @fires before:selection:cleared\n   * @fires selection:cleared\n   * @fires selection:updated\n   * @fires selection:created\n   *\n   * @fires path:created after a drawing operation ends and the path is added\n   * @fires mouse:down\n   * @fires mouse:move\n   * @fires mouse:up\n   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs\n   * @fires mouse:move:before on mouse move, before the inner fabric logic runs\n   * @fires mouse:up:before on mouse up, before the inner fabric logic runs\n   * @fires mouse:over\n   * @fires mouse:out\n   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop\n   * @fires after:render at the end of the render process, receives the context in the callback\n   * @fires before:render at start the render process, receives the context in the callback\n   *\n   * the following events are deprecated:\n   * @fires object:rotated at the end of a rotation transform\n   * @fires object:scaled at the end of a scale transform\n   * @fires object:moved at the end of translation transform\n   * @fires object:skewed at the end of a skew transform\n   */fabric.Canvas=fabric.util.createClass(fabric.StaticCanvas,/** @lends fabric.Canvas.prototype */{/**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */initialize:function(el,options){options||(options={});this.renderAndResetBound=this.renderAndReset.bind(this);this.requestRenderAllBound=this.requestRenderAll.bind(this);this._initStatic(el,options);this._initInteractive();this._createCacheCanvas();},/**\n     * When true, objects can be transformed by one side (unproportionally)\n     * when dragged on the corners that normally would not do that.\n     * @type Boolean\n     * @default\n     * @since fabric 4.0 // changed name and default value\n     */uniformScaling:true,/**\n     * Indicates which key switches uniform scaling.\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * totally wrong named. this sounds like `uniform scaling`\n     * if Canvas.uniformScaling is true, pressing this will set it to false\n     * and viceversa.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */uniScaleKey:'shiftKey',/**\n     * When true, objects use center point as the origin of scale transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */centeredScaling:false,/**\n     * When true, objects use center point as the origin of rotate transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */centeredRotation:false,/**\n     * Indicates which key enable centered Transform\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */centeredKey:'altKey',/**\n     * Indicates which key enable alternate action on corner\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */altActionKey:'shiftKey',/**\n     * Indicates that canvas is interactive. This property should not be changed.\n     * @type Boolean\n     * @default\n     */interactive:true,/**\n     * Indicates whether group selection should be enabled\n     * @type Boolean\n     * @default\n     */selection:true,/**\n     * Indicates which key or keys enable multiple click selection\n     * Pass value as a string or array of strings\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or empty or containing any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.2\n     * @type String|Array\n     * @default\n     */selectionKey:'shiftKey',/**\n     * Indicates which key enable alternative selection\n     * in case of target overlapping with active object\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * For a series of reason that come from the general expectations on how\n     * things should work, this feature works only for preserveObjectStacking true.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.5\n     * @type null|String\n     * @default\n     */altSelectionKey:null,/**\n     * Color of selection\n     * @type String\n     * @default\n     */selectionColor:'rgba(100, 100, 255, 0.3)',// blue\n/**\n     * Default dash array pattern\n     * If not empty the selection border is dashed\n     * @type Array\n     */selectionDashArray:[],/**\n     * Color of the border of selection (usually slightly darker than color of selection itself)\n     * @type String\n     * @default\n     */selectionBorderColor:'rgba(255, 255, 255, 0.3)',/**\n     * Width of a line used in object/group selection\n     * @type Number\n     * @default\n     */selectionLineWidth:1,/**\n     * Select only shapes that are fully contained in the dragged selection rectangle.\n     * @type Boolean\n     * @default\n     */selectionFullyContained:false,/**\n     * Default cursor value used when hovering over an object on canvas\n     * @type String\n     * @default\n     */hoverCursor:'move',/**\n     * Default cursor value used when moving an object on canvas\n     * @type String\n     * @default\n     */moveCursor:'move',/**\n     * Default cursor value used for the entire canvas\n     * @type String\n     * @default\n     */defaultCursor:'default',/**\n     * Cursor value used during free drawing\n     * @type String\n     * @default\n     */freeDrawingCursor:'crosshair',/**\n     * Cursor value used for rotation point\n     * @type String\n     * @default\n     */rotationCursor:'crosshair',/**\n     * Cursor value used for disabled elements ( corners with disabled action )\n     * @type String\n     * @since 2.0.0\n     * @default\n     */notAllowedCursor:'not-allowed',/**\n     * Default element class that's given to wrapper (div) element of canvas\n     * @type String\n     * @default\n     */containerClass:'canvas-container',/**\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\n     * @type Boolean\n     * @default\n     */perPixelTargetFind:false,/**\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\n     * @type Number\n     * @default\n     */targetFindTolerance:0,/**\n     * When true, target detection is skipped. Target detection will return always undefined.\n     * click selection won't work anymore, events will fire with no targets.\n     * if something is selected before setting it to true, it will be deselected at the first click.\n     * area selection will still work. check the `selection` property too.\n     * if you deactivate both, you should look into staticCanvas.\n     * @type Boolean\n     * @default\n     */skipTargetFind:false,/**\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\n     * After mousedown, mousemove creates a shape,\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}\n     * @type Boolean\n     * @default\n     */isDrawingMode:false,/**\n     * Indicates whether objects should remain in current stack position when selected.\n     * When false objects are brought to top and rendered as part of the selection group\n     * @type Boolean\n     * @default\n     */preserveObjectStacking:false,/**\n     * Indicates the angle that an object will lock to while rotating.\n     * @type Number\n     * @since 1.6.7\n     * @default\n     */snapAngle:0,/**\n     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.\n     * When `null`, the snapThreshold will default to the snapAngle.\n     * @type null|Number\n     * @since 1.6.7\n     * @default\n     */snapThreshold:null,/**\n     * Indicates if the right click on canvas can output the context menu or not\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */stopContextMenu:false,/**\n     * Indicates if the canvas can fire right click events\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */fireRightClick:false,/**\n     * Indicates if the canvas can fire middle click events\n     * @type Boolean\n     * @since 1.7.8\n     * @default\n     */fireMiddleClick:false,/**\n     * Keep track of the subTargets for Mouse Events\n     * @type fabric.Object[]\n     */targets:[],/**\n     * Keep track of the hovered target\n     * @type fabric.Object\n     * @private\n     */_hoveredTarget:null,/**\n     * hold the list of nested targets hovered\n     * @type fabric.Object[]\n     * @private\n     */_hoveredTargets:[],/**\n     * @private\n     */_initInteractive:function(){this._currentTransform=null;this._groupSelector=null;this._initWrapperElement();this._createUpperCanvas();this._initEventListeners();this._initRetinaScaling();this.freeDrawingBrush=fabric.PencilBrush&&new fabric.PencilBrush(this);this.calcOffset();},/**\n     * Divides objects in two groups, one to render immediately\n     * and one to render as activeGroup.\n     * @return {Array} objects to render immediately and pushes the other in the activeGroup.\n     */_chooseObjectsToRender:function(){var activeObjects=this.getActiveObjects(),object,objsToRender,activeGroupObjects;if(activeObjects.length>0&&!this.preserveObjectStacking){objsToRender=[];activeGroupObjects=[];for(var i=0,length=this._objects.length;i<length;i++){object=this._objects[i];if(activeObjects.indexOf(object)===-1){objsToRender.push(object);}else{activeGroupObjects.push(object);}}if(activeObjects.length>1){this._activeObject._objects=activeGroupObjects;}objsToRender.push.apply(objsToRender,activeGroupObjects);}else{objsToRender=this._objects;}return objsToRender;},/**\n     * Renders both the top canvas and the secondary container canvas.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */renderAll:function(){if(this.contextTopDirty&&!this._groupSelector&&!this.isDrawingMode){this.clearContext(this.contextTop);this.contextTopDirty=false;}if(this.hasLostContext){this.renderTopLayer(this.contextTop);}var canvasToDrawOn=this.contextContainer;this.renderCanvas(canvasToDrawOn,this._chooseObjectsToRender());return this;},renderTopLayer:function(ctx){ctx.save();if(this.isDrawingMode&&this._isCurrentlyDrawing){this.freeDrawingBrush&&this.freeDrawingBrush._render();this.contextTopDirty=true;}// we render the top context - last object\nif(this.selection&&this._groupSelector){this._drawSelection(ctx);this.contextTopDirty=true;}ctx.restore();},/**\n     * Method to render only the top canvas.\n     * Also used to render the group selection box.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */renderTop:function(){var ctx=this.contextTop;this.clearContext(ctx);this.renderTopLayer(ctx);this.fire('after:render');return this;},/**\n     * @private\n     */_normalizePointer:function(object,pointer){var m=object.calcTransformMatrix(),invertedM=fabric.util.invertTransform(m),vptPointer=this.restorePointerVpt(pointer);return fabric.util.transformPoint(vptPointer,invertedM);},/**\n     * Returns true if object is transparent at a certain location\n     * @param {fabric.Object} target Object to check\n     * @param {Number} x Left coordinate\n     * @param {Number} y Top coordinate\n     * @return {Boolean}\n     */isTargetTransparent:function(target,x,y){// in case the target is the activeObject, we cannot execute this optimization\n// because we need to draw controls too.\nif(target.shouldCache()&&target._cacheCanvas&&target!==this._activeObject){var normalizedPointer=this._normalizePointer(target,{x:x,y:y}),targetRelativeX=Math.max(target.cacheTranslationX+normalizedPointer.x*target.zoomX,0),targetRelativeY=Math.max(target.cacheTranslationY+normalizedPointer.y*target.zoomY,0);var isTransparent=fabric.util.isTransparent(target._cacheContext,Math.round(targetRelativeX),Math.round(targetRelativeY),this.targetFindTolerance);return isTransparent;}var ctx=this.contextCache,originalColor=target.selectionBackgroundColor,v=this.viewportTransform;target.selectionBackgroundColor='';this.clearContext(ctx);ctx.save();ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]);target.render(ctx);ctx.restore();target.selectionBackgroundColor=originalColor;var isTransparent=fabric.util.isTransparent(ctx,x,y,this.targetFindTolerance);return isTransparent;},/**\n     * takes an event and determines if selection key has been pressed\n     * @private\n     * @param {Event} e Event object\n     */_isSelectionKeyPressed:function(e){var selectionKeyPressed=false;if(Object.prototype.toString.call(this.selectionKey)==='[object Array]'){selectionKeyPressed=!!this.selectionKey.find(function(key){return e[key]===true;});}else{selectionKeyPressed=e[this.selectionKey];}return selectionKeyPressed;},/**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */_shouldClearSelection:function(e,target){var activeObjects=this.getActiveObjects(),activeObject=this._activeObject;return!target||target&&activeObject&&activeObjects.length>1&&activeObjects.indexOf(target)===-1&&activeObject!==target&&!this._isSelectionKeyPressed(e)||target&&!target.evented||target&&!target.selectable&&activeObject&&activeObject!==target;},/**\n     * centeredScaling from object can't override centeredScaling from canvas.\n     * this should be fixed, since object setting should take precedence over canvas.\n     * also this should be something that will be migrated in the control properties.\n     * as ability to define the origin of the transformation that the control provide.\n     * @private\n     * @param {fabric.Object} target\n     * @param {String} action\n     * @param {Boolean} altKey\n     */_shouldCenterTransform:function(target,action,altKey){if(!target){return;}var centerTransform;if(action==='scale'||action==='scaleX'||action==='scaleY'||action==='resizing'){centerTransform=this.centeredScaling||target.centeredScaling;}else if(action==='rotate'){centerTransform=this.centeredRotation||target.centeredRotation;}return centerTransform?!altKey:altKey;},/**\n     * should disappear before release 4.0\n     * @private\n     */_getOriginFromCorner:function(target,corner){var origin={x:target.originX,y:target.originY};if(corner==='ml'||corner==='tl'||corner==='bl'){origin.x='right';}else if(corner==='mr'||corner==='tr'||corner==='br'){origin.x='left';}if(corner==='tl'||corner==='mt'||corner==='tr'){origin.y='bottom';}else if(corner==='bl'||corner==='mb'||corner==='br'){origin.y='top';}return origin;},/**\n     * @private\n     * @param {Boolean} alreadySelected true if target is already selected\n     * @param {String} corner a string representing the corner ml, mr, tl ...\n     * @param {Event} e Event object\n     * @param {fabric.Object} [target] inserted back to help overriding. Unused\n     */_getActionFromCorner:function(alreadySelected,corner,e,target){if(!corner||!alreadySelected){return'drag';}var control=target.controls[corner];return control.getActionName(e,control,target);},/**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */_setupCurrentTransform:function(e,target,alreadySelected){if(!target){return;}var pointer=this.getPointer(e),corner=target.__corner,control=target.controls[corner],actionHandler=alreadySelected&&corner?control.getActionHandler(e,target,control):fabric.controlsUtils.dragHandler,action=this._getActionFromCorner(alreadySelected,corner,e,target),origin=this._getOriginFromCorner(target,corner),altKey=e[this.centeredKey],transform={target:target,action:action,actionHandler:actionHandler,corner:corner,scaleX:target.scaleX,scaleY:target.scaleY,skewX:target.skewX,skewY:target.skewY,// used by transation\noffsetX:pointer.x-target.left,offsetY:pointer.y-target.top,originX:origin.x,originY:origin.y,ex:pointer.x,ey:pointer.y,lastX:pointer.x,lastY:pointer.y,// unsure they are useful anymore.\n// left: target.left,\n// top: target.top,\ntheta:degreesToRadians(target.angle),// end of unsure\nwidth:target.width*target.scaleX,shiftKey:e.shiftKey,altKey:altKey,original:fabric.util.saveObjectTransform(target)};if(this._shouldCenterTransform(target,action,altKey)){transform.originX='center';transform.originY='center';}transform.original.originX=origin.x;transform.original.originY=origin.y;this._currentTransform=transform;this._beforeTransform(e);},/**\n     * Set the cursor type of the canvas element\n     * @param {String} value Cursor type of the canvas element.\n     * @see http://www.w3.org/TR/css3-ui/#cursor\n     */setCursor:function(value){this.upperCanvasEl.style.cursor=value;},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx to draw the selection on\n     */_drawSelection:function(ctx){var selector=this._groupSelector,viewportStart=new fabric.Point(selector.ex,selector.ey),start=fabric.util.transformPoint(viewportStart,this.viewportTransform),viewportExtent=new fabric.Point(selector.ex+selector.left,selector.ey+selector.top),extent=fabric.util.transformPoint(viewportExtent,this.viewportTransform),minX=Math.min(start.x,extent.x),minY=Math.min(start.y,extent.y),maxX=Math.max(start.x,extent.x),maxY=Math.max(start.y,extent.y),strokeOffset=this.selectionLineWidth/2;if(this.selectionColor){ctx.fillStyle=this.selectionColor;ctx.fillRect(minX,minY,maxX-minX,maxY-minY);}if(!this.selectionLineWidth||!this.selectionBorderColor){return;}ctx.lineWidth=this.selectionLineWidth;ctx.strokeStyle=this.selectionBorderColor;minX+=strokeOffset;minY+=strokeOffset;maxX-=strokeOffset;maxY-=strokeOffset;// selection border\nfabric.Object.prototype._setLineDash.call(this,ctx,this.selectionDashArray);ctx.strokeRect(minX,minY,maxX-minX,maxY-minY);},/**\n     * Method that determines what object we are clicking on\n     * the skipGroup parameter is for internal use, is needed for shift+click action\n     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target\n     * or the outside part of the corner.\n     * @param {Event} e mouse event\n     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through\n     * @return {fabric.Object} the target found\n     */findTarget:function(e,skipGroup){if(this.skipTargetFind){return;}var ignoreZoom=true,pointer=this.getPointer(e,ignoreZoom),activeObject=this._activeObject,aObjects=this.getActiveObjects(),activeTarget,activeTargetSubs,isTouch=isTouchEvent(e),shouldLookForActive=aObjects.length>1&&!skipGroup||aObjects.length===1;// first check current group (if one exists)\n// active group does not check sub targets like normal groups.\n// if active group just exits.\nthis.targets=[];// if we hit the corner of an activeObject, let's return that.\nif(shouldLookForActive&&activeObject._findTargetCorner(pointer,isTouch)){return activeObject;}if(aObjects.length>1&&!skipGroup&&activeObject===this._searchPossibleTargets([activeObject],pointer)){return activeObject;}if(aObjects.length===1&&activeObject===this._searchPossibleTargets([activeObject],pointer)){if(!this.preserveObjectStacking){return activeObject;}else{activeTarget=activeObject;activeTargetSubs=this.targets;this.targets=[];}}var target=this._searchPossibleTargets(this._objects,pointer);if(e[this.altSelectionKey]&&target&&activeTarget&&target!==activeTarget){target=activeTarget;this.targets=activeTargetSubs;}return target;},/**\n     * Checks point is inside the object.\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @param {fabric.Object} obj Object to test against\n     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.\n     * @return {Boolean} true if point is contained within an area of given object\n     * @private\n     */_checkTarget:function(pointer,obj,globalPointer){if(obj&&obj.visible&&obj.evented&&// http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\n// http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\nobj.containsPoint(pointer)){if((this.perPixelTargetFind||obj.perPixelTargetFind)&&!obj.isEditing){var isTransparent=this.isTargetTransparent(obj,globalPointer.x,globalPointer.y);if(!isTransparent){return true;}}else{return true;}}},/**\n     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted\n     * @param {Array} [objects] objects array to look into\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @return {fabric.Object} object that contains pointer\n     * @private\n     */_searchPossibleTargets:function(objects,pointer){// Cache all targets where their bounding box contains point.\nvar target,i=objects.length,subTarget;// Do not check for currently grouped objects, since we check the parent group itself.\n// until we call this function specifically to search inside the activeGroup\nwhile(i--){var objToCheck=objects[i];var pointerToUse=objToCheck.group?this._normalizePointer(objToCheck.group,pointer):pointer;if(this._checkTarget(pointerToUse,objToCheck,pointer)){target=objects[i];if(target.subTargetCheck&&target instanceof fabric.Group){subTarget=this._searchPossibleTargets(target._objects,pointer);subTarget&&this.targets.push(subTarget);}break;}}return target;},/**\n     * Returns pointer coordinates without the effect of the viewport\n     * @param {Object} pointer with \"x\" and \"y\" number values\n     * @return {Object} object with \"x\" and \"y\" number values\n     */restorePointerVpt:function(pointer){return fabric.util.transformPoint(pointer,fabric.util.invertTransform(this.viewportTransform));},/**\n     * Returns pointer coordinates relative to canvas.\n     * Can return coordinates with or without viewportTransform.\n     * ignoreZoom false gives back coordinates that represent\n     * the point clicked on canvas element.\n     * ignoreZoom true gives back coordinates after being processed\n     * by the viewportTransform ( sort of coordinates of what is displayed\n     * on the canvas where you are clicking.\n     * ignoreZoom true = HTMLElement coordinates relative to top,left\n     * ignoreZoom false, default = fabric space coordinates, the same used for shape position\n     * To interact with your shapes top and left you want to use ignoreZoom true\n     * most of the time, while ignoreZoom false will give you coordinates\n     * compatible with the object.oCoords system.\n     * of the time.\n     * @param {Event} e\n     * @param {Boolean} ignoreZoom\n     * @return {Object} object with \"x\" and \"y\" number values\n     */getPointer:function(e,ignoreZoom){// return cached values if we are in the event processing chain\nif(this._absolutePointer&&!ignoreZoom){return this._absolutePointer;}if(this._pointer&&ignoreZoom){return this._pointer;}var pointer=getPointer(e),upperCanvasEl=this.upperCanvasEl,bounds=upperCanvasEl.getBoundingClientRect(),boundsWidth=bounds.width||0,boundsHeight=bounds.height||0,cssScale;if(!boundsWidth||!boundsHeight){if('top'in bounds&&'bottom'in bounds){boundsHeight=Math.abs(bounds.top-bounds.bottom);}if('right'in bounds&&'left'in bounds){boundsWidth=Math.abs(bounds.right-bounds.left);}}this.calcOffset();pointer.x=pointer.x-this._offset.left;pointer.y=pointer.y-this._offset.top;if(!ignoreZoom){pointer=this.restorePointerVpt(pointer);}var retinaScaling=this.getRetinaScaling();if(retinaScaling!==1){pointer.x/=retinaScaling;pointer.y/=retinaScaling;}if(boundsWidth===0||boundsHeight===0){// If bounds are not available (i.e. not visible), do not apply scale.\ncssScale={width:1,height:1};}else{cssScale={width:upperCanvasEl.width/boundsWidth,height:upperCanvasEl.height/boundsHeight};}return{x:pointer.x*cssScale.width,y:pointer.y*cssScale.height};},/**\n     * @private\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\n     */_createUpperCanvas:function(){var lowerCanvasClass=this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/,''),lowerCanvasEl=this.lowerCanvasEl,upperCanvasEl=this.upperCanvasEl;// there is no need to create a new upperCanvas element if we have already one.\nif(upperCanvasEl){upperCanvasEl.className='';}else{upperCanvasEl=this._createCanvasElement();this.upperCanvasEl=upperCanvasEl;}fabric.util.addClass(upperCanvasEl,'upper-canvas '+lowerCanvasClass);this.wrapperEl.appendChild(upperCanvasEl);this._copyCanvasStyle(lowerCanvasEl,upperCanvasEl);this._applyCanvasStyle(upperCanvasEl);this.contextTop=upperCanvasEl.getContext('2d');},/**\n     * @private\n     */_createCacheCanvas:function(){this.cacheCanvasEl=this._createCanvasElement();this.cacheCanvasEl.setAttribute('width',this.width);this.cacheCanvasEl.setAttribute('height',this.height);this.contextCache=this.cacheCanvasEl.getContext('2d');},/**\n     * @private\n     */_initWrapperElement:function(){this.wrapperEl=fabric.util.wrapElement(this.lowerCanvasEl,'div',{'class':this.containerClass});fabric.util.setStyle(this.wrapperEl,{width:this.width+'px',height:this.height+'px',position:'relative'});fabric.util.makeElementUnselectable(this.wrapperEl);},/**\n     * @private\n     * @param {HTMLElement} element canvas element to apply styles on\n     */_applyCanvasStyle:function(element){var width=this.width||element.width,height=this.height||element.height;fabric.util.setStyle(element,{position:'absolute',width:width+'px',height:height+'px',left:0,top:0,'touch-action':this.allowTouchScrolling?'manipulation':'none','-ms-touch-action':this.allowTouchScrolling?'manipulation':'none'});element.width=width;element.height=height;fabric.util.makeElementUnselectable(element);},/**\n     * Copy the entire inline style from one element (fromEl) to another (toEl)\n     * @private\n     * @param {Element} fromEl Element style is copied from\n     * @param {Element} toEl Element copied style is applied to\n     */_copyCanvasStyle:function(fromEl,toEl){toEl.style.cssText=fromEl.style.cssText;},/**\n     * Returns context of canvas where object selection is drawn\n     * @return {CanvasRenderingContext2D}\n     */getSelectionContext:function(){return this.contextTop;},/**\n     * Returns &lt;canvas> element on which object selection is drawn\n     * @return {HTMLCanvasElement}\n     */getSelectionElement:function(){return this.upperCanvasEl;},/**\n     * Returns currently active object\n     * @return {fabric.Object} active object\n     */getActiveObject:function(){return this._activeObject;},/**\n     * Returns an array with the current selected objects\n     * @return {fabric.Object} active object\n     */getActiveObjects:function(){var active=this._activeObject;if(active){if(active.type==='activeSelection'&&active._objects){return active._objects.slice(0);}else{return[active];}}return[];},/**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */_onObjectRemoved:function(obj){// removing active object should fire \"selection:cleared\" events\nif(obj===this._activeObject){this.fire('before:selection:cleared',{target:obj});this._discardActiveObject();this.fire('selection:cleared',{target:obj});obj.fire('deselected');}if(obj===this._hoveredTarget){this._hoveredTarget=null;this._hoveredTargets=[];}this.callSuper('_onObjectRemoved',obj);},/**\n     * @private\n     * Compares the old activeObject with the current one and fires correct events\n     * @param {fabric.Object} obj old activeObject\n     */_fireSelectionEvents:function(oldObjects,e){var somethingChanged=false,objects=this.getActiveObjects(),added=[],removed=[];oldObjects.forEach(function(oldObject){if(objects.indexOf(oldObject)===-1){somethingChanged=true;oldObject.fire('deselected',{e:e,target:oldObject});removed.push(oldObject);}});objects.forEach(function(object){if(oldObjects.indexOf(object)===-1){somethingChanged=true;object.fire('selected',{e:e,target:object});added.push(object);}});if(oldObjects.length>0&&objects.length>0){somethingChanged&&this.fire('selection:updated',{e:e,selected:added,deselected:removed,// added for backward compatibility\n// deprecated\nupdated:added[0]||removed[0],target:this._activeObject});}else if(objects.length>0){this.fire('selection:created',{e:e,selected:added,target:this._activeObject});}else if(oldObjects.length>0){this.fire('selection:cleared',{e:e,deselected:removed});}},/**\n     * Sets given object as the only active object on canvas\n     * @param {fabric.Object} object Object to set as an active one\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */setActiveObject:function(object,e){var currentActives=this.getActiveObjects();this._setActiveObject(object,e);this._fireSelectionEvents(currentActives,e);return this;},/**\n     * This is a private method for now.\n     * This is supposed to be equivalent to setActiveObject but without firing\n     * any event. There is commitment to have this stay this way.\n     * This is the functional part of setActiveObject.\n     * @private\n     * @param {Object} object to set as active\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {Boolean} true if the selection happened\n     */_setActiveObject:function(object,e){if(this._activeObject===object){return false;}if(!this._discardActiveObject(e,object)){return false;}if(object.onSelect({e:e})){return false;}this._activeObject=object;return true;},/**\n     * This is a private method for now.\n     * This is supposed to be equivalent to discardActiveObject but without firing\n     * any events. There is commitment to have this stay this way.\n     * This is the functional part of discardActiveObject.\n     * @param {Event} [e] Event (passed along when firing \"object:deselected\")\n     * @param {Object} object to set as active\n     * @return {Boolean} true if the selection happened\n     * @private\n     */_discardActiveObject:function(e,object){var obj=this._activeObject;if(obj){// onDeselect return TRUE to cancel selection;\nif(obj.onDeselect({e:e,object:object})){return false;}this._activeObject=null;}return true;},/**\n     * Discards currently active object and fire events. If the function is called by fabric\n     * as a consequence of a mouse event, the event is passed as a parameter and\n     * sent to the fire function for the custom events. When used as a method the\n     * e param does not have any application.\n     * @param {event} e\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */discardActiveObject:function(e){var currentActives=this.getActiveObjects(),activeObject=this.getActiveObject();if(currentActives.length){this.fire('before:selection:cleared',{target:activeObject,e:e});}this._discardActiveObject(e);this._fireSelectionEvents(currentActives,e);return this;},/**\n     * Clears a canvas element and removes all event listeners\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */dispose:function(){var wrapper=this.wrapperEl;this.removeListeners();wrapper.removeChild(this.upperCanvasEl);wrapper.removeChild(this.lowerCanvasEl);this.contextCache=null;this.contextTop=null;['upperCanvasEl','cacheCanvasEl'].forEach(function(element){fabric.util.cleanUpJsdomNode(this[element]);this[element]=undefined;}.bind(this));if(wrapper.parentNode){wrapper.parentNode.replaceChild(this.lowerCanvasEl,this.wrapperEl);}delete this.wrapperEl;fabric.StaticCanvas.prototype.dispose.call(this);return this;},/**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */clear:function(){// this.discardActiveGroup();\nthis.discardActiveObject();this.clearContext(this.contextTop);return this.callSuper('clear');},/**\n     * Draws objects' controls (borders/controls)\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\n     */drawControls:function(ctx){var activeObject=this._activeObject;if(activeObject){activeObject._renderControls(ctx);}},/**\n     * @private\n     */_toObject:function(instance,methodName,propertiesToInclude){//If the object is part of the current selection group, it should\n//be transformed appropriately\n//i.e. it should be serialised as it would appear if the selection group\n//were to be destroyed.\nvar originalProperties=this._realizeGroupTransformOnObject(instance),object=this.callSuper('_toObject',instance,methodName,propertiesToInclude);//Undo the damage we did by changing all of its properties\nthis._unwindGroupTransformOnObject(instance,originalProperties);return object;},/**\n     * Realises an object's group transformation on it\n     * @private\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\n     * @returns the original values of instance which were changed\n     */_realizeGroupTransformOnObject:function(instance){if(instance.group&&instance.group.type==='activeSelection'&&this._activeObject===instance.group){var layoutProps=['angle','flipX','flipY','left','scaleX','scaleY','skewX','skewY','top'];//Copy all the positionally relevant properties across now\nvar originalValues={};layoutProps.forEach(function(prop){originalValues[prop]=instance[prop];});fabric.util.addTransformToObject(instance,this._activeObject.calcOwnMatrix());return originalValues;}else{return null;}},/**\n     * Restores the changed properties of instance\n     * @private\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\n     */_unwindGroupTransformOnObject:function(instance,originalValues){if(originalValues){instance.set(originalValues);}},/**\n     * @private\n     */_setSVGObject:function(markup,instance,reviver){//If the object is in a selection group, simulate what would happen to that\n//object when the group is deselected\nvar originalProperties=this._realizeGroupTransformOnObject(instance);this.callSuper('_setSVGObject',markup,instance,reviver);this._unwindGroupTransformOnObject(instance,originalProperties);},setViewportTransform:function(vpt){if(this.renderOnAddRemove&&this._activeObject&&this._activeObject.isEditing){this._activeObject.clearContextTop();}fabric.StaticCanvas.prototype.setViewportTransform.call(this,vpt);}});// copying static properties manually to work around Opera's bug,\n// where \"prototype\" property is enumerable and overrides existing prototype\nfor(var prop in fabric.StaticCanvas){if(prop!=='prototype'){fabric.Canvas[prop]=fabric.StaticCanvas[prop];}}})();(function(){var addListener=fabric.util.addListener,removeListener=fabric.util.removeListener,RIGHT_CLICK=3,MIDDLE_CLICK=2,LEFT_CLICK=1,addEventOptions={passive:false};function checkClick(e,value){return e.button&&e.button===value-1;}fabric.util.object.extend(fabric.Canvas.prototype,/** @lends fabric.Canvas.prototype */{/**\n     * Contains the id of the touch event that owns the fabric transform\n     * @type Number\n     * @private\n     */mainTouchId:null,/**\n     * Adds mouse listeners to canvas\n     * @private\n     */_initEventListeners:function(){// in case we initialized the class twice. This should not happen normally\n// but in some kind of applications where the canvas element may be changed\n// this is a workaround to having double listeners.\nthis.removeListeners();this._bindEvents();this.addOrRemove(addListener,'add');},/**\n     * return an event prefix pointer or mouse.\n     * @private\n     */_getEventPrefix:function(){return this.enablePointerEvents?'pointer':'mouse';},addOrRemove:function(functor,eventjsFunctor){var canvasElement=this.upperCanvasEl,eventTypePrefix=this._getEventPrefix();functor(fabric.window,'resize',this._onResize);functor(canvasElement,eventTypePrefix+'down',this._onMouseDown);functor(canvasElement,eventTypePrefix+'move',this._onMouseMove,addEventOptions);functor(canvasElement,eventTypePrefix+'out',this._onMouseOut);functor(canvasElement,eventTypePrefix+'enter',this._onMouseEnter);functor(canvasElement,'wheel',this._onMouseWheel);functor(canvasElement,'contextmenu',this._onContextMenu);functor(canvasElement,'dblclick',this._onDoubleClick);functor(canvasElement,'dragover',this._onDragOver);functor(canvasElement,'dragenter',this._onDragEnter);functor(canvasElement,'dragleave',this._onDragLeave);functor(canvasElement,'drop',this._onDrop);if(!this.enablePointerEvents){functor(canvasElement,'touchstart',this._onTouchStart,addEventOptions);}if(typeof eventjs!=='undefined'&&eventjsFunctor in eventjs){eventjs[eventjsFunctor](canvasElement,'gesture',this._onGesture);eventjs[eventjsFunctor](canvasElement,'drag',this._onDrag);eventjs[eventjsFunctor](canvasElement,'orientation',this._onOrientationChange);eventjs[eventjsFunctor](canvasElement,'shake',this._onShake);eventjs[eventjsFunctor](canvasElement,'longpress',this._onLongPress);}},/**\n     * Removes all event listeners\n     */removeListeners:function(){this.addOrRemove(removeListener,'remove');// if you dispose on a mouseDown, before mouse up, you need to clean document to...\nvar eventTypePrefix=this._getEventPrefix();removeListener(fabric.document,eventTypePrefix+'up',this._onMouseUp);removeListener(fabric.document,'touchend',this._onTouchEnd,addEventOptions);removeListener(fabric.document,eventTypePrefix+'move',this._onMouseMove,addEventOptions);removeListener(fabric.document,'touchmove',this._onMouseMove,addEventOptions);},/**\n     * @private\n     */_bindEvents:function(){if(this.eventsBound){// for any reason we pass here twice we do not want to bind events twice.\nreturn;}this._onMouseDown=this._onMouseDown.bind(this);this._onTouchStart=this._onTouchStart.bind(this);this._onMouseMove=this._onMouseMove.bind(this);this._onMouseUp=this._onMouseUp.bind(this);this._onTouchEnd=this._onTouchEnd.bind(this);this._onResize=this._onResize.bind(this);this._onGesture=this._onGesture.bind(this);this._onDrag=this._onDrag.bind(this);this._onShake=this._onShake.bind(this);this._onLongPress=this._onLongPress.bind(this);this._onOrientationChange=this._onOrientationChange.bind(this);this._onMouseWheel=this._onMouseWheel.bind(this);this._onMouseOut=this._onMouseOut.bind(this);this._onMouseEnter=this._onMouseEnter.bind(this);this._onContextMenu=this._onContextMenu.bind(this);this._onDoubleClick=this._onDoubleClick.bind(this);this._onDragOver=this._onDragOver.bind(this);this._onDragEnter=this._simpleEventHandler.bind(this,'dragenter');this._onDragLeave=this._simpleEventHandler.bind(this,'dragleave');this._onDrop=this._simpleEventHandler.bind(this,'drop');this.eventsBound=true;},/**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js gesture\n     * @param {Event} [self] Inner Event object\n     */_onGesture:function(e,self){this.__onTransformGesture&&this.__onTransformGesture(e,self);},/**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js drag\n     * @param {Event} [self] Inner Event object\n     */_onDrag:function(e,self){this.__onDrag&&this.__onDrag(e,self);},/**\n     * @private\n     * @param {Event} [e] Event object fired on wheel event\n     */_onMouseWheel:function(e){this.__onMouseWheel(e);},/**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */_onMouseOut:function(e){var target=this._hoveredTarget;this.fire('mouse:out',{target:target,e:e});this._hoveredTarget=null;target&&target.fire('mouseout',{e:e});var _this=this;this._hoveredTargets.forEach(function(_target){_this.fire('mouse:out',{target:target,e:e});_target&&target.fire('mouseout',{e:e});});this._hoveredTargets=[];if(this._iTextInstances){this._iTextInstances.forEach(function(obj){if(obj.isEditing){obj.hiddenTextarea.focus();}});}},/**\n     * @private\n     * @param {Event} e Event object fired on mouseenter\n     */_onMouseEnter:function(e){// This find target and consequent 'mouse:over' is used to\n// clear old instances on hovered target.\n// calling findTarget has the side effect of killing target.__corner.\n// as a short term fix we are not firing this if we are currently transforming.\n// as a long term fix we need to separate the action of finding a target with the\n// side effects we added to it.\nif(!this._currentTransform&&!this.findTarget(e)){this.fire('mouse:over',{target:null,e:e});this._hoveredTarget=null;this._hoveredTargets=[];}},/**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js orientation change\n     * @param {Event} [self] Inner Event object\n     */_onOrientationChange:function(e,self){this.__onOrientationChange&&this.__onOrientationChange(e,self);},/**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */_onShake:function(e,self){this.__onShake&&this.__onShake(e,self);},/**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */_onLongPress:function(e,self){this.__onLongPress&&this.__onLongPress(e,self);},/**\n     * prevent default to allow drop event to be fired\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     */_onDragOver:function(e){e.preventDefault();var target=this._simpleEventHandler('dragover',e);this._fireEnterLeaveEvents(target,e);},/**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */_onContextMenu:function(e){if(this.stopContextMenu){e.stopPropagation();e.preventDefault();}return false;},/**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */_onDoubleClick:function(e){this._cacheTransformEventData(e);this._handleEvent(e,'dblclick');this._resetTransformEventData(e);},/**\n     * Return a the id of an event.\n     * returns either the pointerId or the identifier or 0 for the mouse event\n     * @private\n     * @param {Event} evt Event object\n     */getPointerId:function(evt){var changedTouches=evt.changedTouches;if(changedTouches){return changedTouches[0]&&changedTouches[0].identifier;}if(this.enablePointerEvents){return evt.pointerId;}return-1;},/**\n     * Determines if an event has the id of the event that is considered main\n     * @private\n     * @param {evt} event Event object\n     */_isMainEvent:function(evt){if(evt.isPrimary===true){return true;}if(evt.isPrimary===false){return false;}if(evt.type==='touchend'&&evt.touches.length===0){return true;}if(evt.changedTouches){return evt.changedTouches[0].identifier===this.mainTouchId;}return true;},/**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */_onTouchStart:function(e){e.preventDefault();if(this.mainTouchId===null){this.mainTouchId=this.getPointerId(e);}this.__onMouseDown(e);this._resetTransformEventData();var canvasElement=this.upperCanvasEl,eventTypePrefix=this._getEventPrefix();addListener(fabric.document,'touchend',this._onTouchEnd,addEventOptions);addListener(fabric.document,'touchmove',this._onMouseMove,addEventOptions);// Unbind mousedown to prevent double triggers from touch devices\nremoveListener(canvasElement,eventTypePrefix+'down',this._onMouseDown);},/**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */_onMouseDown:function(e){this.__onMouseDown(e);this._resetTransformEventData();var canvasElement=this.upperCanvasEl,eventTypePrefix=this._getEventPrefix();removeListener(canvasElement,eventTypePrefix+'move',this._onMouseMove,addEventOptions);addListener(fabric.document,eventTypePrefix+'up',this._onMouseUp);addListener(fabric.document,eventTypePrefix+'move',this._onMouseMove,addEventOptions);},/**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */_onTouchEnd:function(e){if(e.touches.length>0){// if there are still touches stop here\nreturn;}this.__onMouseUp(e);this._resetTransformEventData();this.mainTouchId=null;var eventTypePrefix=this._getEventPrefix();removeListener(fabric.document,'touchend',this._onTouchEnd,addEventOptions);removeListener(fabric.document,'touchmove',this._onMouseMove,addEventOptions);var _this=this;if(this._willAddMouseDown){clearTimeout(this._willAddMouseDown);}this._willAddMouseDown=setTimeout(function(){// Wait 400ms before rebinding mousedown to prevent double triggers\n// from touch devices\naddListener(_this.upperCanvasEl,eventTypePrefix+'down',_this._onMouseDown);_this._willAddMouseDown=0;},400);},/**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */_onMouseUp:function(e){this.__onMouseUp(e);this._resetTransformEventData();var canvasElement=this.upperCanvasEl,eventTypePrefix=this._getEventPrefix();if(this._isMainEvent(e)){removeListener(fabric.document,eventTypePrefix+'up',this._onMouseUp);removeListener(fabric.document,eventTypePrefix+'move',this._onMouseMove,addEventOptions);addListener(canvasElement,eventTypePrefix+'move',this._onMouseMove,addEventOptions);}},/**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */_onMouseMove:function(e){!this.allowTouchScrolling&&e.preventDefault&&e.preventDefault();this.__onMouseMove(e);},/**\n     * @private\n     */_onResize:function(){this.calcOffset();},/**\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n     * @private\n     * @param {Object} target\n     */_shouldRender:function(target){var activeObject=this._activeObject;if(!!activeObject!==!!target||activeObject&&target&&activeObject!==target){// this covers: switch of target, from target to no target, selection of target\n// multiSelection with key and mouse\nreturn true;}else if(activeObject&&activeObject.isEditing){// if we mouse up/down over a editing textbox a cursor change,\n// there is no need to re render\nreturn false;}return false;},/**\n     * Method that defines the actions when mouse is released on canvas.\n     * The method resets the currentTransform parameters, store the image corner\n     * position in the image object and render the canvas on top.\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */__onMouseUp:function(e){var target,transform=this._currentTransform,groupSelector=this._groupSelector,shouldRender=false,isClick=!groupSelector||groupSelector.left===0&&groupSelector.top===0;this._cacheTransformEventData(e);target=this._target;this._handleEvent(e,'up:before');// if right/middle click just fire events and return\n// target undefined will make the _handleEvent search the target\nif(checkClick(e,RIGHT_CLICK)){if(this.fireRightClick){this._handleEvent(e,'up',RIGHT_CLICK,isClick);}return;}if(checkClick(e,MIDDLE_CLICK)){if(this.fireMiddleClick){this._handleEvent(e,'up',MIDDLE_CLICK,isClick);}this._resetTransformEventData();return;}if(this.isDrawingMode&&this._isCurrentlyDrawing){this._onMouseUpInDrawingMode(e);return;}if(!this._isMainEvent(e)){return;}if(transform){this._finalizeCurrentTransform(e);shouldRender=transform.actionPerformed;}if(!isClick){var targetWasActive=target===this._activeObject;this._maybeGroupObjects(e);if(!shouldRender){shouldRender=this._shouldRender(target)||!targetWasActive&&target===this._activeObject;}}if(target){if(target.selectable&&target!==this._activeObject&&target.activeOn==='up'){this.setActiveObject(target,e);shouldRender=true;}else{var corner=target._findTargetCorner(this.getPointer(e,true),fabric.util.isTouchEvent(e));var control=target.controls[corner],mouseUpHandler=control&&control.getMouseUpHandler(e,target,control);if(mouseUpHandler){var pointer=this.getPointer(e);mouseUpHandler(e,transform,pointer.x,pointer.y);}}target.isMoving=false;}this._setCursorFromEvent(e,target);this._handleEvent(e,'up',LEFT_CLICK,isClick);this._groupSelector=null;this._currentTransform=null;// reset the target information about which corner is selected\ntarget&&(target.__corner=0);if(shouldRender){this.requestRenderAll();}else if(!isClick){this.renderTop();}},/**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @return {Fabric.Object} target return the the target found, for internal reasons.\n     */_simpleEventHandler:function(eventType,e){var target=this.findTarget(e),targets=this.targets,options={e:e,target:target,subTargets:targets};this.fire(eventType,options);target&&target.fire(eventType,options);if(!targets){return target;}for(var i=0;i<targets.length;i++){targets[i].fire(eventType,options);}return target;},/**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @param {fabric.Object} targetObj receiving event\n     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right\n     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.\n     */_handleEvent:function(e,eventType,button,isClick){var target=this._target,targets=this.targets||[],options={e:e,target:target,subTargets:targets,button:button||LEFT_CLICK,isClick:isClick||false,pointer:this._pointer,absolutePointer:this._absolutePointer,transform:this._currentTransform};if(eventType==='up'){options.currentTarget=this.findTarget(e);options.currentSubTargets=this.targets;}this.fire('mouse:'+eventType,options);target&&target.fire('mouse'+eventType,options);for(var i=0;i<targets.length;i++){targets[i].fire('mouse'+eventType,options);}},/**\n     * @private\n     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event\n     */_finalizeCurrentTransform:function(e){var transform=this._currentTransform,target=transform.target,eventName,options={e:e,target:target,transform:transform,action:transform.action};if(target._scaling){target._scaling=false;}target.setCoords();if(transform.actionPerformed||this.stateful&&target.hasStateChanged()){if(transform.actionPerformed){// this is not friendly to the new control api.\n// is deprecated.\neventName=this._addEventOptions(options,transform);this._fire(eventName,options);}this._fire('modified',options);}},/**\n     * Mutate option object in order to add by property and give back the event name.\n     * @private\n     * @deprecated since 4.2.0\n     * @param {Object} options to mutate\n     * @param {Object} transform to inspect action from\n     */_addEventOptions:function(options,transform){// we can probably add more details at low cost\n// scale change, rotation changes, translation changes\nvar eventName,by;switch(transform.action){case'scaleX':eventName='scaled';by='x';break;case'scaleY':eventName='scaled';by='y';break;case'skewX':eventName='skewed';by='x';break;case'skewY':eventName='skewed';by='y';break;case'scale':eventName='scaled';by='equally';break;case'rotate':eventName='rotated';break;case'drag':eventName='moved';break;}options.by=by;return eventName;},/**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */_onMouseDownInDrawingMode:function(e){this._isCurrentlyDrawing=true;if(this.getActiveObject()){this.discardActiveObject(e).requestRenderAll();}var pointer=this.getPointer(e);this.freeDrawingBrush.onMouseDown(pointer,{e:e,pointer:pointer});this._handleEvent(e,'down');},/**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */_onMouseMoveInDrawingMode:function(e){if(this._isCurrentlyDrawing){var pointer=this.getPointer(e);this.freeDrawingBrush.onMouseMove(pointer,{e:e,pointer:pointer});}this.setCursor(this.freeDrawingCursor);this._handleEvent(e,'move');},/**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */_onMouseUpInDrawingMode:function(e){var pointer=this.getPointer(e);this._isCurrentlyDrawing=this.freeDrawingBrush.onMouseUp({e:e,pointer:pointer});this._handleEvent(e,'up');},/**\n     * Method that defines the actions when mouse is clicked on canvas.\n     * The method inits the currentTransform parameters and renders all the\n     * canvas so the current image can be placed on the top canvas and the rest\n     * in on the container one.\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */__onMouseDown:function(e){this._cacheTransformEventData(e);this._handleEvent(e,'down:before');var target=this._target;// if right click just fire events\nif(checkClick(e,RIGHT_CLICK)){if(this.fireRightClick){this._handleEvent(e,'down',RIGHT_CLICK);}return;}if(checkClick(e,MIDDLE_CLICK)){if(this.fireMiddleClick){this._handleEvent(e,'down',MIDDLE_CLICK);}return;}if(this.isDrawingMode){this._onMouseDownInDrawingMode(e);return;}if(!this._isMainEvent(e)){return;}// ignore if some object is being transformed at this moment\nif(this._currentTransform){return;}var pointer=this._pointer;// save pointer for check in __onMouseUp event\nthis._previousPointer=pointer;var shouldRender=this._shouldRender(target),shouldGroup=this._shouldGroup(e,target);if(this._shouldClearSelection(e,target)){this.discardActiveObject(e);}else if(shouldGroup){this._handleGrouping(e,target);target=this._activeObject;}if(this.selection&&(!target||!target.selectable&&!target.isEditing&&target!==this._activeObject)){this._groupSelector={ex:this._absolutePointer.x,ey:this._absolutePointer.y,top:0,left:0};}if(target){var alreadySelected=target===this._activeObject;if(target.selectable&&target.activeOn==='down'){this.setActiveObject(target,e);}var corner=target._findTargetCorner(this.getPointer(e,true),fabric.util.isTouchEvent(e));target.__corner=corner;if(target===this._activeObject&&(corner||!shouldGroup)){this._setupCurrentTransform(e,target,alreadySelected);var control=target.controls[corner],pointer=this.getPointer(e),mouseDownHandler=control&&control.getMouseDownHandler(e,target,control);if(mouseDownHandler){mouseDownHandler(e,this._currentTransform,pointer.x,pointer.y);}}}this._handleEvent(e,'down');// we must renderAll so that we update the visuals\n(shouldRender||shouldGroup)&&this.requestRenderAll();},/**\n     * reset cache form common information needed during event processing\n     * @private\n     */_resetTransformEventData:function(){this._target=null;this._pointer=null;this._absolutePointer=null;},/**\n     * Cache common information needed during event processing\n     * @private\n     * @param {Event} e Event object fired on event\n     */_cacheTransformEventData:function(e){// reset in order to avoid stale caching\nthis._resetTransformEventData();this._pointer=this.getPointer(e,true);this._absolutePointer=this.restorePointerVpt(this._pointer);this._target=this._currentTransform?this._currentTransform.target:this.findTarget(e)||null;},/**\n     * @private\n     */_beforeTransform:function(e){var t=this._currentTransform;this.stateful&&t.target.saveState();this.fire('before:transform',{e:e,transform:t});},/**\n     * Method that defines the actions when mouse is hovering the canvas.\n     * The currentTransform parameter will define whether the user is rotating/scaling/translating\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\n     * all any other type of action.\n     * In case of an image transformation only the top canvas will be rendered.\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */__onMouseMove:function(e){this._handleEvent(e,'move:before');this._cacheTransformEventData(e);var target,pointer;if(this.isDrawingMode){this._onMouseMoveInDrawingMode(e);return;}if(!this._isMainEvent(e)){return;}var groupSelector=this._groupSelector;// We initially clicked in an empty area, so we draw a box for multiple selection\nif(groupSelector){pointer=this._absolutePointer;groupSelector.left=pointer.x-groupSelector.ex;groupSelector.top=pointer.y-groupSelector.ey;this.renderTop();}else if(!this._currentTransform){target=this.findTarget(e)||null;this._setCursorFromEvent(e,target);this._fireOverOutEvents(target,e);}else{this._transformObject(e);}this._handleEvent(e,'move');this._resetTransformEventData();},/**\n     * Manage the mouseout, mouseover events for the fabric object on the canvas\n     * @param {Fabric.Object} target the target where the target from the mousemove event\n     * @param {Event} e Event object fired on mousemove\n     * @private\n     */_fireOverOutEvents:function(target,e){var _hoveredTarget=this._hoveredTarget,_hoveredTargets=this._hoveredTargets,targets=this.targets,length=Math.max(_hoveredTargets.length,targets.length);this.fireSyntheticInOutEvents(target,e,{oldTarget:_hoveredTarget,evtOut:'mouseout',canvasEvtOut:'mouse:out',evtIn:'mouseover',canvasEvtIn:'mouse:over'});for(var i=0;i<length;i++){this.fireSyntheticInOutEvents(targets[i],e,{oldTarget:_hoveredTargets[i],evtOut:'mouseout',evtIn:'mouseover'});}this._hoveredTarget=target;this._hoveredTargets=this.targets.concat();},/**\n     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the onDrag event\n     * @param {Event} e Event object fired on ondrag\n     * @private\n     */_fireEnterLeaveEvents:function(target,e){var _draggedoverTarget=this._draggedoverTarget,_hoveredTargets=this._hoveredTargets,targets=this.targets,length=Math.max(_hoveredTargets.length,targets.length);this.fireSyntheticInOutEvents(target,e,{oldTarget:_draggedoverTarget,evtOut:'dragleave',evtIn:'dragenter'});for(var i=0;i<length;i++){this.fireSyntheticInOutEvents(targets[i],e,{oldTarget:_hoveredTargets[i],evtOut:'dragleave',evtIn:'dragenter'});}this._draggedoverTarget=target;},/**\n     * Manage the synthetic in/out events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the supported events\n     * @param {Event} e Event object fired\n     * @param {Object} config configuration for the function to work\n     * @param {String} config.targetName property on the canvas where the old target is stored\n     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n     * @param {String} config.evtOut name of the event to fire for out\n     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n     * @param {String} config.evtIn name of the event to fire for in\n     * @private\n     */fireSyntheticInOutEvents:function(target,e,config){var inOpt,outOpt,oldTarget=config.oldTarget,outFires,inFires,targetChanged=oldTarget!==target,canvasEvtIn=config.canvasEvtIn,canvasEvtOut=config.canvasEvtOut;if(targetChanged){inOpt={e:e,target:target,previousTarget:oldTarget};outOpt={e:e,target:oldTarget,nextTarget:target};}inFires=target&&targetChanged;outFires=oldTarget&&targetChanged;if(outFires){canvasEvtOut&&this.fire(canvasEvtOut,outOpt);oldTarget.fire(config.evtOut,outOpt);}if(inFires){canvasEvtIn&&this.fire(canvasEvtIn,inOpt);target.fire(config.evtIn,inOpt);}},/**\n     * Method that defines actions when an Event Mouse Wheel\n     * @param {Event} e Event object fired on mouseup\n     */__onMouseWheel:function(e){this._cacheTransformEventData(e);this._handleEvent(e,'wheel');this._resetTransformEventData();},/**\n     * @private\n     * @param {Event} e Event fired on mousemove\n     */_transformObject:function(e){var pointer=this.getPointer(e),transform=this._currentTransform;transform.reset=false;transform.shiftKey=e.shiftKey;transform.altKey=e[this.centeredKey];this._performTransformAction(e,transform,pointer);transform.actionPerformed&&this.requestRenderAll();},/**\n     * @private\n     */_performTransformAction:function(e,transform,pointer){var x=pointer.x,y=pointer.y,action=transform.action,actionPerformed=false,actionHandler=transform.actionHandler;// this object could be created from the function in the control handlers\nif(actionHandler){actionPerformed=actionHandler(e,transform,x,y);}if(action==='drag'&&actionPerformed){transform.target.isMoving=true;this.setCursor(transform.target.moveCursor||this.moveCursor);}transform.actionPerformed=transform.actionPerformed||actionPerformed;},/**\n     * @private\n     */_fire:fabric.controlsUtils.fireEvent,/**\n     * Sets the cursor depending on where the canvas is being hovered.\n     * Note: very buggy in Opera\n     * @param {Event} e Event object\n     * @param {Object} target Object that the mouse is hovering, if so.\n     */_setCursorFromEvent:function(e,target){if(!target){this.setCursor(this.defaultCursor);return false;}var hoverCursor=target.hoverCursor||this.hoverCursor,activeSelection=this._activeObject&&this._activeObject.type==='activeSelection'?this._activeObject:null,// only show proper corner when group selection is not active\ncorner=(!activeSelection||!activeSelection.contains(target)// here we call findTargetCorner always with undefined for the touch parameter.\n// we assume that if you are using a cursor you do not need to interact with\n// the bigger touch area.\n)&&target._findTargetCorner(this.getPointer(e,true));if(!corner){if(target.subTargetCheck){// hoverCursor should come from top-most subTarget,\n// so we walk the array backwards\nthis.targets.concat().reverse().map(function(_target){hoverCursor=_target.hoverCursor||hoverCursor;});}this.setCursor(hoverCursor);}else{this.setCursor(this.getCornerCursor(corner,target,e));}},/**\n     * @private\n     */getCornerCursor:function(corner,target,e){var control=target.controls[corner];return control.cursorStyleHandler(e,control,target);}});})();(function(){var min=Math.min,max=Math.max;fabric.util.object.extend(fabric.Canvas.prototype,/** @lends fabric.Canvas.prototype */{/**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     * @return {Boolean}\n     */_shouldGroup:function(e,target){var activeObject=this._activeObject;return activeObject&&this._isSelectionKeyPressed(e)&&target&&target.selectable&&this.selection&&(activeObject!==target||activeObject.type==='activeSelection')&&!target.onSelect({e:e});},/**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */_handleGrouping:function(e,target){var activeObject=this._activeObject;// avoid multi select when shift click on a corner\nif(activeObject.__corner){return;}if(target===activeObject){// if it's a group, find target again, using activeGroup objects\ntarget=this.findTarget(e,true);// if even object is not found or we are on activeObjectCorner, bail out\nif(!target||!target.selectable){return;}}if(activeObject&&activeObject.type==='activeSelection'){this._updateActiveSelection(target,e);}else{this._createActiveSelection(target,e);}},/**\n     * @private\n     */_updateActiveSelection:function(target,e){var activeSelection=this._activeObject,currentActiveObjects=activeSelection._objects.slice(0);if(activeSelection.contains(target)){activeSelection.removeWithUpdate(target);this._hoveredTarget=target;this._hoveredTargets=this.targets.concat();if(activeSelection.size()===1){// activate last remaining object\nthis._setActiveObject(activeSelection.item(0),e);}}else{activeSelection.addWithUpdate(target);this._hoveredTarget=activeSelection;this._hoveredTargets=this.targets.concat();}this._fireSelectionEvents(currentActiveObjects,e);},/**\n     * @private\n     */_createActiveSelection:function(target,e){var currentActives=this.getActiveObjects(),group=this._createGroup(target);this._hoveredTarget=group;// ISSUE 4115: should we consider subTargets here?\n// this._hoveredTargets = [];\n// this._hoveredTargets = this.targets.concat();\nthis._setActiveObject(group,e);this._fireSelectionEvents(currentActives,e);},/**\n     * @private\n     * @param {Object} target\n     */_createGroup:function(target){var objects=this._objects,isActiveLower=objects.indexOf(this._activeObject)<objects.indexOf(target),groupObjects=isActiveLower?[this._activeObject,target]:[target,this._activeObject];this._activeObject.isEditing&&this._activeObject.exitEditing();return new fabric.ActiveSelection(groupObjects,{canvas:this});},/**\n     * @private\n     * @param {Event} e mouse event\n     */_groupSelectedObjects:function(e){var group=this._collectObjects(e),aGroup;// do not create group for 1 element only\nif(group.length===1){this.setActiveObject(group[0],e);}else if(group.length>1){aGroup=new fabric.ActiveSelection(group.reverse(),{canvas:this});this.setActiveObject(aGroup,e);}},/**\n     * @private\n     */_collectObjects:function(e){var group=[],currentObject,x1=this._groupSelector.ex,y1=this._groupSelector.ey,x2=x1+this._groupSelector.left,y2=y1+this._groupSelector.top,selectionX1Y1=new fabric.Point(min(x1,x2),min(y1,y2)),selectionX2Y2=new fabric.Point(max(x1,x2),max(y1,y2)),allowIntersect=!this.selectionFullyContained,isClick=x1===x2&&y1===y2;// we iterate reverse order to collect top first in case of click.\nfor(var i=this._objects.length;i--;){currentObject=this._objects[i];if(!currentObject||!currentObject.selectable||!currentObject.visible){continue;}if(allowIntersect&&currentObject.intersectsWithRect(selectionX1Y1,selectionX2Y2,true)||currentObject.isContainedWithinRect(selectionX1Y1,selectionX2Y2,true)||allowIntersect&&currentObject.containsPoint(selectionX1Y1,null,true)||allowIntersect&&currentObject.containsPoint(selectionX2Y2,null,true)){group.push(currentObject);// only add one object if it's a click\nif(isClick){break;}}}if(group.length>1){group=group.filter(function(object){return!object.onSelect({e:e});});}return group;},/**\n     * @private\n     */_maybeGroupObjects:function(e){if(this.selection&&this._groupSelector){this._groupSelectedObjects(e);}this.setCursor(this.defaultCursor);// clear selection and current transformation\nthis._groupSelector=null;}});})();(function(){fabric.util.object.extend(fabric.StaticCanvas.prototype,/** @lends fabric.StaticCanvas.prototype */{/**\n     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\n     * @param {Object} [options] Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\n     * @example <caption>Generate jpeg dataURL with lower quality</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'jpeg',\n     *   quality: 0.8\n     * });\n     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   left: 100,\n     *   top: 100,\n     *   width: 200,\n     *   height: 200\n     * });\n     * @example <caption>Generate double scaled png dataURL</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   multiplier: 2\n     * });\n     */toDataURL:function(options){options||(options={});var format=options.format||'png',quality=options.quality||1,multiplier=(options.multiplier||1)*(options.enableRetinaScaling?this.getRetinaScaling():1),canvasEl=this.toCanvasElement(multiplier,options);return fabric.util.toDataURL(canvasEl,format,quality);},/**\n     * Create a new HTMLCanvas element painted with the current canvas content.\n     * No need to resize the actual one or repaint it.\n     * Will transfer object ownership to a new canvas, paint it, and set everything back.\n     * This is an intermediary step used to get to a dataUrl but also it is useful to\n     * create quick image copies of a canvas without passing for the dataUrl string\n     * @param {Number} [multiplier] a zoom factor.\n     * @param {Object} [cropping] Cropping informations\n     * @param {Number} [cropping.left] Cropping left offset.\n     * @param {Number} [cropping.top] Cropping top offset.\n     * @param {Number} [cropping.width] Cropping width.\n     * @param {Number} [cropping.height] Cropping height.\n     */toCanvasElement:function(multiplier,cropping){multiplier=multiplier||1;cropping=cropping||{};var scaledWidth=(cropping.width||this.width)*multiplier,scaledHeight=(cropping.height||this.height)*multiplier,zoom=this.getZoom(),originalWidth=this.width,originalHeight=this.height,newZoom=zoom*multiplier,vp=this.viewportTransform,translateX=(vp[4]-(cropping.left||0))*multiplier,translateY=(vp[5]-(cropping.top||0))*multiplier,originalInteractive=this.interactive,newVp=[newZoom,0,0,newZoom,translateX,translateY],originalRetina=this.enableRetinaScaling,canvasEl=fabric.util.createCanvasElement(),originalContextTop=this.contextTop;canvasEl.width=scaledWidth;canvasEl.height=scaledHeight;this.contextTop=null;this.enableRetinaScaling=false;this.interactive=false;this.viewportTransform=newVp;this.width=scaledWidth;this.height=scaledHeight;this.calcViewportBoundaries();this.renderCanvas(canvasEl.getContext('2d'),this._objects);this.viewportTransform=vp;this.width=originalWidth;this.height=originalHeight;this.calcViewportBoundaries();this.interactive=originalInteractive;this.enableRetinaScaling=originalRetina;this.contextTop=originalContextTop;return canvasEl;}});})();fabric.util.object.extend(fabric.StaticCanvas.prototype,/** @lends fabric.StaticCanvas.prototype */{/**\n   * Populates canvas with data from the specified JSON.\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\n   * @param {String|Object} json JSON string or object\n   * @param {Function} callback Callback, invoked when json is parsed\n   *                            and corresponding objects (e.g: {@link fabric.Image})\n   *                            are initialized\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\n   * @return {fabric.Canvas} instance\n   * @chainable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\n   * @example <caption>loadFromJSON</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\n   * @example <caption>loadFromJSON with reviver</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\n   *   // `o` = json object\n   *   // `object` = fabric.Object instance\n   *   // ... do some stuff ...\n   * });\n   */loadFromJSON:function(json,callback,reviver){if(!json){return;}// serialize if it wasn't already\nvar serialized=typeof json==='string'?JSON.parse(json):fabric.util.object.clone(json);var _this=this,clipPath=serialized.clipPath,renderOnAddRemove=this.renderOnAddRemove;this.renderOnAddRemove=false;delete serialized.clipPath;this._enlivenObjects(serialized.objects,function(enlivenedObjects){_this.clear();_this._setBgOverlay(serialized,function(){if(clipPath){_this._enlivenObjects([clipPath],function(enlivenedCanvasClip){_this.clipPath=enlivenedCanvasClip[0];_this.__setupCanvas.call(_this,serialized,enlivenedObjects,renderOnAddRemove,callback);});}else{_this.__setupCanvas.call(_this,serialized,enlivenedObjects,renderOnAddRemove,callback);}});},reviver);return this;},/**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Array} restored canvas objects\n   * @param {Function} cached renderOnAddRemove callback\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */__setupCanvas:function(serialized,enlivenedObjects,renderOnAddRemove,callback){var _this=this;enlivenedObjects.forEach(function(obj,index){// we splice the array just in case some custom classes restored from JSON\n// will add more object to canvas at canvas init.\n_this.insertAt(obj,index);});this.renderOnAddRemove=renderOnAddRemove;// remove parts i cannot set as options\ndelete serialized.objects;delete serialized.backgroundImage;delete serialized.overlayImage;delete serialized.background;delete serialized.overlay;// this._initOptions does too many things to just\n// call it. Normally loading an Object from JSON\n// create the Object instance. Here the Canvas is\n// already an instance and we are just loading things over it\nthis._setOptions(serialized);this.renderAll();callback&&callback();},/**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */_setBgOverlay:function(serialized,callback){var loaded={backgroundColor:false,overlayColor:false,backgroundImage:false,overlayImage:false};if(!serialized.backgroundImage&&!serialized.overlayImage&&!serialized.background&&!serialized.overlay){callback&&callback();return;}var cbIfLoaded=function(){if(loaded.backgroundImage&&loaded.overlayImage&&loaded.backgroundColor&&loaded.overlayColor){callback&&callback();}};this.__setBgOverlay('backgroundImage',serialized.backgroundImage,loaded,cbIfLoaded);this.__setBgOverlay('overlayImage',serialized.overlayImage,loaded,cbIfLoaded);this.__setBgOverlay('backgroundColor',serialized.background,loaded,cbIfLoaded);this.__setBgOverlay('overlayColor',serialized.overlay,loaded,cbIfLoaded);},/**\n   * @private\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\n   * @param {(Object|String)} value Value to set\n   * @param {Object} loaded Set loaded property to true if property is set\n   * @param {Object} callback Callback function to invoke after property is set\n   */__setBgOverlay:function(property,value,loaded,callback){var _this=this;if(!value){loaded[property]=true;callback&&callback();return;}if(property==='backgroundImage'||property==='overlayImage'){fabric.util.enlivenObjects([value],function(enlivedObject){_this[property]=enlivedObject[0];loaded[property]=true;callback&&callback();});}else{this['set'+fabric.util.string.capitalize(property,true)](value,function(){loaded[property]=true;callback&&callback();});}},/**\n   * @private\n   * @param {Array} objects\n   * @param {Function} callback\n   * @param {Function} [reviver]\n   */_enlivenObjects:function(objects,callback,reviver){if(!objects||objects.length===0){callback&&callback([]);return;}fabric.util.enlivenObjects(objects,function(enlivenedObjects){callback&&callback(enlivenedObjects);},null,reviver);},/**\n   * @private\n   * @param {String} format\n   * @param {Function} callback\n   */_toDataURL:function(format,callback){this.clone(function(clone){callback(clone.toDataURL(format));});},/**\n   * @private\n   * @param {String} format\n   * @param {Number} multiplier\n   * @param {Function} callback\n   */_toDataURLWithMultiplier:function(format,multiplier,callback){this.clone(function(clone){callback(clone.toDataURLWithMultiplier(format,multiplier));});},/**\n   * Clones canvas instance\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\n   */clone:function(callback,properties){var data=JSON.stringify(this.toJSON(properties));this.cloneWithoutData(function(clone){clone.loadFromJSON(data,function(){callback&&callback(clone);});});},/**\n   * Clones canvas instance without cloning existing data.\n   * This essentially copies canvas dimensions, clipping properties, etc.\n   * but leaves data empty (so that you can populate it with your own)\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   */cloneWithoutData:function(callback){var el=fabric.util.createCanvasElement();el.width=this.width;el.height=this.height;var clone=new fabric.Canvas(el);if(this.backgroundImage){clone.setBackgroundImage(this.backgroundImage.src,function(){clone.renderAll();callback&&callback(clone);});clone.backgroundImageOpacity=this.backgroundImageOpacity;clone.backgroundImageStretch=this.backgroundImageStretch;}else{callback&&callback(clone);}}});(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),extend=fabric.util.object.extend,clone=fabric.util.object.clone,toFixed=fabric.util.toFixed,capitalize=fabric.util.string.capitalize,degreesToRadians=fabric.util.degreesToRadians,objectCaching=!fabric.isLikelyNode,ALIASING_LIMIT=2;if(fabric.Object){return;}/**\n   * Root object class from which all 2d shape classes inherit from\n   * @class fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}\n   * @see {@link fabric.Object#initialize} for constructor definition\n   *\n   * @fires added\n   * @fires removed\n   *\n   * @fires selected\n   * @fires deselected\n   * @fires modified\n   * @fires modified\n   * @fires moved\n   * @fires scaled\n   * @fires rotated\n   * @fires skewed\n   *\n   * @fires rotating\n   * @fires scaling\n   * @fires moving\n   * @fires skewing\n   *\n   * @fires mousedown\n   * @fires mouseup\n   * @fires mouseover\n   * @fires mouseout\n   * @fires mousewheel\n   * @fires mousedblclick\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop\n   */fabric.Object=fabric.util.createClass(fabric.CommonMethods,/** @lends fabric.Object.prototype */{/**\n     * Type of an object (rect, circle, path, etc.).\n     * Note that this property is meant to be read-only and not meant to be modified.\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\n     * @type String\n     * @default\n     */type:'object',/**\n     * Horizontal origin of transformation of an object (one of \"left\", \"right\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */originX:'left',/**\n     * Vertical origin of transformation of an object (one of \"top\", \"bottom\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */originY:'top',/**\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\n     * @type Number\n     * @default\n     */top:0,/**\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\n     * @type Number\n     * @default\n     */left:0,/**\n     * Object width\n     * @type Number\n     * @default\n     */width:0,/**\n     * Object height\n     * @type Number\n     * @default\n     */height:0,/**\n     * Object scale factor (horizontal)\n     * @type Number\n     * @default\n     */scaleX:1,/**\n     * Object scale factor (vertical)\n     * @type Number\n     * @default\n     */scaleY:1,/**\n     * When true, an object is rendered as flipped horizontally\n     * @type Boolean\n     * @default\n     */flipX:false,/**\n     * When true, an object is rendered as flipped vertically\n     * @type Boolean\n     * @default\n     */flipY:false,/**\n     * Opacity of an object\n     * @type Number\n     * @default\n     */opacity:1,/**\n     * Angle of rotation of an object (in degrees)\n     * @type Number\n     * @default\n     */angle:0,/**\n     * Angle of skew on x axes of an object (in degrees)\n     * @type Number\n     * @default\n     */skewX:0,/**\n     * Angle of skew on y axes of an object (in degrees)\n     * @type Number\n     * @default\n     */skewY:0,/**\n     * Size of object's controlling corners (in pixels)\n     * @type Number\n     * @default\n     */cornerSize:13,/**\n     * Size of object's controlling corners when touch interaction is detected\n     * @type Number\n     * @default\n     */touchCornerSize:24,/**\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\n     * @type Boolean\n     * @default\n     */transparentCorners:true,/**\n     * Default cursor value used when hovering over this object on canvas\n     * @type String\n     * @default\n     */hoverCursor:null,/**\n     * Default cursor value used when moving this object on canvas\n     * @type String\n     * @default\n     */moveCursor:null,/**\n     * Padding between object and its controlling borders (in pixels)\n     * @type Number\n     * @default\n     */padding:0,/**\n     * Color of controlling borders of an object (when it's active)\n     * @type String\n     * @default\n     */borderColor:'rgb(178,204,255)',/**\n     * Array specifying dash pattern of an object's borders (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */borderDashArray:null,/**\n     * Color of controlling corners of an object (when it's active)\n     * @type String\n     * @default\n     */cornerColor:'rgb(178,204,255)',/**\n     * Color of controlling corners of an object (when it's active and transparentCorners false)\n     * @since 1.6.2\n     * @type String\n     * @default\n     */cornerStrokeColor:null,/**\n     * Specify style of control, 'rect' or 'circle'\n     * @since 1.6.2\n     * @type String\n     */cornerStyle:'rect',/**\n     * Array specifying dash pattern of an object's control (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */cornerDashArray:null,/**\n     * When true, this object will use center point as the origin of transformation\n     * when being scaled via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */centeredScaling:false,/**\n     * When true, this object will use center point as the origin of transformation\n     * when being rotated via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */centeredRotation:true,/**\n     * Color of object's fill\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */fill:'rgb(0,0,0)',/**\n     * Fill rule used to fill an object\n     * accepted values are nonzero, evenodd\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\n     * @type String\n     * @default\n     */fillRule:'nonzero',/**\n     * Composite rule used for canvas globalCompositeOperation\n     * @type String\n     * @default\n     */globalCompositeOperation:'source-over',/**\n     * Background color of an object.\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */backgroundColor:'',/**\n     * Selection Background color of an object. colored layer behind the object when it is active.\n     * does not mix good with globalCompositeOperation methods.\n     * @type String\n     * @default\n     */selectionBackgroundColor:'',/**\n     * When defined, an object is rendered via stroke and this property specifies its color\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */stroke:null,/**\n     * Width of a stroke used to render this object\n     * @type Number\n     * @default\n     */strokeWidth:1,/**\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\n     * @type Array\n     */strokeDashArray:null,/**\n     * Line offset of an object's stroke\n     * @type Number\n     * @default\n     */strokeDashOffset:0,/**\n     * Line endings style of an object's stroke (one of \"butt\", \"round\", \"square\")\n     * @type String\n     * @default\n     */strokeLineCap:'butt',/**\n     * Corner style of an object's stroke (one of \"bevel\", \"round\", \"miter\")\n     * @type String\n     * @default\n     */strokeLineJoin:'miter',/**\n     * Maximum miter length (used for strokeLineJoin = \"miter\") of an object's stroke\n     * @type Number\n     * @default\n     */strokeMiterLimit:4,/**\n     * Shadow object representing shadow of this shape\n     * @type fabric.Shadow\n     * @default\n     */shadow:null,/**\n     * Opacity of object's controlling borders when object is active and moving\n     * @type Number\n     * @default\n     */borderOpacityWhenMoving:0.4,/**\n     * Scale factor of object's controlling borders\n     * bigger number will make a thicker border\n     * border is 1, so this is basically a border thickness\n     * since there is no way to change the border itself.\n     * @type Number\n     * @default\n     */borderScaleFactor:1,/**\n     * Minimum allowed scale value of an object\n     * @type Number\n     * @default\n     */minScaleLimit:0,/**\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\n     * But events still fire on it.\n     * @type Boolean\n     * @default\n     */selectable:true,/**\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\n     * @type Boolean\n     * @default\n     */evented:true,/**\n     * When set to `false`, an object is not rendered on canvas\n     * @type Boolean\n     * @default\n     */visible:true,/**\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\n     * @type Boolean\n     * @default\n     */hasControls:true,/**\n     * When set to `false`, object's controlling borders are not rendered\n     * @type Boolean\n     * @default\n     */hasBorders:true,/**\n     * When set to `true`, objects are \"found\" on canvas on per-pixel basis rather than according to bounding box\n     * @type Boolean\n     * @default\n     */perPixelTargetFind:false,/**\n     * When `false`, default object's values are not included in its serialization\n     * @type Boolean\n     * @default\n     */includeDefaultValues:true,/**\n     * When `true`, object horizontal movement is locked\n     * @type Boolean\n     * @default\n     */lockMovementX:false,/**\n     * When `true`, object vertical movement is locked\n     * @type Boolean\n     * @default\n     */lockMovementY:false,/**\n     * When `true`, object rotation is locked\n     * @type Boolean\n     * @default\n     */lockRotation:false,/**\n     * When `true`, object horizontal scaling is locked\n     * @type Boolean\n     * @default\n     */lockScalingX:false,/**\n     * When `true`, object vertical scaling is locked\n     * @type Boolean\n     * @default\n     */lockScalingY:false,/**\n     * When `true`, object horizontal skewing is locked\n     * @type Boolean\n     * @default\n     */lockSkewingX:false,/**\n     * When `true`, object vertical skewing is locked\n     * @type Boolean\n     * @default\n     */lockSkewingY:false,/**\n     * When `true`, object cannot be flipped by scaling into negative values\n     * @type Boolean\n     * @default\n     */lockScalingFlip:false,/**\n     * When `true`, object is not exported in OBJECT/JSON\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */excludeFromExport:false,/**\n     * When `true`, object is cached on an additional canvas.\n     * When `false`, object is not cached unless necessary ( clipPath )\n     * default to true\n     * @since 1.7.0\n     * @type Boolean\n     * @default true\n     */objectCaching:objectCaching,/**\n     * When `true`, object properties are checked for cache invalidation. In some particular\n     * situation you may want this to be disabled ( spray brush, very big, groups)\n     * or if your application does not allow you to modify properties for groups child you want\n     * to disable it for groups.\n     * default to false\n     * since 1.7.0\n     * @type Boolean\n     * @default false\n     */statefullCache:false,/**\n     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled\n     * too much and will be redrawn with correct details at the end of scaling.\n     * this setting is performance and application dependant.\n     * default to true\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */noScaleCache:true,/**\n     * When `false`, the stoke width will scale with the object.\n     * When `true`, the stroke will always match the exact pixel size entered for stroke width.\n     * default to false\n     * @since 2.6.0\n     * @type Boolean\n     * @default false\n     * @type Boolean\n     * @default false\n     */strokeUniform:false,/**\n     * When set to `true`, object's cache will be rerendered next render call.\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */dirty:true,/**\n     * keeps the value of the last hovered corner during mouse move.\n     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..\n     * It should be private, but there is no harm in using it as\n     * a read-only property.\n     * @type number|string|any\n     * @default 0\n     */__corner:0,/**\n     * Determines if the fill or the stroke is drawn first (one of \"fill\" or \"stroke\")\n     * @type String\n     * @default\n     */paintFirst:'fill',/**\n     * When 'down', object is set to active on mousedown/touchstart\n     * When 'up', object is set to active on mouseup/touchend\n     * Experimental. Let's see if this breaks anything before supporting officially\n     * @private\n     * since 4.4.0\n     * @type String\n     * @default 'down'\n     */activeOn:'down',/**\n     * List of properties to consider when checking if state\n     * of an object is changed (fabric.Object#hasStateChanged)\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */stateProperties:('top left width height scaleX scaleY flipX flipY originX originY transformMatrix '+'stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit '+'angle opacity fill globalCompositeOperation shadow visible backgroundColor '+'skewX skewY fillRule paintFirst clipPath strokeUniform').split(' '),/**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */cacheProperties:('fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform'+' strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath').split(' '),/**\n     * List of properties to consider for animating colors.\n     * @type Array\n     */colorProperties:'fill stroke backgroundColor'.split(' '),/**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the object has rendered, and the context is placed in the center\n     * of the object cacheCanvas.\n     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'\n     * @type fabric.Object\n     */clipPath:undefined,/**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will make the object clip to the outside of the clipPath\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */inverted:false,/**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will have its top and left relative to canvas, and will\n     * not be influenced by the object transform. This will make the clipPath relative\n     * to the canvas, but clipping just a particular object.\n     * WARNING this is beta, this feature may change or be renamed.\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */absolutePositioned:false,/**\n     * Constructor\n     * @param {Object} [options] Options object\n     */initialize:function(options){if(options){this.setOptions(options);}},/**\n     * Create a the canvas used to keep the cached copy of the object\n     * @private\n     */_createCacheCanvas:function(){this._cacheProperties={};this._cacheCanvas=fabric.util.createCanvasElement();this._cacheContext=this._cacheCanvas.getContext('2d');this._updateCacheCanvas();// if canvas gets created, is empty, so dirty.\nthis.dirty=true;},/**\n     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal\n     * and each side do not cross fabric.cacheSideLimit\n     * those numbers are configurable so that you can get as much detail as you want\n     * making bargain with performances.\n     * @param {Object} dims\n     * @param {Object} dims.width width of canvas\n     * @param {Object} dims.height height of canvas\n     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */_limitCacheSize:function(dims){var perfLimitSizeTotal=fabric.perfLimitSizeTotal,width=dims.width,height=dims.height,max=fabric.maxCacheSideLimit,min=fabric.minCacheSideLimit;if(width<=max&&height<=max&&width*height<=perfLimitSizeTotal){if(width<min){dims.width=min;}if(height<min){dims.height=min;}return dims;}var ar=width/height,limitedDims=fabric.util.limitDimsByArea(ar,perfLimitSizeTotal),capValue=fabric.util.capValue,x=capValue(min,limitedDims.x,max),y=capValue(min,limitedDims.y,max);if(width>x){dims.zoomX/=width/x;dims.width=x;dims.capped=true;}if(height>y){dims.zoomY/=height/y;dims.height=y;dims.capped=true;}return dims;},/**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @return {Object}.x width of object to be cached\n     * @return {Object}.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */_getCacheCanvasDimensions:function(){var objectScale=this.getTotalObjectScaling(),// caculate dimensions without skewing\ndim=this._getTransformedDimensions(0,0),neededX=dim.x*objectScale.scaleX/this.scaleX,neededY=dim.y*objectScale.scaleY/this.scaleY;return{// for sure this ALIASING_LIMIT is slightly creating problem\n// in situation in which the cache canvas gets an upper limit\n// also objectScale contains already scaleX and scaleY\nwidth:neededX+ALIASING_LIMIT,height:neededY+ALIASING_LIMIT,zoomX:objectScale.scaleX,zoomY:objectScale.scaleY,x:neededX,y:neededY};},/**\n     * Update width and height of the canvas for cache\n     * returns true or false if canvas needed resize.\n     * @private\n     * @return {Boolean} true if the canvas has been resized\n     */_updateCacheCanvas:function(){var targetCanvas=this.canvas;if(this.noScaleCache&&targetCanvas&&targetCanvas._currentTransform){var target=targetCanvas._currentTransform.target,action=targetCanvas._currentTransform.action;if(this===target&&action.slice&&action.slice(0,5)==='scale'){return false;}}var canvas=this._cacheCanvas,dims=this._limitCacheSize(this._getCacheCanvasDimensions()),minCacheSize=fabric.minCacheSideLimit,width=dims.width,height=dims.height,drawingWidth,drawingHeight,zoomX=dims.zoomX,zoomY=dims.zoomY,dimensionsChanged=width!==this.cacheWidth||height!==this.cacheHeight,zoomChanged=this.zoomX!==zoomX||this.zoomY!==zoomY,shouldRedraw=dimensionsChanged||zoomChanged,additionalWidth=0,additionalHeight=0,shouldResizeCanvas=false;if(dimensionsChanged){var canvasWidth=this._cacheCanvas.width,canvasHeight=this._cacheCanvas.height,sizeGrowing=width>canvasWidth||height>canvasHeight,sizeShrinking=(width<canvasWidth*0.9||height<canvasHeight*0.9)&&canvasWidth>minCacheSize&&canvasHeight>minCacheSize;shouldResizeCanvas=sizeGrowing||sizeShrinking;if(sizeGrowing&&!dims.capped&&(width>minCacheSize||height>minCacheSize)){additionalWidth=width*0.1;additionalHeight=height*0.1;}}if(this instanceof fabric.Text&&this.path){shouldRedraw=true;shouldResizeCanvas=true;additionalWidth+=this.getHeightOfLine(0)*this.zoomX;additionalHeight+=this.getHeightOfLine(0)*this.zoomY;}if(shouldRedraw){if(shouldResizeCanvas){canvas.width=Math.ceil(width+additionalWidth);canvas.height=Math.ceil(height+additionalHeight);}else{this._cacheContext.setTransform(1,0,0,1,0,0);this._cacheContext.clearRect(0,0,canvas.width,canvas.height);}drawingWidth=dims.x/2;drawingHeight=dims.y/2;this.cacheTranslationX=Math.round(canvas.width/2-drawingWidth)+drawingWidth;this.cacheTranslationY=Math.round(canvas.height/2-drawingHeight)+drawingHeight;this.cacheWidth=width;this.cacheHeight=height;this._cacheContext.translate(this.cacheTranslationX,this.cacheTranslationY);this._cacheContext.scale(zoomX,zoomY);this.zoomX=zoomX;this.zoomY=zoomY;return true;}return false;},/**\n     * Sets object's properties from options\n     * @param {Object} [options] Options object\n     */setOptions:function(options){this._setOptions(options);this._initGradient(options.fill,'fill');this._initGradient(options.stroke,'stroke');this._initPattern(options.fill,'fill');this._initPattern(options.stroke,'stroke');},/**\n     * Transforms context when rendering an object\n     * @param {CanvasRenderingContext2D} ctx Context\n     */transform:function(ctx){var needFullTransform=this.group&&!this.group._transformDone||this.group&&this.canvas&&ctx===this.canvas.contextTop;var m=this.calcTransformMatrix(!needFullTransform);ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);},/**\n     * Returns an object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */toObject:function(propertiesToInclude){var NUM_FRACTION_DIGITS=fabric.Object.NUM_FRACTION_DIGITS,object={type:this.type,version:fabric.version,originX:this.originX,originY:this.originY,left:toFixed(this.left,NUM_FRACTION_DIGITS),top:toFixed(this.top,NUM_FRACTION_DIGITS),width:toFixed(this.width,NUM_FRACTION_DIGITS),height:toFixed(this.height,NUM_FRACTION_DIGITS),fill:this.fill&&this.fill.toObject?this.fill.toObject():this.fill,stroke:this.stroke&&this.stroke.toObject?this.stroke.toObject():this.stroke,strokeWidth:toFixed(this.strokeWidth,NUM_FRACTION_DIGITS),strokeDashArray:this.strokeDashArray?this.strokeDashArray.concat():this.strokeDashArray,strokeLineCap:this.strokeLineCap,strokeDashOffset:this.strokeDashOffset,strokeLineJoin:this.strokeLineJoin,strokeUniform:this.strokeUniform,strokeMiterLimit:toFixed(this.strokeMiterLimit,NUM_FRACTION_DIGITS),scaleX:toFixed(this.scaleX,NUM_FRACTION_DIGITS),scaleY:toFixed(this.scaleY,NUM_FRACTION_DIGITS),angle:toFixed(this.angle,NUM_FRACTION_DIGITS),flipX:this.flipX,flipY:this.flipY,opacity:toFixed(this.opacity,NUM_FRACTION_DIGITS),shadow:this.shadow&&this.shadow.toObject?this.shadow.toObject():this.shadow,visible:this.visible,backgroundColor:this.backgroundColor,fillRule:this.fillRule,paintFirst:this.paintFirst,globalCompositeOperation:this.globalCompositeOperation,skewX:toFixed(this.skewX,NUM_FRACTION_DIGITS),skewY:toFixed(this.skewY,NUM_FRACTION_DIGITS)};if(this.clipPath&&!this.clipPath.excludeFromExport){object.clipPath=this.clipPath.toObject(propertiesToInclude);object.clipPath.inverted=this.clipPath.inverted;object.clipPath.absolutePositioned=this.clipPath.absolutePositioned;}fabric.util.populateWithProperties(this,object,propertiesToInclude);if(!this.includeDefaultValues){object=this._removeDefaultValues(object);}return object;},/**\n     * Returns (dataless) object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */toDatalessObject:function(propertiesToInclude){// will be overwritten by subclasses\nreturn this.toObject(propertiesToInclude);},/**\n     * @private\n     * @param {Object} object\n     */_removeDefaultValues:function(object){var prototype=fabric.util.getKlass(object.type).prototype,stateProperties=prototype.stateProperties;stateProperties.forEach(function(prop){if(prop==='left'||prop==='top'){return;}if(object[prop]===prototype[prop]){delete object[prop];}var isArray=Object.prototype.toString.call(object[prop])==='[object Array]'&&Object.prototype.toString.call(prototype[prop])==='[object Array]';// basically a check for [] === []\nif(isArray&&object[prop].length===0&&prototype[prop].length===0){delete object[prop];}});return object;},/**\n     * Returns a string representation of an instance\n     * @return {String}\n     */toString:function(){return'#<fabric.'+capitalize(this.type)+'>';},/**\n     * Return the object scale factor counting also the group scaling\n     * @return {Object} object with scaleX and scaleY properties\n     */getObjectScaling:function(){// if the object is a top level one, on the canvas, we go for simple aritmetic\n// otherwise the complex method with angles will return approximations and decimals\n// and will likely kill the cache when not needed\n// https://github.com/fabricjs/fabric.js/issues/7157\nif(!this.group){return{scaleX:this.scaleX,scaleY:this.scaleY};}// if we are inside a group total zoom calculation is complex, we defer to generic matrices\nvar options=fabric.util.qrDecompose(this.calcTransformMatrix());return{scaleX:Math.abs(options.scaleX),scaleY:Math.abs(options.scaleY)};},/**\n     * Return the object scale factor counting also the group scaling, zoom and retina\n     * @return {Object} object with scaleX and scaleY properties\n     */getTotalObjectScaling:function(){var scale=this.getObjectScaling(),scaleX=scale.scaleX,scaleY=scale.scaleY;if(this.canvas){var zoom=this.canvas.getZoom();var retina=this.canvas.getRetinaScaling();scaleX*=zoom*retina;scaleY*=zoom*retina;}return{scaleX:scaleX,scaleY:scaleY};},/**\n     * Return the object opacity counting also the group property\n     * @return {Number}\n     */getObjectOpacity:function(){var opacity=this.opacity;if(this.group){opacity*=this.group.getObjectOpacity();}return opacity;},/**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Object} thisArg\n     */_set:function(key,value){var shouldConstrainValue=key==='scaleX'||key==='scaleY',isChanged=this[key]!==value,groupNeedsUpdate=false;if(shouldConstrainValue){value=this._constrainScale(value);}if(key==='scaleX'&&value<0){this.flipX=!this.flipX;value*=-1;}else if(key==='scaleY'&&value<0){this.flipY=!this.flipY;value*=-1;}else if(key==='shadow'&&value&&!(value instanceof fabric.Shadow)){value=new fabric.Shadow(value);}else if(key==='dirty'&&this.group){this.group.set('dirty',value);}this[key]=value;if(isChanged){groupNeedsUpdate=this.group&&this.group.isOnACache();if(this.cacheProperties.indexOf(key)>-1){this.dirty=true;groupNeedsUpdate&&this.group.set('dirty',true);}else if(groupNeedsUpdate&&this.stateProperties.indexOf(key)>-1){this.group.set('dirty',true);}}return this;},/**\n     * This callback function is called by the parent group of an object every\n     * time a non-delegated property changes on the group. It is passed the key\n     * and value as parameters. Not adding in this function's signature to avoid\n     * Travis build error about unused variables.\n     */setOnGroup:function(){// implemented by sub-classes, as needed.\n},/**\n     * Retrieves viewportTransform from Object's canvas if possible\n     * @method getViewportTransform\n     * @memberOf fabric.Object.prototype\n     * @return {Array}\n     */getViewportTransform:function(){if(this.canvas&&this.canvas.viewportTransform){return this.canvas.viewportTransform;}return fabric.iMatrix.concat();},/*\n     * @private\n     * return if the object would be visible in rendering\n     * @memberOf fabric.Object.prototype\n     * @return {Boolean}\n     */isNotVisible:function(){return this.opacity===0||!this.width&&!this.height&&this.strokeWidth===0||!this.visible;},/**\n     * Renders an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */render:function(ctx){// do not render if width/height are zeros or object is not visible\nif(this.isNotVisible()){return;}if(this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()){return;}ctx.save();this._setupCompositeOperation(ctx);this.drawSelectionBackground(ctx);this.transform(ctx);this._setOpacity(ctx);this._setShadow(ctx,this);if(this.shouldCache()){this.renderCache();this.drawCacheOnCanvas(ctx);}else{this._removeCacheCanvas();this.dirty=false;this.drawObject(ctx);if(this.objectCaching&&this.statefullCache){this.saveState({propertySet:'cacheProperties'});}}ctx.restore();},renderCache:function(options){options=options||{};if(!this._cacheCanvas){this._createCacheCanvas();}if(this.isCacheDirty()){this.statefullCache&&this.saveState({propertySet:'cacheProperties'});this.drawObject(this._cacheContext,options.forClipping);this.dirty=false;}},/**\n     * Remove cacheCanvas and its dimensions from the objects\n     */_removeCacheCanvas:function(){this._cacheCanvas=null;this.cacheWidth=0;this.cacheHeight=0;},/**\n     * return true if the object will draw a stroke\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when stroke happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the stroke is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */hasStroke:function(){return this.stroke&&this.stroke!=='transparent'&&this.strokeWidth!==0;},/**\n     * return true if the object will draw a fill\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when fill happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the fill is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */hasFill:function(){return this.fill&&this.fill!=='transparent';},/**\n     * When set to `true`, force the object to have its own cache, even if it is inside a group\n     * it may be needed when your object behave in a particular way on the cache and always needs\n     * its own isolated canvas to render correctly.\n     * Created to be overridden\n     * since 1.7.12\n     * @returns Boolean\n     */needsItsOwnCache:function(){if(this.paintFirst==='stroke'&&this.hasFill()&&this.hasStroke()&&typeof this.shadow==='object'){return true;}if(this.clipPath){return true;}return false;},/**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.\n     * @return {Boolean}\n     */shouldCache:function(){this.ownCaching=this.needsItsOwnCache()||this.objectCaching&&(!this.group||!this.group.isOnACache());return this.ownCaching;},/**\n     * Check if this object or a child object will cast a shadow\n     * used by Group.shouldCache to know if child has a shadow recursively\n     * @return {Boolean}\n     */willDrawShadow:function(){return!!this.shadow&&(this.shadow.offsetX!==0||this.shadow.offsetY!==0);},/**\n     * Execute the drawing operation for an object clipPath\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */drawClipPathOnCache:function(ctx){var path=this.clipPath;ctx.save();// DEBUG: uncomment this line, comment the following\n// ctx.globalAlpha = 0.4\nif(path.inverted){ctx.globalCompositeOperation='destination-out';}else{ctx.globalCompositeOperation='destination-in';}//ctx.scale(1 / 2, 1 / 2);\nif(path.absolutePositioned){var m=fabric.util.invertTransform(this.calcTransformMatrix());ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);}path.transform(ctx);ctx.scale(1/path.zoomX,1/path.zoomY);ctx.drawImage(path._cacheCanvas,-path.cacheTranslationX,-path.cacheTranslationY);ctx.restore();},/**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */drawObject:function(ctx,forClipping){var originalFill=this.fill,originalStroke=this.stroke;if(forClipping){this.fill='black';this.stroke='';this._setClippingProperties(ctx);}else{this._renderBackground(ctx);}this._render(ctx);this._drawClipPath(ctx);this.fill=originalFill;this.stroke=originalStroke;},_drawClipPath:function(ctx){var path=this.clipPath;if(!path){return;}// needed to setup a couple of variables\n// path canvas gets overridden with this one.\n// TODO find a better solution?\npath.canvas=this.canvas;path.shouldCache();path._transformDone=true;path.renderCache({forClipping:true});this.drawClipPathOnCache(ctx);},/**\n     * Paint the cached copy of the object on the target context.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */drawCacheOnCanvas:function(ctx){ctx.scale(1/this.zoomX,1/this.zoomY);ctx.drawImage(this._cacheCanvas,-this.cacheTranslationX,-this.cacheTranslationY);},/**\n     * Check if cache is dirty\n     * @param {Boolean} skipCanvas skip canvas checks because this object is painted\n     * on parent canvas.\n     */isCacheDirty:function(skipCanvas){if(this.isNotVisible()){return false;}if(this._cacheCanvas&&!skipCanvas&&this._updateCacheCanvas()){// in this case the context is already cleared.\nreturn true;}else{if(this.dirty||this.clipPath&&this.clipPath.absolutePositioned||this.statefullCache&&this.hasStateChanged('cacheProperties')){if(this._cacheCanvas&&!skipCanvas){var width=this.cacheWidth/this.zoomX;var height=this.cacheHeight/this.zoomY;this._cacheContext.clearRect(-width/2,-height/2,width,height);}return true;}}return false;},/**\n     * Draws a background for the object big as its untransformed dimensions\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderBackground:function(ctx){if(!this.backgroundColor){return;}var dim=this._getNonTransformedDimensions();ctx.fillStyle=this.backgroundColor;ctx.fillRect(-dim.x/2,-dim.y/2,dim.x,dim.y);// if there is background color no other shadows\n// should be casted\nthis._removeShadow(ctx);},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_setOpacity:function(ctx){if(this.group&&!this.group._transformDone){ctx.globalAlpha=this.getObjectOpacity();}else{ctx.globalAlpha*=this.opacity;}},_setStrokeStyles:function(ctx,decl){var stroke=decl.stroke;if(stroke){ctx.lineWidth=decl.strokeWidth;ctx.lineCap=decl.strokeLineCap;ctx.lineDashOffset=decl.strokeDashOffset;ctx.lineJoin=decl.strokeLineJoin;ctx.miterLimit=decl.strokeMiterLimit;if(stroke.toLive){if(stroke.gradientUnits==='percentage'||stroke.gradientTransform||stroke.patternTransform){// need to transform gradient in a pattern.\n// this is a slow process. If you are hitting this codepath, and the object\n// is not using caching, you should consider switching it on.\n// we need a canvas as big as the current object caching canvas.\nthis._applyPatternForTransformedGradient(ctx,stroke);}else{// is a simple gradient or pattern\nctx.strokeStyle=stroke.toLive(ctx,this);this._applyPatternGradientTransform(ctx,stroke);}}else{// is a color\nctx.strokeStyle=decl.stroke;}}},_setFillStyles:function(ctx,decl){var fill=decl.fill;if(fill){if(fill.toLive){ctx.fillStyle=fill.toLive(ctx,this);this._applyPatternGradientTransform(ctx,decl.fill);}else{ctx.fillStyle=fill;}}},_setClippingProperties:function(ctx){ctx.globalAlpha=1;ctx.strokeStyle='transparent';ctx.fillStyle='#000000';},/**\n     * @private\n     * Sets line dash\n     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on\n     * @param {Array} dashArray array representing dashes\n     */_setLineDash:function(ctx,dashArray){if(!dashArray||dashArray.length===0){return;}// Spec requires the concatenation of two copies the dash list when the number of elements is odd\nif(1&dashArray.length){dashArray.push.apply(dashArray,dashArray);}ctx.setLineDash(dashArray);},/**\n     * Renders controls and borders for the object\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     */_renderControls:function(ctx,styleOverride){var vpt=this.getViewportTransform(),matrix=this.calcTransformMatrix(),options,drawBorders,drawControls;styleOverride=styleOverride||{};drawBorders=typeof styleOverride.hasBorders!=='undefined'?styleOverride.hasBorders:this.hasBorders;drawControls=typeof styleOverride.hasControls!=='undefined'?styleOverride.hasControls:this.hasControls;matrix=fabric.util.multiplyTransformMatrices(vpt,matrix);options=fabric.util.qrDecompose(matrix);ctx.save();ctx.translate(options.translateX,options.translateY);ctx.lineWidth=1*this.borderScaleFactor;if(!this.group){ctx.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1;}ctx.rotate(degreesToRadians(options.angle));if(styleOverride.forActiveSelection||this.group){drawBorders&&this.drawBordersInGroup(ctx,options,styleOverride);}else{drawBorders&&this.drawBorders(ctx,styleOverride);}drawControls&&this.drawControls(ctx,styleOverride);ctx.restore();},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_setShadow:function(ctx){if(!this.shadow){return;}var shadow=this.shadow,canvas=this.canvas,scaling,multX=canvas&&canvas.viewportTransform[0]||1,multY=canvas&&canvas.viewportTransform[3]||1;if(shadow.nonScaling){scaling={scaleX:1,scaleY:1};}else{scaling=this.getObjectScaling();}if(canvas&&canvas._isRetinaScaling()){multX*=fabric.devicePixelRatio;multY*=fabric.devicePixelRatio;}ctx.shadowColor=shadow.color;ctx.shadowBlur=shadow.blur*fabric.browserShadowBlurConstant*(multX+multY)*(scaling.scaleX+scaling.scaleY)/4;ctx.shadowOffsetX=shadow.offsetX*multX*scaling.scaleX;ctx.shadowOffsetY=shadow.offsetY*multY*scaling.scaleY;},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_removeShadow:function(ctx){if(!this.shadow){return;}ctx.shadowColor='';ctx.shadowBlur=ctx.shadowOffsetX=ctx.shadowOffsetY=0;},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} filler fabric.Pattern or fabric.Gradient\n     * @return {Object} offset.offsetX offset for text rendering\n     * @return {Object} offset.offsetY offset for text rendering\n     */_applyPatternGradientTransform:function(ctx,filler){if(!filler||!filler.toLive){return{offsetX:0,offsetY:0};}var t=filler.gradientTransform||filler.patternTransform;var offsetX=-this.width/2+filler.offsetX||0,offsetY=-this.height/2+filler.offsetY||0;if(filler.gradientUnits==='percentage'){ctx.transform(this.width,0,0,this.height,offsetX,offsetY);}else{ctx.transform(1,0,0,1,offsetX,offsetY);}if(t){ctx.transform(t[0],t[1],t[2],t[3],t[4],t[5]);}return{offsetX:offsetX,offsetY:offsetY};},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderPaintInOrder:function(ctx){if(this.paintFirst==='stroke'){this._renderStroke(ctx);this._renderFill(ctx);}else{this._renderFill(ctx);this._renderStroke(ctx);}},/**\n     * @private\n     * function that actually render something on the context.\n     * empty here to allow Obects to work on tests to benchmark fabric functionalites\n     * not related to rendering\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function/* ctx */(){},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderFill:function(ctx){if(!this.fill){return;}ctx.save();this._setFillStyles(ctx,this);if(this.fillRule==='evenodd'){ctx.fill('evenodd');}else{ctx.fill();}ctx.restore();},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderStroke:function(ctx){if(!this.stroke||this.strokeWidth===0){return;}if(this.shadow&&!this.shadow.affectStroke){this._removeShadow(ctx);}ctx.save();if(this.strokeUniform&&this.group){var scaling=this.getObjectScaling();ctx.scale(1/scaling.scaleX,1/scaling.scaleY);}else if(this.strokeUniform){ctx.scale(1/this.scaleX,1/this.scaleY);}this._setLineDash(ctx,this.strokeDashArray);this._setStrokeStyles(ctx,this);ctx.stroke();ctx.restore();},/**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     */_applyPatternForTransformedGradient:function(ctx,filler){var dims=this._limitCacheSize(this._getCacheCanvasDimensions()),pCanvas=fabric.util.createCanvasElement(),pCtx,retinaScaling=this.canvas.getRetinaScaling(),width=dims.x/this.scaleX/retinaScaling,height=dims.y/this.scaleY/retinaScaling;pCanvas.width=width;pCanvas.height=height;pCtx=pCanvas.getContext('2d');pCtx.beginPath();pCtx.moveTo(0,0);pCtx.lineTo(width,0);pCtx.lineTo(width,height);pCtx.lineTo(0,height);pCtx.closePath();pCtx.translate(width/2,height/2);pCtx.scale(dims.zoomX/this.scaleX/retinaScaling,dims.zoomY/this.scaleY/retinaScaling);this._applyPatternGradientTransform(pCtx,filler);pCtx.fillStyle=filler.toLive(ctx);pCtx.fill();ctx.translate(-this.width/2-this.strokeWidth/2,-this.height/2-this.strokeWidth/2);ctx.scale(retinaScaling*this.scaleX/dims.zoomX,retinaScaling*this.scaleY/dims.zoomY);ctx.strokeStyle=pCtx.createPattern(pCanvas,'no-repeat');},/**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */_findCenterFromElement:function(){return{x:this.left+this.width/2,y:this.top+this.height/2};},/**\n     * This function is an helper for svg import. it decompose the transformMatrix\n     * and assign properties to object.\n     * untransformed coordinates\n     * @private\n     * @chainable\n     */_assignTransformMatrixProps:function(){if(this.transformMatrix){var options=fabric.util.qrDecompose(this.transformMatrix);this.flipX=false;this.flipY=false;this.set('scaleX',options.scaleX);this.set('scaleY',options.scaleY);this.angle=options.angle;this.skewX=options.skewX;this.skewY=0;}},/**\n     * This function is an helper for svg import. it removes the transform matrix\n     * and set to object properties that fabricjs can handle\n     * @private\n     * @param {Object} preserveAspectRatioOptions\n     * @return {thisArg}\n     */_removeTransformMatrix:function(preserveAspectRatioOptions){var center=this._findCenterFromElement();if(this.transformMatrix){this._assignTransformMatrixProps();center=fabric.util.transformPoint(center,this.transformMatrix);}this.transformMatrix=null;if(preserveAspectRatioOptions){this.scaleX*=preserveAspectRatioOptions.scaleX;this.scaleY*=preserveAspectRatioOptions.scaleY;this.cropX=preserveAspectRatioOptions.cropX;this.cropY=preserveAspectRatioOptions.cropY;center.x+=preserveAspectRatioOptions.offsetLeft;center.y+=preserveAspectRatioOptions.offsetTop;this.width=preserveAspectRatioOptions.width;this.height=preserveAspectRatioOptions.height;}this.setPositionByOrigin(center,'center','center');},/**\n     * Clones an instance, using a callback method will work for every object.\n     * @param {Function} callback Callback is invoked with a clone as a first argument\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     */clone:function(callback,propertiesToInclude){var objectForm=this.toObject(propertiesToInclude);if(this.constructor.fromObject){this.constructor.fromObject(objectForm,callback);}else{fabric.Object._fromObject('Object',objectForm,callback);}},/**\n     * Creates an instance of fabric.Image out of an object\n     * makes use of toCanvasElement.\n     * Once this method was based on toDataUrl and loadImage, so it also had a quality\n     * and format option. toCanvasElement is faster and produce no loss of quality.\n     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.\n     * toCanvasElement and then toBlob from the obtained canvas is also a good option.\n     * This method is sync now, but still support the callback because we did not want to break.\n     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.\n     * @param {Function} callback callback, invoked with an instance as a first argument\n     * @param {Object} [options] for clone as image, passed to toDataURL\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {fabric.Object} thisArg\n     */cloneAsImage:function(callback,options){var canvasEl=this.toCanvasElement(options);if(callback){callback(new fabric.Image(canvasEl));}return this;},/**\n     * Converts an object into a HTMLCanvas element\n     * @param {Object} options Options object\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object\n     */toCanvasElement:function(options){options||(options={});var utils=fabric.util,origParams=utils.saveObjectTransform(this),originalGroup=this.group,originalShadow=this.shadow,abs=Math.abs,multiplier=(options.multiplier||1)*(options.enableRetinaScaling?fabric.devicePixelRatio:1);delete this.group;if(options.withoutTransform){utils.resetObjectTransform(this);}if(options.withoutShadow){this.shadow=null;}var el=fabric.util.createCanvasElement(),// skip canvas zoom and calculate with setCoords now.\nboundingRect=this.getBoundingRect(true,true),shadow=this.shadow,scaling,shadowOffset={x:0,y:0},shadowBlur,width,height;if(shadow){shadowBlur=shadow.blur;if(shadow.nonScaling){scaling={scaleX:1,scaleY:1};}else{scaling=this.getObjectScaling();}// consider non scaling shadow.\nshadowOffset.x=2*Math.round(abs(shadow.offsetX)+shadowBlur)*abs(scaling.scaleX);shadowOffset.y=2*Math.round(abs(shadow.offsetY)+shadowBlur)*abs(scaling.scaleY);}width=boundingRect.width+shadowOffset.x;height=boundingRect.height+shadowOffset.y;// if the current width/height is not an integer\n// we need to make it so.\nel.width=Math.ceil(width);el.height=Math.ceil(height);var canvas=new fabric.StaticCanvas(el,{enableRetinaScaling:false,renderOnAddRemove:false,skipOffscreen:false});if(options.format==='jpeg'){canvas.backgroundColor='#fff';}this.setPositionByOrigin(new fabric.Point(canvas.width/2,canvas.height/2),'center','center');var originalCanvas=this.canvas;canvas.add(this);var canvasEl=canvas.toCanvasElement(multiplier||1,options);this.shadow=originalShadow;this.set('canvas',originalCanvas);if(originalGroup){this.group=originalGroup;}this.set(origParams).setCoords();// canvas.dispose will call image.dispose that will nullify the elements\n// since this canvas is a simple element for the process, we remove references\n// to objects in this way in order to avoid object trashing.\ncanvas._objects=[];canvas.dispose();canvas=null;return canvasEl;},/**\n     * Converts an object into a data-url-like string\n     * @param {Object} options Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     */toDataURL:function(options){options||(options={});return fabric.util.toDataURL(this.toCanvasElement(options),options.format||'png',options.quality||1);},/**\n     * Returns true if specified type is identical to the type of an instance\n     * @param {String} type Type to check against\n     * @return {Boolean}\n     */isType:function(type){return this.type===type;},/**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance (is 1 unless subclassed)\n     */complexity:function(){return 1;},/**\n     * Returns a JSON representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} JSON\n     */toJSON:function(propertiesToInclude){// delegate, not alias\nreturn this.toObject(propertiesToInclude);},/**\n     * Sets \"angle\" of an instance with centered rotation\n     * @param {Number} angle Angle value (in degrees)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */rotate:function(angle){var shouldCenterOrigin=(this.originX!=='center'||this.originY!=='center')&&this.centeredRotation;if(shouldCenterOrigin){this._setOriginToCenter();}this.set('angle',angle);if(shouldCenterOrigin){this._resetOrigin();}return this;},/**\n     * Centers object horizontally on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */centerH:function(){this.canvas&&this.canvas.centerObjectH(this);return this;},/**\n     * Centers object horizontally on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */viewportCenterH:function(){this.canvas&&this.canvas.viewportCenterObjectH(this);return this;},/**\n     * Centers object vertically on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */centerV:function(){this.canvas&&this.canvas.centerObjectV(this);return this;},/**\n     * Centers object vertically on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */viewportCenterV:function(){this.canvas&&this.canvas.viewportCenterObjectV(this);return this;},/**\n     * Centers object vertically and horizontally on canvas to which is was added last\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */center:function(){this.canvas&&this.canvas.centerObject(this);return this;},/**\n     * Centers object on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */viewportCenter:function(){this.canvas&&this.canvas.viewportCenterObject(this);return this;},/**\n     * Returns coordinates of a pointer relative to an object\n     * @param {Event} e Event to operate upon\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\n     * @return {Object} Coordinates of a pointer (x, y)\n     */getLocalPointer:function(e,pointer){pointer=pointer||this.canvas.getPointer(e);var pClicked=new fabric.Point(pointer.x,pointer.y),objectLeftTop=this._getLeftTopCoords();if(this.angle){pClicked=fabric.util.rotatePoint(pClicked,objectLeftTop,degreesToRadians(-this.angle));}return{x:pClicked.x-objectLeftTop.x,y:pClicked.y-objectLeftTop.y};},/**\n     * Sets canvas globalCompositeOperation for specific object\n     * custom composition operation for the particular object can be specified using globalCompositeOperation property\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\n     */_setupCompositeOperation:function(ctx){if(this.globalCompositeOperation){ctx.globalCompositeOperation=this.globalCompositeOperation;}}});fabric.util.createAccessors&&fabric.util.createAccessors(fabric.Object);extend(fabric.Object.prototype,fabric.Observable);/**\n   * Defines the number of fraction digits to use when serializing object values.\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type Number\n   */fabric.Object.NUM_FRACTION_DIGITS=2;fabric.Object._fromObject=function(className,object,callback,extraParam){var klass=fabric[className];object=clone(object,true);fabric.util.enlivenPatterns([object.fill,object.stroke],function(patterns){if(typeof patterns[0]!=='undefined'){object.fill=patterns[0];}if(typeof patterns[1]!=='undefined'){object.stroke=patterns[1];}fabric.util.enlivenObjects([object.clipPath],function(enlivedProps){object.clipPath=enlivedProps[0];var instance=extraParam?new klass(object[extraParam],object):new klass(object);callback&&callback(instance);});});};/**\n   * Unique id used internally when creating SVG elements\n   * @static\n   * @memberOf fabric.Object\n   * @type Number\n   */fabric.Object.__uid=0;})( true?exports:0);(function(){var degreesToRadians=fabric.util.degreesToRadians,originXOffset={left:-0.5,center:0,right:0.5},originYOffset={top:-0.5,center:0,bottom:0.5};fabric.util.object.extend(fabric.Object.prototype,/** @lends fabric.Object.prototype */{/**\n     * Translates the coordinates from a set of origin to another (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */translateToGivenOrigin:function(point,fromOriginX,fromOriginY,toOriginX,toOriginY){var x=point.x,y=point.y,offsetX,offsetY,dim;if(typeof fromOriginX==='string'){fromOriginX=originXOffset[fromOriginX];}else{fromOriginX-=0.5;}if(typeof toOriginX==='string'){toOriginX=originXOffset[toOriginX];}else{toOriginX-=0.5;}offsetX=toOriginX-fromOriginX;if(typeof fromOriginY==='string'){fromOriginY=originYOffset[fromOriginY];}else{fromOriginY-=0.5;}if(typeof toOriginY==='string'){toOriginY=originYOffset[toOriginY];}else{toOriginY-=0.5;}offsetY=toOriginY-fromOriginY;if(offsetX||offsetY){dim=this._getTransformedDimensions();x=point.x+offsetX*dim.x;y=point.y+offsetY*dim.y;}return new fabric.Point(x,y);},/**\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */translateToCenterPoint:function(point,originX,originY){var p=this.translateToGivenOrigin(point,originX,originY,'center','center');if(this.angle){return fabric.util.rotatePoint(p,point,degreesToRadians(this.angle));}return p;},/**\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\n     * @param {fabric.Point} center The point which corresponds to center of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */translateToOriginPoint:function(center,originX,originY){var p=this.translateToGivenOrigin(center,'center','center',originX,originY);if(this.angle){return fabric.util.rotatePoint(p,center,degreesToRadians(this.angle));}return p;},/**\n     * Returns the real center coordinates of the object\n     * @return {fabric.Point}\n     */getCenterPoint:function(){var leftTop=new fabric.Point(this.left,this.top);return this.translateToCenterPoint(leftTop,this.originX,this.originY);},/**\n     * Returns the coordinates of the object based on center coordinates\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @return {fabric.Point}\n     */ // getOriginPoint: function(center) {\n//   return this.translateToOriginPoint(center, this.originX, this.originY);\n// },\n/**\n     * Returns the coordinates of the object as if it has a different origin\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */getPointByOrigin:function(originX,originY){var center=this.getCenterPoint();return this.translateToOriginPoint(center,originX,originY);},/**\n     * Returns the point in local coordinates\n     * @param {fabric.Point} point The point relative to the global coordinate system\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */toLocalPoint:function(point,originX,originY){var center=this.getCenterPoint(),p,p2;if(typeof originX!=='undefined'&&typeof originY!=='undefined'){p=this.translateToGivenOrigin(center,'center','center',originX,originY);}else{p=new fabric.Point(this.left,this.top);}p2=new fabric.Point(point.x,point.y);if(this.angle){p2=fabric.util.rotatePoint(p2,center,-degreesToRadians(this.angle));}return p2.subtractEquals(p);},/**\n     * Returns the point in global coordinates\n     * @param {fabric.Point} The point relative to the local coordinate system\n     * @return {fabric.Point}\n     */ // toGlobalPoint: function(point) {\n//   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\n// },\n/**\n     * Sets the position of the object taking into consideration the object's origin\n     * @param {fabric.Point} pos The new position of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {void}\n     */setPositionByOrigin:function(pos,originX,originY){var center=this.translateToCenterPoint(pos,originX,originY),position=this.translateToOriginPoint(center,this.originX,this.originY);this.set('left',position.x);this.set('top',position.y);},/**\n     * @param {String} to One of 'left', 'center', 'right'\n     */adjustPosition:function(to){var angle=degreesToRadians(this.angle),hypotFull=this.getScaledWidth(),xFull=fabric.util.cos(angle)*hypotFull,yFull=fabric.util.sin(angle)*hypotFull,offsetFrom,offsetTo;//TODO: this function does not consider mixed situation like top, center.\nif(typeof this.originX==='string'){offsetFrom=originXOffset[this.originX];}else{offsetFrom=this.originX-0.5;}if(typeof to==='string'){offsetTo=originXOffset[to];}else{offsetTo=to-0.5;}this.left+=xFull*(offsetTo-offsetFrom);this.top+=yFull*(offsetTo-offsetFrom);this.setCoords();this.originX=to;},/**\n     * Sets the origin/position of the object to it's center point\n     * @private\n     * @return {void}\n     */_setOriginToCenter:function(){this._originalOriginX=this.originX;this._originalOriginY=this.originY;var center=this.getCenterPoint();this.originX='center';this.originY='center';this.left=center.x;this.top=center.y;},/**\n     * Resets the origin/position of the object to it's original origin\n     * @private\n     * @return {void}\n     */_resetOrigin:function(){var originPoint=this.translateToOriginPoint(this.getCenterPoint(),this._originalOriginX,this._originalOriginY);this.originX=this._originalOriginX;this.originY=this._originalOriginY;this.left=originPoint.x;this.top=originPoint.y;this._originalOriginX=null;this._originalOriginY=null;},/**\n     * @private\n     */_getLeftTopCoords:function(){return this.translateToOriginPoint(this.getCenterPoint(),'left','top');}});})();(function(){function arrayFromCoords(coords){return[new fabric.Point(coords.tl.x,coords.tl.y),new fabric.Point(coords.tr.x,coords.tr.y),new fabric.Point(coords.br.x,coords.br.y),new fabric.Point(coords.bl.x,coords.bl.y)];}var util=fabric.util,degreesToRadians=util.degreesToRadians,multiplyMatrices=util.multiplyTransformMatrices,transformPoint=util.transformPoint;util.object.extend(fabric.Object.prototype,/** @lends fabric.Object.prototype */{/**\n     * Describe object's corner position in canvas element coordinates.\n     * properties are depending on control keys and padding the main controls.\n     * each property is an object with x, y and corner.\n     * The `corner` property contains in a similar manner the 4 points of the\n     * interactive area of the corner.\n     * The coordinates depends from the controls positionHandler and are used\n     * to draw and locate controls\n     * @memberOf fabric.Object.prototype\n     */oCoords:null,/**\n     * Describe object's corner position in canvas object absolute coordinates\n     * properties are tl,tr,bl,br and describe the four main corner.\n     * each property is an object with x, y, instance of Fabric.Point.\n     * The coordinates depends from this properties: width, height, scaleX, scaleY\n     * skewX, skewY, angle, strokeWidth, top, left.\n     * Those coordinates are useful to understand where an object is. They get updated\n     * with oCoords but they do not need to be updated when zoom or panning change.\n     * The coordinates get updated with @method setCoords.\n     * You can calculate them without updating with @method calcACoords();\n     * @memberOf fabric.Object.prototype\n     */aCoords:null,/**\n     * Describe object's corner position in canvas element coordinates.\n     * includes padding. Used of object detection.\n     * set and refreshed with setCoords and calcCoords.\n     * @memberOf fabric.Object.prototype\n     */lineCoords:null,/**\n     * storage for object transform matrix\n     */ownMatrixCache:null,/**\n     * storage for object full transform matrix\n     */matrixCache:null,/**\n     * custom controls interface\n     * controls are added by default_controls.js\n     */controls:{},/**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * @param {Boolean} absolute will return aCoords if true or lineCoords\n     * @return {Object} {tl, tr, br, bl} points\n     */_getCoords:function(absolute,calculate){if(calculate){return absolute?this.calcACoords():this.calcLineCoords();}if(!this.aCoords||!this.lineCoords){this.setCoords(true);}return absolute?this.aCoords:this.lineCoords;},/**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * The coords are returned in an array.\n     * @return {Array} [tl, tr, br, bl] of points\n     */getCoords:function(absolute,calculate){return arrayFromCoords(this._getCoords(absolute,calculate));},/**\n     * Checks if object intersects with an area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with an area formed by 2 points\n     */intersectsWithRect:function(pointTL,pointBR,absolute,calculate){var coords=this.getCoords(absolute,calculate),intersection=fabric.Intersection.intersectPolygonRectangle(coords,pointTL,pointBR);return intersection.status==='Intersection';},/**\n     * Checks if object intersects with another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with another object\n     */intersectsWithObject:function(other,absolute,calculate){var intersection=fabric.Intersection.intersectPolygonPolygon(this.getCoords(absolute,calculate),other.getCoords(absolute,calculate));return intersection.status==='Intersection'||other.isContainedWithinObject(this,absolute,calculate)||this.isContainedWithinObject(other,absolute,calculate);},/**\n     * Checks if object is fully contained within area of another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area of another object\n     */isContainedWithinObject:function(other,absolute,calculate){var points=this.getCoords(absolute,calculate),otherCoords=absolute?other.aCoords:other.lineCoords,i=0,lines=other._getImageLines(otherCoords);for(;i<4;i++){if(!other.containsPoint(points[i],lines)){return false;}}return true;},/**\n     * Checks if object is fully contained within area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\n     */isContainedWithinRect:function(pointTL,pointBR,absolute,calculate){var boundingRect=this.getBoundingRect(absolute,calculate);return boundingRect.left>=pointTL.x&&boundingRect.left+boundingRect.width<=pointBR.x&&boundingRect.top>=pointTL.y&&boundingRect.top+boundingRect.height<=pointBR.y;},/**\n     * Checks if point is inside the object\n     * @param {fabric.Point} point Point to check against\n     * @param {Object} [lines] object returned from @method _getImageLines\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if point is inside the object\n     */containsPoint:function(point,lines,absolute,calculate){var coords=this._getCoords(absolute,calculate),lines=lines||this._getImageLines(coords),xPoints=this._findCrossPoints(point,lines);// if xPoints is odd then point is inside the object\nreturn xPoints!==0&&xPoints%2===1;},/**\n     * Checks if object is contained within the canvas with current viewportTransform\n     * the check is done stopping at first point that appears on screen\n     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords\n     * @return {Boolean} true if object is fully or partially contained within canvas\n     */isOnScreen:function(calculate){if(!this.canvas){return false;}var pointTL=this.canvas.vptCoords.tl,pointBR=this.canvas.vptCoords.br;var points=this.getCoords(true,calculate);// if some point is on screen, the object is on screen.\nif(points.some(function(point){return point.x<=pointBR.x&&point.x>=pointTL.x&&point.y<=pointBR.y&&point.y>=pointTL.y;})){return true;}// no points on screen, check intersection with absolute coordinates\nif(this.intersectsWithRect(pointTL,pointBR,true,calculate)){return true;}return this._containsCenterOfCanvas(pointTL,pointBR,calculate);},/**\n     * Checks if the object contains the midpoint between canvas extremities\n     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen\n     * @private\n     * @param {Fabric.Point} pointTL Top Left point\n     * @param {Fabric.Point} pointBR Top Right point\n     * @param {Boolean} calculate use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if the object contains the point\n     */_containsCenterOfCanvas:function(pointTL,pointBR,calculate){// worst case scenario the object is so big that contains the screen\nvar centerPoint={x:(pointTL.x+pointBR.x)/2,y:(pointTL.y+pointBR.y)/2};if(this.containsPoint(centerPoint,null,true,calculate)){return true;}return false;},/**\n     * Checks if object is partially contained within the canvas with current viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is partially contained within canvas\n     */isPartiallyOnScreen:function(calculate){if(!this.canvas){return false;}var pointTL=this.canvas.vptCoords.tl,pointBR=this.canvas.vptCoords.br;if(this.intersectsWithRect(pointTL,pointBR,true,calculate)){return true;}var allPointsAreOutside=this.getCoords(true,calculate).every(function(point){return(point.x>=pointBR.x||point.x<=pointTL.x)&&(point.y>=pointBR.y||point.y<=pointTL.y);});return allPointsAreOutside&&this._containsCenterOfCanvas(pointTL,pointBR,calculate);},/**\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\n     * @private\n     * @param {Object} oCoords Coordinates of the object corners\n     */_getImageLines:function(oCoords){var lines={topline:{o:oCoords.tl,d:oCoords.tr},rightline:{o:oCoords.tr,d:oCoords.br},bottomline:{o:oCoords.br,d:oCoords.bl},leftline:{o:oCoords.bl,d:oCoords.tl}};// // debugging\n// if (this.canvas.contextTop) {\n//   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n//   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n//\n//   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n//   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n//\n//   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n//   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n//\n//   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n//   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n// }\nreturn lines;},/**\n     * Helper method to determine how many cross points are between the 4 object edges\n     * and the horizontal line determined by a point on canvas\n     * @private\n     * @param {fabric.Point} point Point to check\n     * @param {Object} lines Coordinates of the object being evaluated\n     */ // remove yi, not used but left code here just in case.\n_findCrossPoints:function(point,lines){var b1,b2,a1,a2,xi,// yi,\nxcount=0,iLine;for(var lineKey in lines){iLine=lines[lineKey];// optimisation 1: line below point. no cross\nif(iLine.o.y<point.y&&iLine.d.y<point.y){continue;}// optimisation 2: line above point. no cross\nif(iLine.o.y>=point.y&&iLine.d.y>=point.y){continue;}// optimisation 3: vertical line case\nif(iLine.o.x===iLine.d.x&&iLine.o.x>=point.x){xi=iLine.o.x;// yi = point.y;\n}// calculate the intersection point\nelse{b1=0;b2=(iLine.d.y-iLine.o.y)/(iLine.d.x-iLine.o.x);a1=point.y-b1*point.x;a2=iLine.o.y-b2*iLine.o.x;xi=-(a1-a2)/(b1-b2);// yi = a1 + b1 * xi;\n}// dont count xi < point.x cases\nif(xi>=point.x){xcount+=1;}// optimisation 4: specific for square images\nif(xcount===2){break;}}return xcount;},/**\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\n     * the box is intended as aligned to axis of canvas.\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords\n     * @return {Object} Object with left, top, width, height properties\n     */getBoundingRect:function(absolute,calculate){var coords=this.getCoords(absolute,calculate);return util.makeBoundingBoxFromPoints(coords);},/**\n     * Returns width of an object's bounding box counting transformations\n     * before 2.0 it was named getWidth();\n     * @return {Number} width value\n     */getScaledWidth:function(){return this._getTransformedDimensions().x;},/**\n     * Returns height of an object bounding box counting transformations\n     * before 2.0 it was named getHeight();\n     * @return {Number} height value\n     */getScaledHeight:function(){return this._getTransformedDimensions().y;},/**\n     * Makes sure the scale is valid and modifies it if necessary\n     * @private\n     * @param {Number} value\n     * @return {Number}\n     */_constrainScale:function(value){if(Math.abs(value)<this.minScaleLimit){if(value<0){return-this.minScaleLimit;}else{return this.minScaleLimit;}}else if(value===0){return 0.0001;}return value;},/**\n     * Scales an object (equally by x and y)\n     * @param {Number} value Scale factor\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */scale:function(value){this._set('scaleX',value);this._set('scaleY',value);return this.setCoords();},/**\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New width value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */scaleToWidth:function(value,absolute){// adjust to bounding rect factor so that rotated shapes would fit as well\nvar boundingRectFactor=this.getBoundingRect(absolute).width/this.getScaledWidth();return this.scale(value/this.width/boundingRectFactor);},/**\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New height value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */scaleToHeight:function(value,absolute){// adjust to bounding rect factor so that rotated shapes would fit as well\nvar boundingRectFactor=this.getBoundingRect(absolute).height/this.getScaledHeight();return this.scale(value/this.height/boundingRectFactor);},/**\n     * Calculates and returns the .coords of an object.\n     * unused by the library, only for the end dev.\n     * @return {Object} Object with tl, tr, br, bl ....\n     * @chainable\n     * @deprecated\n     */calcCoords:function(absolute){// this is a compatibility function to avoid removing calcCoords now.\nif(absolute){return this.calcACoords();}return this.calcOCoords();},calcLineCoords:function(){var vpt=this.getViewportTransform(),padding=this.padding,angle=degreesToRadians(this.angle),cos=util.cos(angle),sin=util.sin(angle),cosP=cos*padding,sinP=sin*padding,cosPSinP=cosP+sinP,cosPMinusSinP=cosP-sinP,aCoords=this.calcACoords();var lineCoords={tl:transformPoint(aCoords.tl,vpt),tr:transformPoint(aCoords.tr,vpt),bl:transformPoint(aCoords.bl,vpt),br:transformPoint(aCoords.br,vpt)};if(padding){lineCoords.tl.x-=cosPMinusSinP;lineCoords.tl.y-=cosPSinP;lineCoords.tr.x+=cosPSinP;lineCoords.tr.y-=cosPMinusSinP;lineCoords.bl.x-=cosPSinP;lineCoords.bl.y+=cosPMinusSinP;lineCoords.br.x+=cosPMinusSinP;lineCoords.br.y+=cosPSinP;}return lineCoords;},calcOCoords:function(){var rotateMatrix=this._calcRotateMatrix(),translateMatrix=this._calcTranslateMatrix(),vpt=this.getViewportTransform(),startMatrix=multiplyMatrices(vpt,translateMatrix),finalMatrix=multiplyMatrices(startMatrix,rotateMatrix),finalMatrix=multiplyMatrices(finalMatrix,[1/vpt[0],0,0,1/vpt[3],0,0]),dim=this._calculateCurrentDimensions(),coords={};this.forEachControl(function(control,key,fabricObject){coords[key]=control.positionHandler(dim,finalMatrix,fabricObject);});// debug code\n// var canvas = this.canvas;\n// setTimeout(function() {\n//   canvas.contextTop.clearRect(0, 0, 700, 700);\n//   canvas.contextTop.fillStyle = 'green';\n//   Object.keys(coords).forEach(function(key) {\n//     var control = coords[key];\n//     canvas.contextTop.fillRect(control.x, control.y, 3, 3);\n//   });\n// }, 50);\nreturn coords;},calcACoords:function(){var rotateMatrix=this._calcRotateMatrix(),translateMatrix=this._calcTranslateMatrix(),finalMatrix=multiplyMatrices(translateMatrix,rotateMatrix),dim=this._getTransformedDimensions(),w=dim.x/2,h=dim.y/2;return{// corners\ntl:transformPoint({x:-w,y:-h},finalMatrix),tr:transformPoint({x:w,y:-h},finalMatrix),bl:transformPoint({x:-w,y:h},finalMatrix),br:transformPoint({x:w,y:h},finalMatrix)};},/**\n     * Sets corner and controls position coordinates based on current angle, width and height, left and top.\n     * oCoords are used to find the corners\n     * aCoords are used to quickly find an object on the canvas\n     * lineCoords are used to quickly find object during pointer events.\n     * See {@link https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords|When-to-call-setCoords}\n     * @param {Boolean} [skipCorners] skip calculation of oCoords.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */setCoords:function(skipCorners){this.aCoords=this.calcACoords();// in case we are in a group, for how the inner group target check works,\n// lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.\nthis.lineCoords=this.group?this.aCoords:this.calcLineCoords();if(skipCorners){return this;}// set coordinates of the draggable boxes in the corners used to scale/rotate the image\nthis.oCoords=this.calcOCoords();this._setCornerCoords&&this._setCornerCoords();return this;},/**\n     * calculate rotation matrix of an object\n     * @return {Array} rotation matrix for the object\n     */_calcRotateMatrix:function(){return util.calcRotateMatrix(this);},/**\n     * calculate the translation matrix for an object transform\n     * @return {Array} rotation matrix for the object\n     */_calcTranslateMatrix:function(){var center=this.getCenterPoint();return[1,0,0,1,center.x,center.y];},transformMatrixKey:function(skipGroup){var sep='_',prefix='';if(!skipGroup&&this.group){prefix=this.group.transformMatrixKey(skipGroup)+sep;};return prefix+this.top+sep+this.left+sep+this.scaleX+sep+this.scaleY+sep+this.skewX+sep+this.skewY+sep+this.angle+sep+this.originX+sep+this.originY+sep+this.width+sep+this.height+sep+this.strokeWidth+this.flipX+this.flipY;},/**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties.\n     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations\n     * There are some situation in which this is useful to avoid the fake rotation.\n     * @return {Array} transform matrix for the object\n     */calcTransformMatrix:function(skipGroup){var matrix=this.calcOwnMatrix();if(skipGroup||!this.group){return matrix;}var key=this.transformMatrixKey(skipGroup),cache=this.matrixCache||(this.matrixCache={});if(cache.key===key){return cache.value;}if(this.group){matrix=multiplyMatrices(this.group.calcTransformMatrix(false),matrix);}cache.key=key;cache.value=matrix;return matrix;},/**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties, this matrix does not include the group transformation\n     * @return {Array} transform matrix for the object\n     */calcOwnMatrix:function(){var key=this.transformMatrixKey(true),cache=this.ownMatrixCache||(this.ownMatrixCache={});if(cache.key===key){return cache.value;}var tMatrix=this._calcTranslateMatrix(),options={angle:this.angle,translateX:tMatrix[4],translateY:tMatrix[5],scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,flipX:this.flipX,flipY:this.flipY};cache.key=key;cache.value=util.composeMatrix(options);return cache.value;},/*\n     * Calculate object dimensions from its properties\n     * @private\n     * @deprecated since 3.4.0, please use fabric.util._calcDimensionsTransformMatrix\n     * not including or including flipX, flipY to emulate the flipping boolean\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */_calcDimensionsTransformMatrix:function(skewX,skewY,flipping){return util.calcDimensionsMatrix({skewX:skewX,skewY:skewY,scaleX:this.scaleX*(flipping&&this.flipX?-1:1),scaleY:this.scaleY*(flipping&&this.flipY?-1:1)});},/*\n     * Calculate object dimensions from its properties\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */_getNonTransformedDimensions:function(){var strokeWidth=this.strokeWidth,w=this.width+strokeWidth,h=this.height+strokeWidth;return{x:w,y:h};},/*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param {Number} skewX, a value to override current skewX\n     * @param {Number} skewY, a value to override current skewY\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */_getTransformedDimensions:function(skewX,skewY){if(typeof skewX==='undefined'){skewX=this.skewX;}if(typeof skewY==='undefined'){skewY=this.skewY;}var dimensions,dimX,dimY,noSkew=skewX===0&&skewY===0;if(this.strokeUniform){dimX=this.width;dimY=this.height;}else{dimensions=this._getNonTransformedDimensions();dimX=dimensions.x;dimY=dimensions.y;}if(noSkew){return this._finalizeDimensions(dimX*this.scaleX,dimY*this.scaleY);}var bbox=util.sizeAfterTransform(dimX,dimY,{scaleX:this.scaleX,scaleY:this.scaleY,skewX:skewX,skewY:skewY});return this._finalizeDimensions(bbox.x,bbox.y);},/*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param Number width width of the bbox\n     * @param Number height height of the bbox\n     * @private\n     * @return {Object} .x finalized width dimension\n     * @return {Object} .y finalized height dimension\n     */_finalizeDimensions:function(width,height){return this.strokeUniform?{x:width+this.strokeWidth,y:height+this.strokeWidth}:{x:width,y:height};},/*\n     * Calculate object dimensions for controls box, including padding and canvas zoom.\n     * and active selection\n     * private\n     */_calculateCurrentDimensions:function(){var vpt=this.getViewportTransform(),dim=this._getTransformedDimensions(),p=transformPoint(dim,vpt,true);return p.scalarAdd(2*this.padding);}});})();fabric.util.object.extend(fabric.Object.prototype,/** @lends fabric.Object.prototype */{/**\n   * Moves an object to the bottom of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */sendToBack:function(){if(this.group){fabric.StaticCanvas.prototype.sendToBack.call(this.group,this);}else if(this.canvas){this.canvas.sendToBack(this);}return this;},/**\n   * Moves an object to the top of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */bringToFront:function(){if(this.group){fabric.StaticCanvas.prototype.bringToFront.call(this.group,this);}else if(this.canvas){this.canvas.bringToFront(this);}return this;},/**\n   * Moves an object down in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */sendBackwards:function(intersecting){if(this.group){fabric.StaticCanvas.prototype.sendBackwards.call(this.group,this,intersecting);}else if(this.canvas){this.canvas.sendBackwards(this,intersecting);}return this;},/**\n   * Moves an object up in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */bringForward:function(intersecting){if(this.group){fabric.StaticCanvas.prototype.bringForward.call(this.group,this,intersecting);}else if(this.canvas){this.canvas.bringForward(this,intersecting);}return this;},/**\n   * Moves an object to specified level in stack of drawn objects\n   * @param {Number} index New position of object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */moveTo:function(index){if(this.group&&this.group.type!=='activeSelection'){fabric.StaticCanvas.prototype.moveTo.call(this.group,this,index);}else if(this.canvas){this.canvas.moveTo(this,index);}return this;}});/* _TO_SVG_START_ */(function(){function getSvgColorString(prop,value){if(!value){return prop+': none; ';}else if(value.toLive){return prop+': url(#SVGID_'+value.id+'); ';}else{var color=new fabric.Color(value),str=prop+': '+color.toRgb()+'; ',opacity=color.getAlpha();if(opacity!==1){//change the color in rgb + opacity\nstr+=prop+'-opacity: '+opacity.toString()+'; ';}return str;}}var toFixed=fabric.util.toFixed;fabric.util.object.extend(fabric.Object.prototype,/** @lends fabric.Object.prototype */{/**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */getSvgStyles:function(skipShadow){var fillRule=this.fillRule?this.fillRule:'nonzero',strokeWidth=this.strokeWidth?this.strokeWidth:'0',strokeDashArray=this.strokeDashArray?this.strokeDashArray.join(' '):'none',strokeDashOffset=this.strokeDashOffset?this.strokeDashOffset:'0',strokeLineCap=this.strokeLineCap?this.strokeLineCap:'butt',strokeLineJoin=this.strokeLineJoin?this.strokeLineJoin:'miter',strokeMiterLimit=this.strokeMiterLimit?this.strokeMiterLimit:'4',opacity=typeof this.opacity!=='undefined'?this.opacity:'1',visibility=this.visible?'':' visibility: hidden;',filter=skipShadow?'':this.getSvgFilter(),fill=getSvgColorString('fill',this.fill),stroke=getSvgColorString('stroke',this.stroke);return[stroke,'stroke-width: ',strokeWidth,'; ','stroke-dasharray: ',strokeDashArray,'; ','stroke-linecap: ',strokeLineCap,'; ','stroke-dashoffset: ',strokeDashOffset,'; ','stroke-linejoin: ',strokeLineJoin,'; ','stroke-miterlimit: ',strokeMiterLimit,'; ',fill,'fill-rule: ',fillRule,'; ','opacity: ',opacity,';',filter,visibility].join('');},/**\n     * Returns styles-string for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.\n     * @return {String}\n     */getSvgSpanStyles:function(style,useWhiteSpace){var term='; ';var fontFamily=style.fontFamily?'font-family: '+(style.fontFamily.indexOf('\\'')===-1&&style.fontFamily.indexOf('\"')===-1?'\\''+style.fontFamily+'\\'':style.fontFamily)+term:'';var strokeWidth=style.strokeWidth?'stroke-width: '+style.strokeWidth+term:'',fontFamily=fontFamily,fontSize=style.fontSize?'font-size: '+style.fontSize+'px'+term:'',fontStyle=style.fontStyle?'font-style: '+style.fontStyle+term:'',fontWeight=style.fontWeight?'font-weight: '+style.fontWeight+term:'',fill=style.fill?getSvgColorString('fill',style.fill):'',stroke=style.stroke?getSvgColorString('stroke',style.stroke):'',textDecoration=this.getSvgTextDecoration(style),deltaY=style.deltaY?'baseline-shift: '+-style.deltaY+'; ':'';if(textDecoration){textDecoration='text-decoration: '+textDecoration+term;}return[stroke,strokeWidth,fontFamily,fontSize,fontStyle,fontWeight,textDecoration,fill,deltaY,useWhiteSpace?'white-space: pre; ':''].join('');},/**\n     * Returns text-decoration property for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @return {String}\n     */getSvgTextDecoration:function(style){return['overline','underline','line-through'].filter(function(decoration){return style[decoration.replace('-','')];}).join(' ');},/**\n     * Returns filter for svg shadow\n     * @return {String}\n     */getSvgFilter:function(){return this.shadow?'filter: url(#SVGID_'+this.shadow.id+');':'';},/**\n     * Returns id attribute for svg output\n     * @return {String}\n     */getSvgCommons:function(){return[this.id?'id=\"'+this.id+'\" ':'',this.clipPath?'clip-path=\"url(#'+this.clipPath.clipPathId+')\" ':''].join('');},/**\n     * Returns transform-string for svg-export\n     * @param {Boolean} use the full transform or the single object one.\n     * @return {String}\n     */getSvgTransform:function(full,additionalTransform){var transform=full?this.calcTransformMatrix():this.calcOwnMatrix(),svgTransform='transform=\"'+fabric.util.matrixToSVG(transform);return svgTransform+(additionalTransform||'')+'\" ';},_setSVGBg:function(textBgRects){if(this.backgroundColor){var NUM_FRACTION_DIGITS=fabric.Object.NUM_FRACTION_DIGITS;textBgRects.push('\\t\\t<rect ',this._getFillAttributes(this.backgroundColor),' x=\"',toFixed(-this.width/2,NUM_FRACTION_DIGITS),'\" y=\"',toFixed(-this.height/2,NUM_FRACTION_DIGITS),'\" width=\"',toFixed(this.width,NUM_FRACTION_DIGITS),'\" height=\"',toFixed(this.height,NUM_FRACTION_DIGITS),'\"></rect>\\n');}},/**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */toSVG:function(reviver){return this._createBaseSVGMarkup(this._toSVG(reviver),{reviver:reviver});},/**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */toClipPathSVG:function(reviver){return'\\t'+this._createBaseClipPathSVGMarkup(this._toSVG(reviver),{reviver:reviver});},/**\n     * @private\n     */_createBaseClipPathSVGMarkup:function(objectMarkup,options){options=options||{};var reviver=options.reviver,additionalTransform=options.additionalTransform||'',commonPieces=[this.getSvgTransform(true,additionalTransform),this.getSvgCommons()].join(''),// insert commons in the markup, style and svgCommons\nindex=objectMarkup.indexOf('COMMON_PARTS');objectMarkup[index]=commonPieces;return reviver?reviver(objectMarkup.join('')):objectMarkup.join('');},/**\n     * @private\n     */_createBaseSVGMarkup:function(objectMarkup,options){options=options||{};var noStyle=options.noStyle,reviver=options.reviver,styleInfo=noStyle?'':'style=\"'+this.getSvgStyles()+'\" ',shadowInfo=options.withShadow?'style=\"'+this.getSvgFilter()+'\" ':'',clipPath=this.clipPath,vectorEffect=this.strokeUniform?'vector-effect=\"non-scaling-stroke\" ':'',absoluteClipPath=clipPath&&clipPath.absolutePositioned,stroke=this.stroke,fill=this.fill,shadow=this.shadow,commonPieces,markup=[],clipPathMarkup,// insert commons in the markup, style and svgCommons\nindex=objectMarkup.indexOf('COMMON_PARTS'),additionalTransform=options.additionalTransform;if(clipPath){clipPath.clipPathId='CLIPPATH_'+fabric.Object.__uid++;clipPathMarkup='<clipPath id=\"'+clipPath.clipPathId+'\" >\\n'+clipPath.toClipPathSVG(reviver)+'</clipPath>\\n';}if(absoluteClipPath){markup.push('<g ',shadowInfo,this.getSvgCommons(),' >\\n');}markup.push('<g ',this.getSvgTransform(false),!absoluteClipPath?shadowInfo+this.getSvgCommons():'',' >\\n');commonPieces=[styleInfo,vectorEffect,noStyle?'':this.addPaintOrder(),' ',additionalTransform?'transform=\"'+additionalTransform+'\" ':''].join('');objectMarkup[index]=commonPieces;if(fill&&fill.toLive){markup.push(fill.toSVG(this));}if(stroke&&stroke.toLive){markup.push(stroke.toSVG(this));}if(shadow){markup.push(shadow.toSVG(this));}if(clipPath){markup.push(clipPathMarkup);}markup.push(objectMarkup.join(''));markup.push('</g>\\n');absoluteClipPath&&markup.push('</g>\\n');return reviver?reviver(markup.join('')):markup.join('');},addPaintOrder:function(){return this.paintFirst!=='fill'?' paint-order=\"'+this.paintFirst+'\" ':'';}});})();/* _TO_SVG_END_ */(function(){var extend=fabric.util.object.extend,originalSet='stateProperties';/*\n    Depends on `stateProperties`\n  */function saveProps(origin,destination,props){var tmpObj={},deep=true;props.forEach(function(prop){tmpObj[prop]=origin[prop];});extend(origin[destination],tmpObj,deep);}function _isEqual(origValue,currentValue,firstPass){if(origValue===currentValue){// if the objects are identical, return\nreturn true;}else if(Array.isArray(origValue)){if(!Array.isArray(currentValue)||origValue.length!==currentValue.length){return false;}for(var i=0,len=origValue.length;i<len;i++){if(!_isEqual(origValue[i],currentValue[i])){return false;}}return true;}else if(origValue&&typeof origValue==='object'){var keys=Object.keys(origValue),key;if(!currentValue||typeof currentValue!=='object'||!firstPass&&keys.length!==Object.keys(currentValue).length){return false;}for(var i=0,len=keys.length;i<len;i++){key=keys[i];// since clipPath is in the statefull cache list and the clipPath objects\n// would be iterated as an object, this would lead to possible infinite recursion\n// we do not want to compare those.\nif(key==='canvas'||key==='group'){continue;}if(!_isEqual(origValue[key],currentValue[key])){return false;}}return true;}}fabric.util.object.extend(fabric.Object.prototype,/** @lends fabric.Object.prototype */{/**\n     * Returns true if object state (one of its state properties) was changed\n     * @param {String} [propertySet] optional name for the set of property we want to save\n     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\n     */hasStateChanged:function(propertySet){propertySet=propertySet||originalSet;var dashedPropertySet='_'+propertySet;if(Object.keys(this[dashedPropertySet]).length<this[propertySet].length){return true;}return!_isEqual(this[dashedPropertySet],this,true);},/**\n     * Saves state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */saveState:function(options){var propertySet=options&&options.propertySet||originalSet,destination='_'+propertySet;if(!this[destination]){return this.setupState(options);}saveProps(this,destination,this[propertySet]);if(options&&options.stateProperties){saveProps(this,destination,options.stateProperties);}return this;},/**\n     * Setups state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */setupState:function(options){options=options||{};var propertySet=options.propertySet||originalSet;options.propertySet=propertySet;this['_'+propertySet]={};this.saveState(options);return this;}});})();(function(){var degreesToRadians=fabric.util.degreesToRadians;fabric.util.object.extend(fabric.Object.prototype,/** @lends fabric.Object.prototype */{/**\n     * Determines which corner has been clicked\n     * @private\n     * @param {Object} pointer The pointer indicating the mouse position\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\n     */_findTargetCorner:function(pointer,forTouch){// objects in group, anykind, are not self modificable,\n// must not return an hovered corner.\nif(!this.hasControls||this.group||!this.canvas||this.canvas._activeObject!==this){return false;}var ex=pointer.x,ey=pointer.y,xPoints,lines,keys=Object.keys(this.oCoords),j=keys.length-1,i;this.__corner=0;// cycle in reverse order so we pick first the one on top\nfor(;j>=0;j--){i=keys[j];if(!this.isControlVisible(i)){continue;}lines=this._getImageLines(forTouch?this.oCoords[i].touchCorner:this.oCoords[i].corner);// // debugging\n//\n// this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n// this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n//\n// this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n// this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n//\n// this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n// this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n//\n// this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n// this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\nxPoints=this._findCrossPoints({x:ex,y:ey},lines);if(xPoints!==0&&xPoints%2===1){this.__corner=i;return i;}}return false;},/**\n     * Calls a function for each control. The function gets called,\n     * with the control, the object that is calling the iterator and the control's key\n     * @param {Function} fn function to iterate over the controls over\n     */forEachControl:function(fn){for(var i in this.controls){fn(this.controls[i],i,this);};},/**\n     * Sets the coordinates of the draggable boxes in the corners of\n     * the image used to scale/rotate it.\n     * note: if we would switch to ROUND corner area, all of this would disappear.\n     * everything would resolve to a single point and a pythagorean theorem for the distance\n     * @private\n     */_setCornerCoords:function(){var coords=this.oCoords;for(var control in coords){var controlObject=this.controls[control];coords[control].corner=controlObject.calcCornerCoords(this.angle,this.cornerSize,coords[control].x,coords[control].y,false);coords[control].touchCorner=controlObject.calcCornerCoords(this.angle,this.touchCornerSize,coords[control].x,coords[control].y,true);}},/**\n     * Draws a colored layer behind the object, inside its selection borders.\n     * Requires public options: padding, selectionBackgroundColor\n     * this function is called when the context is transformed\n     * has checks to be skipped when the object is on a staticCanvas\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */drawSelectionBackground:function(ctx){if(!this.selectionBackgroundColor||this.canvas&&!this.canvas.interactive||this.canvas&&this.canvas._activeObject!==this){return this;}ctx.save();var center=this.getCenterPoint(),wh=this._calculateCurrentDimensions(),vpt=this.canvas.viewportTransform;ctx.translate(center.x,center.y);ctx.scale(1/vpt[0],1/vpt[3]);ctx.rotate(degreesToRadians(this.angle));ctx.fillStyle=this.selectionBackgroundColor;ctx.fillRect(-wh.x/2,-wh.y/2,wh.x,wh.y);ctx.restore();return this;},/**\n     * Draws borders of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */drawBorders:function(ctx,styleOverride){styleOverride=styleOverride||{};var wh=this._calculateCurrentDimensions(),strokeWidth=this.borderScaleFactor,width=wh.x+strokeWidth,height=wh.y+strokeWidth,hasControls=typeof styleOverride.hasControls!=='undefined'?styleOverride.hasControls:this.hasControls,shouldStroke=false;ctx.save();ctx.strokeStyle=styleOverride.borderColor||this.borderColor;this._setLineDash(ctx,styleOverride.borderDashArray||this.borderDashArray);ctx.strokeRect(-width/2,-height/2,width,height);if(hasControls){ctx.beginPath();this.forEachControl(function(control,key,fabricObject){// in this moment, the ctx is centered on the object.\n// width and height of the above function are the size of the bbox.\nif(control.withConnection&&control.getVisibility(fabricObject,key)){// reset movement for each control\nshouldStroke=true;ctx.moveTo(control.x*width,control.y*height);ctx.lineTo(control.x*width+control.offsetX,control.y*height+control.offsetY);}});if(shouldStroke){ctx.stroke();}}ctx.restore();return this;},/**\n     * Draws borders of an object's bounding box when it is inside a group.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {object} options object representing current object parameters\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */drawBordersInGroup:function(ctx,options,styleOverride){styleOverride=styleOverride||{};var bbox=fabric.util.sizeAfterTransform(this.width,this.height,options),strokeWidth=this.strokeWidth,strokeUniform=this.strokeUniform,borderScaleFactor=this.borderScaleFactor,width=bbox.x+strokeWidth*(strokeUniform?this.canvas.getZoom():options.scaleX)+borderScaleFactor,height=bbox.y+strokeWidth*(strokeUniform?this.canvas.getZoom():options.scaleY)+borderScaleFactor;ctx.save();this._setLineDash(ctx,styleOverride.borderDashArray||this.borderDashArray);ctx.strokeStyle=styleOverride.borderColor||this.borderColor;ctx.strokeRect(-width/2,-height/2,width,height);ctx.restore();return this;},/**\n     * Draws corners of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: cornerSize, padding\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */drawControls:function(ctx,styleOverride){styleOverride=styleOverride||{};ctx.save();var retinaScaling=this.canvas.getRetinaScaling(),matrix,p;ctx.setTransform(retinaScaling,0,0,retinaScaling,0,0);ctx.strokeStyle=ctx.fillStyle=styleOverride.cornerColor||this.cornerColor;if(!this.transparentCorners){ctx.strokeStyle=styleOverride.cornerStrokeColor||this.cornerStrokeColor;}this._setLineDash(ctx,styleOverride.cornerDashArray||this.cornerDashArray);this.setCoords();if(this.group){// fabricJS does not really support drawing controls inside groups,\n// this piece of code here helps having at least the control in places.\n// If an application needs to show some objects as selected because of some UI state\n// can still call Object._renderControls() on any object they desire, independently of groups.\n// using no padding, circular controls and hiding the rotating cursor is higly suggested,\nmatrix=this.group.calcTransformMatrix();}this.forEachControl(function(control,key,fabricObject){p=fabricObject.oCoords[key];if(control.getVisibility(fabricObject,key)){if(matrix){p=fabric.util.transformPoint(p,matrix);}control.render(ctx,p.x,p.y,styleOverride,fabricObject);}});ctx.restore();return this;},/**\n     * Returns true if the specified control is visible, false otherwise.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @returns {Boolean} true if the specified control is visible, false otherwise\n     */isControlVisible:function(controlKey){return this.controls[controlKey]&&this.controls[controlKey].getVisibility(this,controlKey);},/**\n     * Sets the visibility of the specified control.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */setControlVisible:function(controlKey,visible){if(!this._controlsVisibility){this._controlsVisibility={};}this._controlsVisibility[controlKey]=visible;return this;},/**\n     * Sets the visibility state of object controls.\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */setControlsVisibility:function(options){options||(options={});for(var p in options){this.setControlVisible(p,options[p]);}return this;},/**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to deselect this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */onDeselect:function(){// implemented by sub-classes, as needed.\n},/**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to select this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */onSelect:function(){// implemented by sub-classes, as needed.\n}});})();fabric.util.object.extend(fabric.StaticCanvas.prototype,/** @lends fabric.StaticCanvas.prototype */{/**\n   * Animation duration (in ms) for fx* methods\n   * @type Number\n   * @default\n   */FX_DURATION:500,/**\n   * Centers object horizontally with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */fxCenterObjectH:function(object,callbacks){callbacks=callbacks||{};var empty=function(){},onComplete=callbacks.onComplete||empty,onChange=callbacks.onChange||empty,_this=this;fabric.util.animate({startValue:object.left,endValue:this.getCenter().left,duration:this.FX_DURATION,onChange:function(value){object.set('left',value);_this.requestRenderAll();onChange();},onComplete:function(){object.setCoords();onComplete();}});return this;},/**\n   * Centers object vertically with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */fxCenterObjectV:function(object,callbacks){callbacks=callbacks||{};var empty=function(){},onComplete=callbacks.onComplete||empty,onChange=callbacks.onChange||empty,_this=this;fabric.util.animate({startValue:object.top,endValue:this.getCenter().top,duration:this.FX_DURATION,onChange:function(value){object.set('top',value);_this.requestRenderAll();onChange();},onComplete:function(){object.setCoords();onComplete();}});return this;},/**\n   * Same as `fabric.Canvas#remove` but animated\n   * @param {fabric.Object} object Object to remove\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */fxRemove:function(object,callbacks){callbacks=callbacks||{};var empty=function(){},onComplete=callbacks.onComplete||empty,onChange=callbacks.onChange||empty,_this=this;fabric.util.animate({startValue:object.opacity,endValue:0,duration:this.FX_DURATION,onChange:function(value){object.set('opacity',value);_this.requestRenderAll();onChange();},onComplete:function(){_this.remove(object);onComplete();}});return this;}});fabric.util.object.extend(fabric.Object.prototype,/** @lends fabric.Object.prototype */{/**\n   * Animates object's properties\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\n   * @return {fabric.Object} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}\n   * @chainable\n   *\n   * As object  multiple properties\n   *\n   * object.animate({ left: ..., top: ... });\n   * object.animate({ left: ..., top: ... }, { duration: ... });\n   *\n   * As string  one property\n   *\n   * object.animate('left', ...);\n   * object.animate('left', { duration: ... });\n   *\n   */animate:function(){if(arguments[0]&&typeof arguments[0]==='object'){var propsToAnimate=[],prop,skipCallbacks;for(prop in arguments[0]){propsToAnimate.push(prop);}for(var i=0,len=propsToAnimate.length;i<len;i++){prop=propsToAnimate[i];skipCallbacks=i!==len-1;this._animate(prop,arguments[0][prop],arguments[1],skipCallbacks);}}else{this._animate.apply(this,arguments);}return this;},/**\n   * @private\n   * @param {String} property Property to animate\n   * @param {String} to Value to animate to\n   * @param {Object} [options] Options object\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\n   */_animate:function(property,to,options,skipCallbacks){var _this=this,propPair;to=to.toString();if(!options){options={};}else{options=fabric.util.object.clone(options);}if(~property.indexOf('.')){propPair=property.split('.');}var propIsColor=_this.colorProperties.indexOf(property)>-1||propPair&&_this.colorProperties.indexOf(propPair[1])>-1;var currentValue=propPair?this.get(propPair[0])[propPair[1]]:this.get(property);if(!('from'in options)){options.from=currentValue;}if(!propIsColor){if(~to.indexOf('=')){to=currentValue+parseFloat(to.replace('=',''));}else{to=parseFloat(to);}}var _options={startValue:options.from,endValue:to,byValue:options.by,easing:options.easing,duration:options.duration,abort:options.abort&&function(value,valueProgress,timeProgress){return options.abort.call(_this,value,valueProgress,timeProgress);},onChange:function(value,valueProgress,timeProgress){if(propPair){_this[propPair[0]][propPair[1]]=value;}else{_this.set(property,value);}if(skipCallbacks){return;}options.onChange&&options.onChange(value,valueProgress,timeProgress);},onComplete:function(value,valueProgress,timeProgress){if(skipCallbacks){return;}_this.setCoords();options.onComplete&&options.onComplete(value,valueProgress,timeProgress);}};if(propIsColor){return fabric.util.animateColor(_options.startValue,_options.endValue,_options.duration,_options);}else{return fabric.util.animate(_options);}}});(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),extend=fabric.util.object.extend,clone=fabric.util.object.clone,coordProps={x1:1,x2:1,y1:1,y2:1};if(fabric.Line){fabric.warn('fabric.Line is already defined');return;}/**\n   * Line class\n   * @class fabric.Line\n   * @extends fabric.Object\n   * @see {@link fabric.Line#initialize} for constructor definition\n   */fabric.Line=fabric.util.createClass(fabric.Object,/** @lends fabric.Line.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'line',/**\n     * x value or first line edge\n     * @type Number\n     * @default\n     */x1:0,/**\n     * y value or first line edge\n     * @type Number\n     * @default\n     */y1:0,/**\n     * x value or second line edge\n     * @type Number\n     * @default\n     */x2:0,/**\n     * y value or second line edge\n     * @type Number\n     * @default\n     */y2:0,cacheProperties:fabric.Object.prototype.cacheProperties.concat('x1','x2','y1','y2'),/**\n     * Constructor\n     * @param {Array} [points] Array of points\n     * @param {Object} [options] Options object\n     * @return {fabric.Line} thisArg\n     */initialize:function(points,options){if(!points){points=[0,0,0,0];}this.callSuper('initialize',options);this.set('x1',points[0]);this.set('y1',points[1]);this.set('x2',points[2]);this.set('y2',points[3]);this._setWidthHeight(options);},/**\n     * @private\n     * @param {Object} [options] Options\n     */_setWidthHeight:function(options){options||(options={});this.width=Math.abs(this.x2-this.x1);this.height=Math.abs(this.y2-this.y1);this.left='left'in options?options.left:this._getLeftToOriginX();this.top='top'in options?options.top:this._getTopToOriginY();},/**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     */_set:function(key,value){this.callSuper('_set',key,value);if(typeof coordProps[key]!=='undefined'){this._setWidthHeight();}return this;},/**\n     * @private\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\n     */_getLeftToOriginX:makeEdgeToOriginGetter({// property names\norigin:'originX',axis1:'x1',axis2:'x2',dimension:'width'},{// possible values of origin\nnearest:'left',center:'center',farthest:'right'}),/**\n     * @private\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\n     */_getTopToOriginY:makeEdgeToOriginGetter({// property names\norigin:'originY',axis1:'y1',axis2:'y2',dimension:'height'},{// possible values of origin\nnearest:'top',center:'center',farthest:'bottom'}),/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function(ctx){ctx.beginPath();var p=this.calcLinePoints();ctx.moveTo(p.x1,p.y1);ctx.lineTo(p.x2,p.y2);ctx.lineWidth=this.strokeWidth;// TODO: test this\n// make sure setting \"fill\" changes color of a line\n// (by copying fillStyle to strokeStyle, since line is stroked, not filled)\nvar origStrokeStyle=ctx.strokeStyle;ctx.strokeStyle=this.stroke||ctx.fillStyle;this.stroke&&this._renderStroke(ctx);ctx.strokeStyle=origStrokeStyle;},/**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */_findCenterFromElement:function(){return{x:(this.x1+this.x2)/2,y:(this.y1+this.y2)/2};},/**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toObject:function(propertiesToInclude){return extend(this.callSuper('toObject',propertiesToInclude),this.calcLinePoints());},/*\n     * Calculate object dimensions from its properties\n     * @private\n     */_getNonTransformedDimensions:function(){var dim=this.callSuper('_getNonTransformedDimensions');if(this.strokeLineCap==='butt'){if(this.width===0){dim.y-=this.strokeWidth;}if(this.height===0){dim.x-=this.strokeWidth;}}return dim;},/**\n     * Recalculates line points given width and height\n     * @private\n     */calcLinePoints:function(){var xMult=this.x1<=this.x2?-1:1,yMult=this.y1<=this.y2?-1:1,x1=xMult*this.width*0.5,y1=yMult*this.height*0.5,x2=xMult*this.width*-0.5,y2=yMult*this.height*-0.5;return{x1:x1,x2:x2,y1:y1,y2:y2};},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */_toSVG:function(){var p=this.calcLinePoints();return['<line ','COMMON_PARTS','x1=\"',p.x1,'\" y1=\"',p.y1,'\" x2=\"',p.x2,'\" y2=\"',p.y2,'\" />\\n'];}/* _TO_SVG_END_ */});/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\n   * @static\n   * @memberOf fabric.Line\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\n   */fabric.Line.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));/**\n   * Returns fabric.Line instance from an SVG element\n   * @static\n   * @memberOf fabric.Line\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] callback function invoked after parsing\n   */fabric.Line.fromElement=function(element,callback,options){options=options||{};var parsedAttributes=fabric.parseAttributes(element,fabric.Line.ATTRIBUTE_NAMES),points=[parsedAttributes.x1||0,parsedAttributes.y1||0,parsedAttributes.x2||0,parsedAttributes.y2||0];callback(new fabric.Line(points,extend(parsedAttributes,options)));};/* _FROM_SVG_END_ */ /**\n   * Returns fabric.Line instance from an object representation\n   * @static\n   * @memberOf fabric.Line\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */fabric.Line.fromObject=function(object,callback){function _callback(instance){delete instance.points;callback&&callback(instance);};var options=clone(object,true);options.points=[object.x1,object.y1,object.x2,object.y2];fabric.Object._fromObject('Line',options,_callback,'points');};/**\n   * Produces a function that calculates distance from canvas edge to Line origin.\n   */function makeEdgeToOriginGetter(propertyNames,originValues){var origin=propertyNames.origin,axis1=propertyNames.axis1,axis2=propertyNames.axis2,dimension=propertyNames.dimension,nearest=originValues.nearest,center=originValues.center,farthest=originValues.farthest;return function(){switch(this.get(origin)){case nearest:return Math.min(this.get(axis1),this.get(axis2));case center:return Math.min(this.get(axis1),this.get(axis2))+0.5*this.get(dimension);case farthest:return Math.max(this.get(axis1),this.get(axis2));}};}})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),pi=Math.PI;if(fabric.Circle){fabric.warn('fabric.Circle is already defined.');return;}/**\n   * Circle class\n   * @class fabric.Circle\n   * @extends fabric.Object\n   * @see {@link fabric.Circle#initialize} for constructor definition\n   */fabric.Circle=fabric.util.createClass(fabric.Object,/** @lends fabric.Circle.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'circle',/**\n     * Radius of this circle\n     * @type Number\n     * @default\n     */radius:0,/**\n     * Start angle of the circle, moving clockwise\n     * deprecated type, this should be in degree, this was an oversight.\n     * probably will change to degrees in next major version\n     * @type Number\n     * @default 0\n     */startAngle:0,/**\n     * End angle of the circle\n     * deprecated type, this should be in degree, this was an oversight.\n     * probably will change to degrees in next major version\n     * @type Number\n     * @default 2Pi\n     */endAngle:pi*2,cacheProperties:fabric.Object.prototype.cacheProperties.concat('radius','startAngle','endAngle'),/**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Circle} thisArg\n     */_set:function(key,value){this.callSuper('_set',key,value);if(key==='radius'){this.setRadius(value);}return this;},/**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toObject:function(propertiesToInclude){return this.callSuper('toObject',['radius','startAngle','endAngle'].concat(propertiesToInclude));},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */_toSVG:function(){var svgString,x=0,y=0,angle=(this.endAngle-this.startAngle)%(2*pi);if(angle===0){svgString=['<circle ','COMMON_PARTS','cx=\"'+x+'\" cy=\"'+y+'\" ','r=\"',this.radius,'\" />\\n'];}else{var startX=fabric.util.cos(this.startAngle)*this.radius,startY=fabric.util.sin(this.startAngle)*this.radius,endX=fabric.util.cos(this.endAngle)*this.radius,endY=fabric.util.sin(this.endAngle)*this.radius,largeFlag=angle>pi?'1':'0';svgString=['<path d=\"M '+startX+' '+startY,' A '+this.radius+' '+this.radius,' 0 ',+largeFlag+' 1',' '+endX+' '+endY,'\" ','COMMON_PARTS',' />\\n'];}return svgString;},/* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */_render:function(ctx){ctx.beginPath();ctx.arc(0,0,this.radius,this.startAngle,this.endAngle,false);this._renderPaintInOrder(ctx);},/**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */getRadiusX:function(){return this.get('radius')*this.get('scaleX');},/**\n     * Returns vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */getRadiusY:function(){return this.get('radius')*this.get('scaleY');},/**\n     * Sets radius of an object (and updates width accordingly)\n     * @return {fabric.Circle} thisArg\n     */setRadius:function(value){this.radius=value;return this.set('width',value*2).set('height',value*2);}});/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\n   * @static\n   * @memberOf fabric.Circle\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\n   */fabric.Circle.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));/**\n   * Returns {@link fabric.Circle} instance from an SVG element\n   * @static\n   * @memberOf fabric.Circle\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @param {Object} [options] Options object\n   * @throws {Error} If value of `r` attribute is missing or invalid\n   */fabric.Circle.fromElement=function(element,callback){var parsedAttributes=fabric.parseAttributes(element,fabric.Circle.ATTRIBUTE_NAMES);if(!isValidRadius(parsedAttributes)){throw new Error('value of `r` attribute is required and can not be negative');}parsedAttributes.left=(parsedAttributes.left||0)-parsedAttributes.radius;parsedAttributes.top=(parsedAttributes.top||0)-parsedAttributes.radius;callback(new fabric.Circle(parsedAttributes));};/**\n   * @private\n   */function isValidRadius(attributes){return'radius'in attributes&&attributes.radius>=0;}/* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Circle} instance from an object representation\n   * @static\n   * @memberOf fabric.Circle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */fabric.Circle.fromObject=function(object,callback){fabric.Object._fromObject('Circle',object,callback);};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={});if(fabric.Triangle){fabric.warn('fabric.Triangle is already defined');return;}/**\n   * Triangle class\n   * @class fabric.Triangle\n   * @extends fabric.Object\n   * @return {fabric.Triangle} thisArg\n   * @see {@link fabric.Triangle#initialize} for constructor definition\n   */fabric.Triangle=fabric.util.createClass(fabric.Object,/** @lends fabric.Triangle.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'triangle',/**\n     * Width is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */width:100,/**\n     * Height is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */height:100,/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function(ctx){var widthBy2=this.width/2,heightBy2=this.height/2;ctx.beginPath();ctx.moveTo(-widthBy2,heightBy2);ctx.lineTo(0,-heightBy2);ctx.lineTo(widthBy2,heightBy2);ctx.closePath();this._renderPaintInOrder(ctx);},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */_toSVG:function(){var widthBy2=this.width/2,heightBy2=this.height/2,points=[-widthBy2+' '+heightBy2,'0 '+-heightBy2,widthBy2+' '+heightBy2].join(',');return['<polygon ','COMMON_PARTS','points=\"',points,'\" />'];}/* _TO_SVG_END_ */});/**\n   * Returns {@link fabric.Triangle} instance from an object representation\n   * @static\n   * @memberOf fabric.Triangle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */fabric.Triangle.fromObject=function(object,callback){return fabric.Object._fromObject('Triangle',object,callback);};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),piBy2=Math.PI*2;if(fabric.Ellipse){fabric.warn('fabric.Ellipse is already defined.');return;}/**\n   * Ellipse class\n   * @class fabric.Ellipse\n   * @extends fabric.Object\n   * @return {fabric.Ellipse} thisArg\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\n   */fabric.Ellipse=fabric.util.createClass(fabric.Object,/** @lends fabric.Ellipse.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'ellipse',/**\n     * Horizontal radius\n     * @type Number\n     * @default\n     */rx:0,/**\n     * Vertical radius\n     * @type Number\n     * @default\n     */ry:0,cacheProperties:fabric.Object.prototype.cacheProperties.concat('rx','ry'),/**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {fabric.Ellipse} thisArg\n     */initialize:function(options){this.callSuper('initialize',options);this.set('rx',options&&options.rx||0);this.set('ry',options&&options.ry||0);},/**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Ellipse} thisArg\n     */_set:function(key,value){this.callSuper('_set',key,value);switch(key){case'rx':this.rx=value;this.set('width',value*2);break;case'ry':this.ry=value;this.set('height',value*2);break;}return this;},/**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */getRx:function(){return this.get('rx')*this.get('scaleX');},/**\n     * Returns Vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */getRy:function(){return this.get('ry')*this.get('scaleY');},/**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toObject:function(propertiesToInclude){return this.callSuper('toObject',['rx','ry'].concat(propertiesToInclude));},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */_toSVG:function(){return['<ellipse ','COMMON_PARTS','cx=\"0\" cy=\"0\" ','rx=\"',this.rx,'\" ry=\"',this.ry,'\" />\\n'];},/* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */_render:function(ctx){ctx.beginPath();ctx.save();ctx.transform(1,0,0,this.ry/this.rx,0,0);ctx.arc(0,0,this.rx,0,piBy2,false);ctx.restore();this._renderPaintInOrder(ctx);}});/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\n   * @static\n   * @memberOf fabric.Ellipse\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\n   */fabric.Ellipse.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));/**\n   * Returns {@link fabric.Ellipse} instance from an SVG element\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @return {fabric.Ellipse}\n   */fabric.Ellipse.fromElement=function(element,callback){var parsedAttributes=fabric.parseAttributes(element,fabric.Ellipse.ATTRIBUTE_NAMES);parsedAttributes.left=(parsedAttributes.left||0)-parsedAttributes.rx;parsedAttributes.top=(parsedAttributes.top||0)-parsedAttributes.ry;callback(new fabric.Ellipse(parsedAttributes));};/* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Ellipse} instance from an object representation\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */fabric.Ellipse.fromObject=function(object,callback){fabric.Object._fromObject('Ellipse',object,callback);};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),extend=fabric.util.object.extend;if(fabric.Rect){fabric.warn('fabric.Rect is already defined');return;}/**\n   * Rectangle class\n   * @class fabric.Rect\n   * @extends fabric.Object\n   * @return {fabric.Rect} thisArg\n   * @see {@link fabric.Rect#initialize} for constructor definition\n   */fabric.Rect=fabric.util.createClass(fabric.Object,/** @lends fabric.Rect.prototype */{/**\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */stateProperties:fabric.Object.prototype.stateProperties.concat('rx','ry'),/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'rect',/**\n     * Horizontal border radius\n     * @type Number\n     * @default\n     */rx:0,/**\n     * Vertical border radius\n     * @type Number\n     * @default\n     */ry:0,cacheProperties:fabric.Object.prototype.cacheProperties.concat('rx','ry'),/**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */initialize:function(options){this.callSuper('initialize',options);this._initRxRy();},/**\n     * Initializes rx/ry attributes\n     * @private\n     */_initRxRy:function(){if(this.rx&&!this.ry){this.ry=this.rx;}else if(this.ry&&!this.rx){this.rx=this.ry;}},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function(ctx){// 1x1 case (used in spray brush) optimization was removed because\n// with caching and higher zoom level this makes more damage than help\nvar rx=this.rx?Math.min(this.rx,this.width/2):0,ry=this.ry?Math.min(this.ry,this.height/2):0,w=this.width,h=this.height,x=-this.width/2,y=-this.height/2,isRounded=rx!==0||ry!==0,/* \"magic number\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */k=1-0.5522847498;ctx.beginPath();ctx.moveTo(x+rx,y);ctx.lineTo(x+w-rx,y);isRounded&&ctx.bezierCurveTo(x+w-k*rx,y,x+w,y+k*ry,x+w,y+ry);ctx.lineTo(x+w,y+h-ry);isRounded&&ctx.bezierCurveTo(x+w,y+h-k*ry,x+w-k*rx,y+h,x+w-rx,y+h);ctx.lineTo(x+rx,y+h);isRounded&&ctx.bezierCurveTo(x+k*rx,y+h,x,y+h-k*ry,x,y+h-ry);ctx.lineTo(x,y+ry);isRounded&&ctx.bezierCurveTo(x,y+k*ry,x+k*rx,y,x+rx,y);ctx.closePath();this._renderPaintInOrder(ctx);},/**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toObject:function(propertiesToInclude){return this.callSuper('toObject',['rx','ry'].concat(propertiesToInclude));},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */_toSVG:function(){var x=-this.width/2,y=-this.height/2;return['<rect ','COMMON_PARTS','x=\"',x,'\" y=\"',y,'\" rx=\"',this.rx,'\" ry=\"',this.ry,'\" width=\"',this.width,'\" height=\"',this.height,'\" />\\n'];}/* _TO_SVG_END_ */});/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\n   * @static\n   * @memberOf fabric.Rect\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\n   */fabric.Rect.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));/**\n   * Returns {@link fabric.Rect} instance from an SVG element\n   * @static\n   * @memberOf fabric.Rect\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */fabric.Rect.fromElement=function(element,callback,options){if(!element){return callback(null);}options=options||{};var parsedAttributes=fabric.parseAttributes(element,fabric.Rect.ATTRIBUTE_NAMES);parsedAttributes.left=parsedAttributes.left||0;parsedAttributes.top=parsedAttributes.top||0;parsedAttributes.height=parsedAttributes.height||0;parsedAttributes.width=parsedAttributes.width||0;var rect=new fabric.Rect(extend(options?fabric.util.object.clone(options):{},parsedAttributes));rect.visible=rect.visible&&rect.width>0&&rect.height>0;callback(rect);};/* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Rect} instance from an object representation\n   * @static\n   * @memberOf fabric.Rect\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created\n   */fabric.Rect.fromObject=function(object,callback){return fabric.Object._fromObject('Rect',object,callback);};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),extend=fabric.util.object.extend,min=fabric.util.array.min,max=fabric.util.array.max,toFixed=fabric.util.toFixed;if(fabric.Polyline){fabric.warn('fabric.Polyline is already defined');return;}/**\n   * Polyline class\n   * @class fabric.Polyline\n   * @extends fabric.Object\n   * @see {@link fabric.Polyline#initialize} for constructor definition\n   */fabric.Polyline=fabric.util.createClass(fabric.Object,/** @lends fabric.Polyline.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'polyline',/**\n     * Points array\n     * @type Array\n     * @default\n     */points:null,cacheProperties:fabric.Object.prototype.cacheProperties.concat('points'),/**\n     * Constructor\n     * @param {Array} points Array of points (where each point is an object with x and y)\n     * @param {Object} [options] Options object\n     * @return {fabric.Polyline} thisArg\n     * @example\n     * var poly = new fabric.Polyline([\n     *     { x: 10, y: 10 },\n     *     { x: 50, y: 30 },\n     *     { x: 40, y: 70 },\n     *     { x: 60, y: 50 },\n     *     { x: 100, y: 150 },\n     *     { x: 40, y: 100 }\n     *   ], {\n     *   stroke: 'red',\n     *   left: 100,\n     *   top: 100\n     * });\n     */initialize:function(points,options){options=options||{};this.points=points||[];this.callSuper('initialize',options);this._setPositionDimensions(options);},_setPositionDimensions:function(options){var calcDim=this._calcDimensions(options),correctLeftTop;this.width=calcDim.width;this.height=calcDim.height;if(!options.fromSVG){correctLeftTop=this.translateToGivenOrigin({x:calcDim.left-this.strokeWidth/2,y:calcDim.top-this.strokeWidth/2},'left','top',this.originX,this.originY);}if(typeof options.left==='undefined'){this.left=options.fromSVG?calcDim.left:correctLeftTop.x;}if(typeof options.top==='undefined'){this.top=options.fromSVG?calcDim.top:correctLeftTop.y;}this.pathOffset={x:calcDim.left+this.width/2,y:calcDim.top+this.height/2};},/**\n     * Calculate the polygon min and max point from points array,\n     * returning an object with left, top, width, height to measure the\n     * polygon size\n     * @return {Object} object.left X coordinate of the polygon leftmost point\n     * @return {Object} object.top Y coordinate of the polygon topmost point\n     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point\n     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point\n     * @private\n     */_calcDimensions:function(){var points=this.points,minX=min(points,'x')||0,minY=min(points,'y')||0,maxX=max(points,'x')||0,maxY=max(points,'y')||0,width=maxX-minX,height=maxY-minY;return{left:minX,top:minY,width:width,height:height};},/**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */toObject:function(propertiesToInclude){return extend(this.callSuper('toObject',propertiesToInclude),{points:this.points.concat()});},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */_toSVG:function(){var points=[],diffX=this.pathOffset.x,diffY=this.pathOffset.y,NUM_FRACTION_DIGITS=fabric.Object.NUM_FRACTION_DIGITS;for(var i=0,len=this.points.length;i<len;i++){points.push(toFixed(this.points[i].x-diffX,NUM_FRACTION_DIGITS),',',toFixed(this.points[i].y-diffY,NUM_FRACTION_DIGITS),' ');}return['<'+this.type+' ','COMMON_PARTS','points=\"',points.join(''),'\" />\\n'];},/* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */commonRender:function(ctx){var point,len=this.points.length,x=this.pathOffset.x,y=this.pathOffset.y;if(!len||isNaN(this.points[len-1].y)){// do not draw if no points or odd points\n// NaN comes from parseFloat of a empty string in parser\nreturn false;}ctx.beginPath();ctx.moveTo(this.points[0].x-x,this.points[0].y-y);for(var i=0;i<len;i++){point=this.points[i];ctx.lineTo(point.x-x,point.y-y);}return true;},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function(ctx){if(!this.commonRender(ctx)){return;}this._renderPaintInOrder(ctx);},/**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance\n     */complexity:function(){return this.get('points').length;}});/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\n   * @static\n   * @memberOf fabric.Polyline\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\n   */fabric.Polyline.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat();/**\n   * Returns fabric.Polyline instance from an SVG element\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {SVGElement} element Element to parser\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */fabric.Polyline.fromElementGenerator=function(_class){return function(element,callback,options){if(!element){return callback(null);}options||(options={});var points=fabric.parsePointsAttribute(element.getAttribute('points')),parsedAttributes=fabric.parseAttributes(element,fabric[_class].ATTRIBUTE_NAMES);parsedAttributes.fromSVG=true;callback(new fabric[_class](points,extend(parsedAttributes,options)));};};fabric.Polyline.fromElement=fabric.Polyline.fromElementGenerator('Polyline');/* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polyline instance from an object representation\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */fabric.Polyline.fromObject=function(object,callback){return fabric.Object._fromObject('Polyline',object,callback,'points');};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={});if(fabric.Polygon){fabric.warn('fabric.Polygon is already defined');return;}/**\n   * Polygon class\n   * @class fabric.Polygon\n   * @extends fabric.Polyline\n   * @see {@link fabric.Polygon#initialize} for constructor definition\n   */fabric.Polygon=fabric.util.createClass(fabric.Polyline,/** @lends fabric.Polygon.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'polygon',/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function(ctx){if(!this.commonRender(ctx)){return;}ctx.closePath();this._renderPaintInOrder(ctx);}});/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\n   * @static\n   * @memberOf fabric.Polygon\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\n   */fabric.Polygon.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat();/**\n   * Returns {@link fabric.Polygon} instance from an SVG element\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */fabric.Polygon.fromElement=fabric.Polyline.fromElementGenerator('Polygon');/* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polygon instance from an object representation\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   * @return {void}\n   */fabric.Polygon.fromObject=function(object,callback){fabric.Object._fromObject('Polygon',object,callback,'points');};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),min=fabric.util.array.min,max=fabric.util.array.max,extend=fabric.util.object.extend,_toString=Object.prototype.toString,toFixed=fabric.util.toFixed;if(fabric.Path){fabric.warn('fabric.Path is already defined');return;}/**\n   * Path class\n   * @class fabric.Path\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}\n   * @see {@link fabric.Path#initialize} for constructor definition\n   */fabric.Path=fabric.util.createClass(fabric.Object,/** @lends fabric.Path.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'path',/**\n     * Array of path points\n     * @type Array\n     * @default\n     */path:null,cacheProperties:fabric.Object.prototype.cacheProperties.concat('path','fillRule'),stateProperties:fabric.Object.prototype.stateProperties.concat('path'),/**\n     * Constructor\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n     * @param {Object} [options] Options object\n     * @return {fabric.Path} thisArg\n     */initialize:function(path,options){options=options||{};this.callSuper('initialize',options);if(!path){path=[];}var fromArray=_toString.call(path)==='[object Array]';this.path=fabric.util.makePathSimpler(fromArray?path:fabric.util.parsePath(path));if(!this.path){return;}fabric.Polyline.prototype._setPositionDimensions.call(this,options);},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */_renderPathCommands:function(ctx){var current,// current instruction\nsubpathStartX=0,subpathStartY=0,x=0,// current x\ny=0,// current y\ncontrolX=0,// current control point x\ncontrolY=0,// current control point y\nl=-this.pathOffset.x,t=-this.pathOffset.y;ctx.beginPath();for(var i=0,len=this.path.length;i<len;++i){current=this.path[i];switch(current[0]){// first letter\ncase'L':// lineto, absolute\nx=current[1];y=current[2];ctx.lineTo(x+l,y+t);break;case'M':// moveTo, absolute\nx=current[1];y=current[2];subpathStartX=x;subpathStartY=y;ctx.moveTo(x+l,y+t);break;case'C':// bezierCurveTo, absolute\nx=current[5];y=current[6];controlX=current[3];controlY=current[4];ctx.bezierCurveTo(current[1]+l,current[2]+t,controlX+l,controlY+t,x+l,y+t);break;case'Q':// quadraticCurveTo, absolute\nctx.quadraticCurveTo(current[1]+l,current[2]+t,current[3]+l,current[4]+t);x=current[3];y=current[4];controlX=current[1];controlY=current[2];break;case'z':case'Z':x=subpathStartX;y=subpathStartY;ctx.closePath();break;}}},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */_render:function(ctx){this._renderPathCommands(ctx);this._renderPaintInOrder(ctx);},/**\n     * Returns string representation of an instance\n     * @return {String} string representation of an instance\n     */toString:function(){return'#<fabric.Path ('+this.complexity()+'): { \"top\": '+this.top+', \"left\": '+this.left+' }>';},/**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toObject:function(propertiesToInclude){return extend(this.callSuper('toObject',propertiesToInclude),{path:this.path.map(function(item){return item.slice();})});},/**\n     * Returns dataless object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toDatalessObject:function(propertiesToInclude){var o=this.toObject(['sourcePath'].concat(propertiesToInclude));if(o.sourcePath){delete o.path;}return o;},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */_toSVG:function(){var path=fabric.util.joinPath(this.path);return['<path ','COMMON_PARTS','d=\"',path,'\" stroke-linecap=\"round\" ','/>\\n'];},_getOffsetTransform:function(){var digits=fabric.Object.NUM_FRACTION_DIGITS;return' translate('+toFixed(-this.pathOffset.x,digits)+', '+toFixed(-this.pathOffset.y,digits)+')';},/**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */toClipPathSVG:function(reviver){var additionalTransform=this._getOffsetTransform();return'\\t'+this._createBaseClipPathSVGMarkup(this._toSVG(),{reviver:reviver,additionalTransform:additionalTransform});},/**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */toSVG:function(reviver){var additionalTransform=this._getOffsetTransform();return this._createBaseSVGMarkup(this._toSVG(),{reviver:reviver,additionalTransform:additionalTransform});},/* _TO_SVG_END_ */ /**\n     * Returns number representation of an instance complexity\n     * @return {Number} complexity of this instance\n     */complexity:function(){return this.path.length;},/**\n     * @private\n     */_calcDimensions:function(){var aX=[],aY=[],current,// current instruction\nsubpathStartX=0,subpathStartY=0,x=0,// current x\ny=0,// current y\nbounds;for(var i=0,len=this.path.length;i<len;++i){current=this.path[i];switch(current[0]){// first letter\ncase'L':// lineto, absolute\nx=current[1];y=current[2];bounds=[];break;case'M':// moveTo, absolute\nx=current[1];y=current[2];subpathStartX=x;subpathStartY=y;bounds=[];break;case'C':// bezierCurveTo, absolute\nbounds=fabric.util.getBoundsOfCurve(x,y,current[1],current[2],current[3],current[4],current[5],current[6]);x=current[5];y=current[6];break;case'Q':// quadraticCurveTo, absolute\nbounds=fabric.util.getBoundsOfCurve(x,y,current[1],current[2],current[1],current[2],current[3],current[4]);x=current[3];y=current[4];break;case'z':case'Z':x=subpathStartX;y=subpathStartY;break;}bounds.forEach(function(point){aX.push(point.x);aY.push(point.y);});aX.push(x);aY.push(y);}var minX=min(aX)||0,minY=min(aY)||0,maxX=max(aX)||0,maxY=max(aY)||0,deltaX=maxX-minX,deltaY=maxY-minY;return{left:minX,top:minY,width:deltaX,height:deltaY};}});/**\n   * Creates an instance of fabric.Path from an object\n   * @static\n   * @memberOf fabric.Path\n   * @param {Object} object\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */fabric.Path.fromObject=function(object,callback){if(typeof object.sourcePath==='string'){var pathUrl=object.sourcePath;fabric.loadSVGFromURL(pathUrl,function(elements){var path=elements[0];path.setOptions(object);callback&&callback(path);});}else{fabric.Object._fromObject('Path',object,callback,'path');}};/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\n   * @static\n   * @memberOf fabric.Path\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\n   */fabric.Path.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat(['d']);/**\n   * Creates an instance of fabric.Path from an SVG <path> element\n   * @static\n   * @memberOf fabric.Path\n   * @param {SVGElement} element to parse\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   */fabric.Path.fromElement=function(element,callback,options){var parsedAttributes=fabric.parseAttributes(element,fabric.Path.ATTRIBUTE_NAMES);parsedAttributes.fromSVG=true;callback(new fabric.Path(parsedAttributes.d,extend(parsedAttributes,options)));};/* _FROM_SVG_END_ */})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),min=fabric.util.array.min,max=fabric.util.array.max;if(fabric.Group){return;}/**\n   * Group class\n   * @class fabric.Group\n   * @extends fabric.Object\n   * @mixes fabric.Collection\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.Group#initialize} for constructor definition\n   */fabric.Group=fabric.util.createClass(fabric.Object,fabric.Collection,/** @lends fabric.Group.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'group',/**\n     * Width of stroke\n     * @type Number\n     * @default\n     */strokeWidth:0,/**\n     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets\n     * @type Boolean\n     * @default\n     */subTargetCheck:false,/**\n     * Groups are container, do not render anything on theyr own, ence no cache properties\n     * @type Array\n     * @default\n     */cacheProperties:[],/**\n     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still\n     * available setting this boolean to true.\n     * @type Boolean\n     * @since 2.0.0\n     * @default\n     */useSetOnGroup:false,/**\n     * Constructor\n     * @param {Object} objects Group objects\n     * @param {Object} [options] Options object\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\n     * @return {Object} thisArg\n     */initialize:function(objects,options,isAlreadyGrouped){options=options||{};this._objects=[];// if objects enclosed in a group have been grouped already,\n// we cannot change properties of objects.\n// Thus we need to set options to group without objects,\nisAlreadyGrouped&&this.callSuper('initialize',options);this._objects=objects||[];for(var i=this._objects.length;i--;){this._objects[i].group=this;}if(!isAlreadyGrouped){var center=options&&options.centerPoint;// we want to set origins before calculating the bounding box.\n// so that the topleft can be set with that in mind.\n// if specific top and left are passed, are overwritten later\n// with the callSuper('initialize', options)\nif(options.originX!==undefined){this.originX=options.originX;}if(options.originY!==undefined){this.originY=options.originY;}// if coming from svg i do not want to calc bounds.\n// i assume width and height are passed along options\ncenter||this._calcBounds();this._updateObjectsCoords(center);delete options.centerPoint;this.callSuper('initialize',options);}else{this._updateObjectsACoords();}this.setCoords();},/**\n     * @private\n     */_updateObjectsACoords:function(){var skipControls=true;for(var i=this._objects.length;i--;){this._objects[i].setCoords(skipControls);}},/**\n     * @private\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\n     */_updateObjectsCoords:function(center){var center=center||this.getCenterPoint();for(var i=this._objects.length;i--;){this._updateObjectCoords(this._objects[i],center);}},/**\n     * @private\n     * @param {Object} object\n     * @param {fabric.Point} center, current center of group.\n     */_updateObjectCoords:function(object,center){var objectLeft=object.left,objectTop=object.top,skipControls=true;object.set({left:objectLeft-center.x,top:objectTop-center.y});object.group=this;object.setCoords(skipControls);},/**\n     * Returns string represenation of a group\n     * @return {String}\n     */toString:function(){return'#<fabric.Group: ('+this.complexity()+')>';},/**\n     * Adds an object to a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */addWithUpdate:function(object){var nested=!!this.group;this._restoreObjectsState();fabric.util.resetObjectTransform(this);if(object){if(nested){// if this group is inside another group, we need to pre transform the object\nfabric.util.removeTransformFromObject(object,this.group.calcTransformMatrix());}this._objects.push(object);object.group=this;object._set('canvas',this.canvas);}this._calcBounds();this._updateObjectsCoords();this.dirty=true;if(nested){this.group.addWithUpdate();}else{this.setCoords();}return this;},/**\n     * Removes an object from a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */removeWithUpdate:function(object){this._restoreObjectsState();fabric.util.resetObjectTransform(this);this.remove(object);this._calcBounds();this._updateObjectsCoords();this.setCoords();this.dirty=true;return this;},/**\n     * @private\n     */_onObjectAdded:function(object){this.dirty=true;object.group=this;object._set('canvas',this.canvas);},/**\n     * @private\n     */_onObjectRemoved:function(object){this.dirty=true;delete object.group;},/**\n     * @private\n     */_set:function(key,value){var i=this._objects.length;if(this.useSetOnGroup){while(i--){this._objects[i].setOnGroup(key,value);}}if(key==='canvas'){while(i--){this._objects[i]._set(key,value);}}fabric.Object.prototype._set.call(this,key,value);},/**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toObject:function(propertiesToInclude){var _includeDefaultValues=this.includeDefaultValues;var objsToObject=this._objects.filter(function(obj){return!obj.excludeFromExport;}).map(function(obj){var originalDefaults=obj.includeDefaultValues;obj.includeDefaultValues=_includeDefaultValues;var _obj=obj.toObject(propertiesToInclude);obj.includeDefaultValues=originalDefaults;return _obj;});var obj=fabric.Object.prototype.toObject.call(this,propertiesToInclude);obj.objects=objsToObject;return obj;},/**\n     * Returns object representation of an instance, in dataless mode.\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toDatalessObject:function(propertiesToInclude){var objsToObject,sourcePath=this.sourcePath;if(sourcePath){objsToObject=sourcePath;}else{var _includeDefaultValues=this.includeDefaultValues;objsToObject=this._objects.map(function(obj){var originalDefaults=obj.includeDefaultValues;obj.includeDefaultValues=_includeDefaultValues;var _obj=obj.toDatalessObject(propertiesToInclude);obj.includeDefaultValues=originalDefaults;return _obj;});}var obj=fabric.Object.prototype.toDatalessObject.call(this,propertiesToInclude);obj.objects=objsToObject;return obj;},/**\n     * Renders instance on a given context\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\n     */render:function(ctx){this._transformDone=true;this.callSuper('render',ctx);this._transformDone=false;},/**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group is already cached.\n     * @return {Boolean}\n     */shouldCache:function(){var ownCache=fabric.Object.prototype.shouldCache.call(this);if(ownCache){for(var i=0,len=this._objects.length;i<len;i++){if(this._objects[i].willDrawShadow()){this.ownCaching=false;return false;}}}return ownCache;},/**\n     * Check if this object or a child object will cast a shadow\n     * @return {Boolean}\n     */willDrawShadow:function(){if(fabric.Object.prototype.willDrawShadow.call(this)){return true;}for(var i=0,len=this._objects.length;i<len;i++){if(this._objects[i].willDrawShadow()){return true;}}return false;},/**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */isOnACache:function(){return this.ownCaching||this.group&&this.group.isOnACache();},/**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */drawObject:function(ctx){for(var i=0,len=this._objects.length;i<len;i++){this._objects[i].render(ctx);}this._drawClipPath(ctx);},/**\n     * Check if cache is dirty\n     */isCacheDirty:function(skipCanvas){if(this.callSuper('isCacheDirty',skipCanvas)){return true;}if(!this.statefullCache){return false;}for(var i=0,len=this._objects.length;i<len;i++){if(this._objects[i].isCacheDirty(true)){if(this._cacheCanvas){// if this group has not a cache canvas there is nothing to clean\nvar x=this.cacheWidth/this.zoomX,y=this.cacheHeight/this.zoomY;this._cacheContext.clearRect(-x/2,-y/2,x,y);}return true;}}return false;},/**\n     * Restores original state of each of group objects (original state is that which was before group was created).\n     * if the nested boolean is true, the original state will be restored just for the\n     * first group and not for all the group chain\n     * @private\n     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */_restoreObjectsState:function(){var groupMatrix=this.calcOwnMatrix();this._objects.forEach(function(object){// instead of using _this = this;\nfabric.util.addTransformToObject(object,groupMatrix);delete object.group;object.setCoords();});return this;},/**\n     * Realises the transform from this group onto the supplied object\n     * i.e. it tells you what would happen if the supplied object was in\n     * the group, and then the group was destroyed. It mutates the supplied\n     * object.\n     * Warning: this method is not useful anymore, it has been kept to no break the api.\n     * is not used in the fabricJS codebase\n     * this method will be reduced to using the utility.\n     * @private\n     * @deprecated\n     * @param {fabric.Object} object\n     * @param {Array} parentMatrix parent transformation\n     * @return {fabric.Object} transformedObject\n     */realizeTransform:function(object,parentMatrix){fabric.util.addTransformToObject(object,parentMatrix);return object;},/**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */destroy:function(){// when group is destroyed objects needs to get a repaint to be eventually\n// displayed on canvas.\nthis._objects.forEach(function(object){object.set('dirty',true);});return this._restoreObjectsState();},/**\n     * make a group an active selection, remove the group from canvas\n     * the group has to be on canvas for this to work.\n     * @return {fabric.ActiveSelection} thisArg\n     * @chainable\n     */toActiveSelection:function(){if(!this.canvas){return;}var objects=this._objects,canvas=this.canvas;this._objects=[];var options=this.toObject();delete options.objects;var activeSelection=new fabric.ActiveSelection([]);activeSelection.set(options);activeSelection.type='activeSelection';canvas.remove(this);objects.forEach(function(object){object.group=activeSelection;object.dirty=true;canvas.add(object);});activeSelection.canvas=canvas;activeSelection._objects=objects;canvas._activeObject=activeSelection;activeSelection.setCoords();return activeSelection;},/**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ungroupOnCanvas:function(){return this._restoreObjectsState();},/**\n     * Sets coordinates of all objects inside group\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */setObjectsCoords:function(){var skipControls=true;this.forEachObject(function(object){object.setCoords(skipControls);});return this;},/**\n     * @private\n     */_calcBounds:function(onlyWidthHeight){var aX=[],aY=[],o,prop,coords,props=['tr','br','bl','tl'],i=0,iLen=this._objects.length,j,jLen=props.length;for(;i<iLen;++i){o=this._objects[i];coords=o.calcACoords();for(j=0;j<jLen;j++){prop=props[j];aX.push(coords[prop].x);aY.push(coords[prop].y);}o.aCoords=coords;}this._getBounds(aX,aY,onlyWidthHeight);},/**\n     * @private\n     */_getBounds:function(aX,aY,onlyWidthHeight){var minXY=new fabric.Point(min(aX),min(aY)),maxXY=new fabric.Point(max(aX),max(aY)),top=minXY.y||0,left=minXY.x||0,width=maxXY.x-minXY.x||0,height=maxXY.y-minXY.y||0;this.width=width;this.height=height;if(!onlyWidthHeight){// the bounding box always finds the topleft most corner.\n// whatever is the group origin, we set up here the left/top position.\nthis.setPositionByOrigin({x:left,y:top},'left','top');}},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */_toSVG:function(reviver){var svgString=['<g ','COMMON_PARTS',' >\\n'];for(var i=0,len=this._objects.length;i<len;i++){svgString.push('\\t\\t',this._objects[i].toSVG(reviver));}svgString.push('</g>\\n');return svgString;},/**\n     * Returns styles-string for svg-export, specific version for group\n     * @return {String}\n     */getSvgStyles:function(){var opacity=typeof this.opacity!=='undefined'&&this.opacity!==1?'opacity: '+this.opacity+';':'',visibility=this.visible?'':' visibility: hidden;';return[opacity,this.getSvgFilter(),visibility].join('');},/**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */toClipPathSVG:function(reviver){var svgString=[];for(var i=0,len=this._objects.length;i<len;i++){svgString.push('\\t',this._objects[i].toClipPathSVG(reviver));}return this._createBaseClipPathSVGMarkup(svgString,{reviver:reviver});}/* _TO_SVG_END_ */});/**\n   * Returns {@link fabric.Group} instance from an object representation\n   * @static\n   * @memberOf fabric.Group\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an group instance is created\n   */fabric.Group.fromObject=function(object,callback){var objects=object.objects,options=fabric.util.object.clone(object,true);delete options.objects;if(typeof objects==='string'){// it has to be an url or something went wrong.\nfabric.loadSVGFromURL(objects,function(elements){var group=fabric.util.groupSVGElements(elements,object,objects);group.set(options);callback&&callback(group);});return;}fabric.util.enlivenObjects(objects,function(enlivenedObjects){fabric.util.enlivenObjects([object.clipPath],function(enlivedClipPath){var options=fabric.util.object.clone(object,true);options.clipPath=enlivedClipPath[0];delete options.objects;callback&&callback(new fabric.Group(enlivenedObjects,options,true));});});};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={});if(fabric.ActiveSelection){return;}/**\n   * Group class\n   * @class fabric.ActiveSelection\n   * @extends fabric.Group\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.ActiveSelection#initialize} for constructor definition\n   */fabric.ActiveSelection=fabric.util.createClass(fabric.Group,/** @lends fabric.ActiveSelection.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'activeSelection',/**\n     * Constructor\n     * @param {Object} objects ActiveSelection objects\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */initialize:function(objects,options){options=options||{};this._objects=objects||[];for(var i=this._objects.length;i--;){this._objects[i].group=this;}if(options.originX){this.originX=options.originX;}if(options.originY){this.originY=options.originY;}this._calcBounds();this._updateObjectsCoords();fabric.Object.prototype.initialize.call(this,options);this.setCoords();},/**\n     * Change te activeSelection to a normal group,\n     * High level function that automatically adds it to canvas as\n     * active object. no events fired.\n     * @since 2.0.0\n     * @return {fabric.Group}\n     */toGroup:function(){var objects=this._objects.concat();this._objects=[];var options=fabric.Object.prototype.toObject.call(this);var newGroup=new fabric.Group([]);delete options.type;newGroup.set(options);objects.forEach(function(object){object.canvas.remove(object);object.group=newGroup;});newGroup._objects=objects;if(!this.canvas){return newGroup;}var canvas=this.canvas;canvas.add(newGroup);canvas._activeObject=newGroup;newGroup.setCoords();return newGroup;},/**\n     * If returns true, deselection is cancelled.\n     * @since 2.0.0\n     * @return {Boolean} [cancel]\n     */onDeselect:function(){this.destroy();return false;},/**\n     * Returns string representation of a group\n     * @return {String}\n     */toString:function(){return'#<fabric.ActiveSelection: ('+this.complexity()+')>';},/**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * @return {Boolean}\n     */shouldCache:function(){return false;},/**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */isOnACache:function(){return false;},/**\n     * Renders controls and borders for the object\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     * @param {Object} [childrenOverride] properties to override the children overrides\n     */_renderControls:function(ctx,styleOverride,childrenOverride){ctx.save();ctx.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1;this.callSuper('_renderControls',ctx,styleOverride);childrenOverride=childrenOverride||{};if(typeof childrenOverride.hasControls==='undefined'){childrenOverride.hasControls=false;}childrenOverride.forActiveSelection=true;for(var i=0,len=this._objects.length;i<len;i++){this._objects[i]._renderControls(ctx,childrenOverride);}ctx.restore();}});/**\n   * Returns {@link fabric.ActiveSelection} instance from an object representation\n   * @static\n   * @memberOf fabric.ActiveSelection\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created\n   */fabric.ActiveSelection.fromObject=function(object,callback){fabric.util.enlivenObjects(object.objects,function(enlivenedObjects){delete object.objects;callback&&callback(new fabric.ActiveSelection(enlivenedObjects,object,true));});};})( true?exports:0);(function(global){'use strict';var extend=fabric.util.object.extend;if(!global.fabric){global.fabric={};}if(global.fabric.Image){fabric.warn('fabric.Image is already defined.');return;}/**\n   * Image class\n   * @class fabric.Image\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}\n   * @see {@link fabric.Image#initialize} for constructor definition\n   */fabric.Image=fabric.util.createClass(fabric.Object,/** @lends fabric.Image.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'image',/**\n     * Width of a stroke.\n     * For image quality a stroke multiple of 2 gives better results.\n     * @type Number\n     * @default\n     */strokeWidth:0,/**\n     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.\n     * This allows for relative urls as image src.\n     * @since 2.7.0\n     * @type Boolean\n     * @default\n     */srcFromAttribute:false,/**\n     * private\n     * contains last value of scaleX to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */_lastScaleX:1,/**\n     * private\n     * contains last value of scaleY to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */_lastScaleY:1,/**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */_filterScalingX:1,/**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */_filterScalingY:1,/**\n     * minimum scale factor under which any resizeFilter is triggered to resize the image\n     * 0 will disable the automatic resize. 1 will trigger automatically always.\n     * number bigger than 1 are not implemented yet.\n     * @type Number\n     */minimumScaleTrigger:0.5,/**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */stateProperties:fabric.Object.prototype.stateProperties.concat('cropX','cropY'),/**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */cacheProperties:fabric.Object.prototype.cacheProperties.concat('cropX','cropY'),/**\n     * key used to retrieve the texture representing this image\n     * @since 2.0.0\n     * @type String\n     * @default\n     */cacheKey:'',/**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */cropX:0,/**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */cropY:0,/**\n     * Indicates whether this canvas will use image smoothing when painting this image.\n     * Also influence if the cacheCanvas for this image uses imageSmoothing\n     * @since 4.0.0-beta.11\n     * @type Boolean\n     * @default\n     */imageSmoothing:true,/**\n     * Constructor\n     * Image can be initialized with any canvas drawable or a string.\n     * The string should be a url and will be loaded as an image.\n     * Canvas and Image element work out of the box, while videos require extra code to work.\n     * Please check video element events for seeking.\n     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element\n     * @param {Object} [options] Options object\n     * @param {function} [callback] callback function to call after eventual filters applied.\n     * @return {fabric.Image} thisArg\n     */initialize:function(element,options){options||(options={});this.filters=[];this.cacheKey='texture'+fabric.Object.__uid++;this.callSuper('initialize',options);this._initElement(element,options);},/**\n     * Returns image element which this instance if based on\n     * @return {HTMLImageElement} Image element\n     */getElement:function(){return this._element||{};},/**\n     * Sets image element for this instance to a specified one.\n     * If filters defined they are applied to new image.\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\n     * @param {HTMLImageElement} element\n     * @param {Object} [options] Options object\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */setElement:function(element,options){this.removeTexture(this.cacheKey);this.removeTexture(this.cacheKey+'_filtered');this._element=element;this._originalElement=element;this._initConfig(options);if(this.filters.length!==0){this.applyFilters();}// resizeFilters work on the already filtered copy.\n// we need to apply resizeFilters AFTER normal filters.\n// applyResizeFilters is run more often than normal filters\n// and is triggered by user interactions rather than dev code\nif(this.resizeFilter){this.applyResizeFilters();}return this;},/**\n     * Delete a single texture if in webgl mode\n     */removeTexture:function(key){var backend=fabric.filterBackend;if(backend&&backend.evictCachesForKey){backend.evictCachesForKey(key);}},/**\n     * Delete textures, reference to elements and eventually JSDOM cleanup\n     */dispose:function(){this.removeTexture(this.cacheKey);this.removeTexture(this.cacheKey+'_filtered');this._cacheContext=undefined;['_originalElement','_element','_filteredEl','_cacheCanvas'].forEach(function(element){fabric.util.cleanUpJsdomNode(this[element]);this[element]=undefined;}.bind(this));},/**\n     * Get the crossOrigin value (of the corresponding image element)\n     */getCrossOrigin:function(){return this._originalElement&&(this._originalElement.crossOrigin||null);},/**\n     * Returns original size of an image\n     * @return {Object} Object with \"width\" and \"height\" properties\n     */getOriginalSize:function(){var element=this.getElement();return{width:element.naturalWidth||element.width,height:element.naturalHeight||element.height};},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_stroke:function(ctx){if(!this.stroke||this.strokeWidth===0){return;}var w=this.width/2,h=this.height/2;ctx.beginPath();ctx.moveTo(-w,-h);ctx.lineTo(w,-h);ctx.lineTo(w,h);ctx.lineTo(-w,h);ctx.lineTo(-w,-h);ctx.closePath();},/**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */toObject:function(propertiesToInclude){var filters=[];this.filters.forEach(function(filterObj){if(filterObj){filters.push(filterObj.toObject());}});var object=extend(this.callSuper('toObject',['cropX','cropY'].concat(propertiesToInclude)),{src:this.getSrc(),crossOrigin:this.getCrossOrigin(),filters:filters});if(this.resizeFilter){object.resizeFilter=this.resizeFilter.toObject();}return object;},/**\n     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.\n     * @return {Boolean}\n     */hasCrop:function(){return this.cropX||this.cropY||this.width<this._element.width||this.height<this._element.height;},/* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */_toSVG:function(){var svgString=[],imageMarkup=[],strokeSvg,element=this._element,x=-this.width/2,y=-this.height/2,clipPath='',imageRendering='';if(!element){return[];}if(this.hasCrop()){var clipPathId=fabric.Object.__uid++;svgString.push('<clipPath id=\"imageCrop_'+clipPathId+'\">\\n','\\t<rect x=\"'+x+'\" y=\"'+y+'\" width=\"'+this.width+'\" height=\"'+this.height+'\" />\\n','</clipPath>\\n');clipPath=' clip-path=\"url(#imageCrop_'+clipPathId+')\" ';}if(!this.imageSmoothing){imageRendering='\" image-rendering=\"optimizeSpeed';}imageMarkup.push('\\t<image ','COMMON_PARTS','xlink:href=\"',this.getSvgSrc(true),'\" x=\"',x-this.cropX,'\" y=\"',y-this.cropY,// we're essentially moving origin of transformation from top/left corner to the center of the shape\n// by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\n// so that object's center aligns with container's left/top\n'\" width=\"',element.width||element.naturalWidth,'\" height=\"',element.height||element.height,imageRendering,'\"',clipPath,'></image>\\n');if(this.stroke||this.strokeDashArray){var origFill=this.fill;this.fill=null;strokeSvg=['\\t<rect ','x=\"',x,'\" y=\"',y,'\" width=\"',this.width,'\" height=\"',this.height,'\" style=\"',this.getSvgStyles(),'\"/>\\n'];this.fill=origFill;}if(this.paintFirst!=='fill'){svgString=svgString.concat(strokeSvg,imageMarkup);}else{svgString=svgString.concat(imageMarkup,strokeSvg);}return svgString;},/* _TO_SVG_END_ */ /**\n     * Returns source of an image\n     * @param {Boolean} filtered indicates if the src is needed for svg\n     * @return {String} Source of an image\n     */getSrc:function(filtered){var element=filtered?this._element:this._originalElement;if(element){if(element.toDataURL){return element.toDataURL();}if(this.srcFromAttribute){return element.getAttribute('src');}else{return element.src;}}else{return this.src||'';}},/**\n     * Sets source of an image\n     * @param {String} src Source string (URL)\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\n     * @param {Object} [options] Options object\n     * @param {String} [options.crossOrigin] crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */setSrc:function(src,callback,options){fabric.util.loadImage(src,function(img,isError){this.setElement(img,options);this._setWidthHeight();callback&&callback(this,isError);},this,options&&options.crossOrigin);return this;},/**\n     * Returns string representation of an instance\n     * @return {String} String representation of an instance\n     */toString:function(){return'#<fabric.Image: { src: \"'+this.getSrc()+'\" }>';},applyResizeFilters:function(){var filter=this.resizeFilter,minimumScale=this.minimumScaleTrigger,objectScale=this.getTotalObjectScaling(),scaleX=objectScale.scaleX,scaleY=objectScale.scaleY,elementToFilter=this._filteredEl||this._originalElement;if(this.group){this.set('dirty',true);}if(!filter||scaleX>minimumScale&&scaleY>minimumScale){this._element=elementToFilter;this._filterScalingX=1;this._filterScalingY=1;this._lastScaleX=scaleX;this._lastScaleY=scaleY;return;}if(!fabric.filterBackend){fabric.filterBackend=fabric.initFilterBackend();}var canvasEl=fabric.util.createCanvasElement(),cacheKey=this._filteredEl?this.cacheKey+'_filtered':this.cacheKey,sourceWidth=elementToFilter.width,sourceHeight=elementToFilter.height;canvasEl.width=sourceWidth;canvasEl.height=sourceHeight;this._element=canvasEl;this._lastScaleX=filter.scaleX=scaleX;this._lastScaleY=filter.scaleY=scaleY;fabric.filterBackend.applyFilters([filter],elementToFilter,sourceWidth,sourceHeight,this._element,cacheKey);this._filterScalingX=canvasEl.width/this._originalElement.width;this._filterScalingY=canvasEl.height/this._originalElement.height;},/**\n     * Applies filters assigned to this image (from \"filters\" array) or from filter param\n     * @method applyFilters\n     * @param {Array} filters to be applied\n     * @param {Boolean} forResizing specify if the filter operation is a resize operation\n     * @return {thisArg} return the fabric.Image object\n     * @chainable\n     */applyFilters:function(filters){filters=filters||this.filters||[];filters=filters.filter(function(filter){return filter&&!filter.isNeutralState();});this.set('dirty',true);// needs to clear out or WEBGL will not resize correctly\nthis.removeTexture(this.cacheKey+'_filtered');if(filters.length===0){this._element=this._originalElement;this._filteredEl=null;this._filterScalingX=1;this._filterScalingY=1;return this;}var imgElement=this._originalElement,sourceWidth=imgElement.naturalWidth||imgElement.width,sourceHeight=imgElement.naturalHeight||imgElement.height;if(this._element===this._originalElement){// if the element is the same we need to create a new element\nvar canvasEl=fabric.util.createCanvasElement();canvasEl.width=sourceWidth;canvasEl.height=sourceHeight;this._element=canvasEl;this._filteredEl=canvasEl;}else{// clear the existing element to get new filter data\n// also dereference the eventual resized _element\nthis._element=this._filteredEl;this._filteredEl.getContext('2d').clearRect(0,0,sourceWidth,sourceHeight);// we also need to resize again at next renderAll, so remove saved _lastScaleX/Y\nthis._lastScaleX=1;this._lastScaleY=1;}if(!fabric.filterBackend){fabric.filterBackend=fabric.initFilterBackend();}fabric.filterBackend.applyFilters(filters,this._originalElement,sourceWidth,sourceHeight,this._element,this.cacheKey);if(this._originalElement.width!==this._element.width||this._originalElement.height!==this._element.height){this._filterScalingX=this._element.width/this._originalElement.width;this._filterScalingY=this._element.height/this._originalElement.height;}return this;},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function(ctx){fabric.util.setImageSmoothing(ctx,this.imageSmoothing);if(this.isMoving!==true&&this.resizeFilter&&this._needsResize()){this.applyResizeFilters();}this._stroke(ctx);this._renderPaintInOrder(ctx);},/**\n     * Paint the cached copy of the object on the target context.\n     * it will set the imageSmoothing for the draw operation\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */drawCacheOnCanvas:function(ctx){fabric.util.setImageSmoothing(ctx,this.imageSmoothing);fabric.Object.prototype.drawCacheOnCanvas.call(this,ctx);},/**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * This is the special image version where we would like to avoid caching where possible.\n     * Essentially images do not benefit from caching. They may require caching, and in that\n     * case we do it. Also caching an image usually ends in a loss of details.\n     * A full performance audit should be done.\n     * @return {Boolean}\n     */shouldCache:function(){return this.needsItsOwnCache();},_renderFill:function(ctx){var elementToDraw=this._element;if(!elementToDraw){return;}var scaleX=this._filterScalingX,scaleY=this._filterScalingY,w=this.width,h=this.height,min=Math.min,max=Math.max,// crop values cannot be lesser than 0.\ncropX=max(this.cropX,0),cropY=max(this.cropY,0),elWidth=elementToDraw.naturalWidth||elementToDraw.width,elHeight=elementToDraw.naturalHeight||elementToDraw.height,sX=cropX*scaleX,sY=cropY*scaleY,// the width height cannot exceed element width/height, starting from the crop offset.\nsW=min(w*scaleX,elWidth-sX),sH=min(h*scaleY,elHeight-sY),x=-w/2,y=-h/2,maxDestW=min(w,elWidth/scaleX-cropX),maxDestH=min(h,elHeight/scaleY-cropY);elementToDraw&&ctx.drawImage(elementToDraw,sX,sY,sW,sH,x,y,maxDestW,maxDestH);},/**\n     * needed to check if image needs resize\n     * @private\n     */_needsResize:function(){var scale=this.getTotalObjectScaling();return scale.scaleX!==this._lastScaleX||scale.scaleY!==this._lastScaleY;},/**\n     * @private\n     */_resetWidthHeight:function(){this.set(this.getOriginalSize());},/**\n     * The Image class's initialization method. This method is automatically\n     * called by the constructor.\n     * @private\n     * @param {HTMLImageElement|String} element The element representing the image\n     * @param {Object} [options] Options object\n     */_initElement:function(element,options){this.setElement(fabric.util.getById(element),options);fabric.util.addClass(this.getElement(),fabric.Image.CSS_CANVAS);},/**\n     * @private\n     * @param {Object} [options] Options object\n     */_initConfig:function(options){options||(options={});this.setOptions(options);this._setWidthHeight(options);},/**\n     * @private\n     * @param {Array} filters to be initialized\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\n     */_initFilters:function(filters,callback){if(filters&&filters.length){fabric.util.enlivenObjects(filters,function(enlivenedObjects){callback&&callback(enlivenedObjects);},'fabric.Image.filters');}else{callback&&callback();}},/**\n     * @private\n     * Set the width and the height of the image object, using the element or the\n     * options.\n     * @param {Object} [options] Object with width/height properties\n     */_setWidthHeight:function(options){options||(options={});var el=this.getElement();this.width=options.width||el.naturalWidth||el.width||0;this.height=options.height||el.naturalHeight||el.height||0;},/**\n     * Calculate offset for center and scale factor for the image in order to respect\n     * the preserveAspectRatio attribute\n     * @private\n     * @return {Object}\n     */parsePreserveAspectRatioAttribute:function(){var pAR=fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio||''),rWidth=this._element.width,rHeight=this._element.height,scaleX=1,scaleY=1,offsetLeft=0,offsetTop=0,cropX=0,cropY=0,offset,pWidth=this.width,pHeight=this.height,parsedAttributes={width:pWidth,height:pHeight};if(pAR&&(pAR.alignX!=='none'||pAR.alignY!=='none')){if(pAR.meetOrSlice==='meet'){scaleX=scaleY=fabric.util.findScaleToFit(this._element,parsedAttributes);offset=(pWidth-rWidth*scaleX)/2;if(pAR.alignX==='Min'){offsetLeft=-offset;}if(pAR.alignX==='Max'){offsetLeft=offset;}offset=(pHeight-rHeight*scaleY)/2;if(pAR.alignY==='Min'){offsetTop=-offset;}if(pAR.alignY==='Max'){offsetTop=offset;}}if(pAR.meetOrSlice==='slice'){scaleX=scaleY=fabric.util.findScaleToCover(this._element,parsedAttributes);offset=rWidth-pWidth/scaleX;if(pAR.alignX==='Mid'){cropX=offset/2;}if(pAR.alignX==='Max'){cropX=offset;}offset=rHeight-pHeight/scaleY;if(pAR.alignY==='Mid'){cropY=offset/2;}if(pAR.alignY==='Max'){cropY=offset;}rWidth=pWidth/scaleX;rHeight=pHeight/scaleY;}}else{scaleX=pWidth/rWidth;scaleY=pHeight/rHeight;}return{width:rWidth,height:rHeight,scaleX:scaleX,scaleY:scaleY,offsetLeft:offsetLeft,offsetTop:offsetTop,cropX:cropX,cropY:cropY};}});/**\n   * Default CSS class name for canvas\n   * @static\n   * @type String\n   * @default\n   */fabric.Image.CSS_CANVAS='canvas-img';/**\n   * Alias for getSrc\n   * @static\n   */fabric.Image.prototype.getSvgSrc=fabric.Image.prototype.getSrc;/**\n   * Creates an instance of fabric.Image from its object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} callback Callback to invoke when an image instance is created\n   */fabric.Image.fromObject=function(_object,callback){var object=fabric.util.object.clone(_object);fabric.util.loadImage(object.src,function(img,isError){if(isError){callback&&callback(null,true);return;}fabric.Image.prototype._initFilters.call(object,object.filters,function(filters){object.filters=filters||[];fabric.Image.prototype._initFilters.call(object,[object.resizeFilter],function(resizeFilters){object.resizeFilter=resizeFilters[0];fabric.util.enlivenObjects([object.clipPath],function(enlivedProps){object.clipPath=enlivedProps[0];var image=new fabric.Image(img,object);callback(image,false);});});});},null,object.crossOrigin);};/**\n   * Creates an instance of fabric.Image from an URL string\n   * @static\n   * @param {String} url URL to create an image from\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.\n   * @param {Object} [imgOptions] Options object\n   */fabric.Image.fromURL=function(url,callback,imgOptions){fabric.util.loadImage(url,function(img,isError){callback&&callback(new fabric.Image(img,imgOptions),isError);},null,imgOptions&&imgOptions.crossOrigin);};/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\n   * @static\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\n   */fabric.Image.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href crossOrigin image-rendering'.split(' '));/**\n   * Returns {@link fabric.Image} instance from an SVG element\n   * @static\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} callback Callback to execute when fabric.Image object is created\n   * @return {fabric.Image} Instance of fabric.Image\n   */fabric.Image.fromElement=function(element,callback,options){var parsedAttributes=fabric.parseAttributes(element,fabric.Image.ATTRIBUTE_NAMES);fabric.Image.fromURL(parsedAttributes['xlink:href'],callback,extend(options?fabric.util.object.clone(options):{},parsedAttributes));};/* _FROM_SVG_END_ */})( true?exports:0);fabric.util.object.extend(fabric.Object.prototype,/** @lends fabric.Object.prototype */{/**\n   * @private\n   * @return {Number} angle value\n   */_getAngleValueForStraighten:function(){var angle=this.angle%360;if(angle>0){return Math.round((angle-1)/90)*90;}return Math.round(angle/90)*90;},/**\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */straighten:function(){this.rotate(this._getAngleValueForStraighten());return this;},/**\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\n   * @param {Object} callbacks Object with callback functions\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */fxStraighten:function(callbacks){callbacks=callbacks||{};var empty=function(){},onComplete=callbacks.onComplete||empty,onChange=callbacks.onChange||empty,_this=this;fabric.util.animate({startValue:this.get('angle'),endValue:this._getAngleValueForStraighten(),duration:this.FX_DURATION,onChange:function(value){_this.rotate(value);onChange();},onComplete:function(){_this.setCoords();onComplete();}});return this;}});fabric.util.object.extend(fabric.StaticCanvas.prototype,/** @lends fabric.StaticCanvas.prototype */{/**\n   * Straightens object, then rerenders canvas\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */straightenObject:function(object){object.straighten();this.requestRenderAll();return this;},/**\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */fxStraightenObject:function(object){object.fxStraighten({onChange:this.requestRenderAllBound});return this;}});(function(){'use strict';/**\n   * Tests if webgl supports certain precision\n   * @param {WebGL} Canvas WebGL context to test on\n   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'\n   * @returns {Boolean} Whether the user's browser WebGL supports given precision.\n   */function testPrecision(gl,precision){var fragmentSource='precision '+precision+' float;\\nvoid main(){}';var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fragmentShader,fragmentSource);gl.compileShader(fragmentShader);if(!gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS)){return false;}return true;}/**\n   * Indicate whether this filtering backend is supported by the user's browser.\n   * @param {Number} tileSize check if the tileSize is supported\n   * @returns {Boolean} Whether the user's browser supports WebGL.\n   */fabric.isWebglSupported=function(tileSize){if(fabric.isLikelyNode){return false;}tileSize=tileSize||fabric.WebglFilterBackend.prototype.tileSize;var canvas=document.createElement('canvas');var gl=canvas.getContext('webgl')||canvas.getContext('experimental-webgl');var isSupported=false;// eslint-disable-next-line\nif(gl){fabric.maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);isSupported=fabric.maxTextureSize>=tileSize;var precisions=['highp','mediump','lowp'];for(var i=0;i<3;i++){if(testPrecision(gl,precisions[i])){fabric.webGlPrecision=precisions[i];break;};}}this.isSupported=isSupported;return isSupported;};fabric.WebglFilterBackend=WebglFilterBackend;/**\n   * WebGL filter backend.\n   */function WebglFilterBackend(options){if(options&&options.tileSize){this.tileSize=options.tileSize;}this.setupGLContext(this.tileSize,this.tileSize);this.captureGPUInfo();};WebglFilterBackend.prototype=/** @lends fabric.WebglFilterBackend.prototype */{tileSize:2048,/**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/resources:{},/**\n     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.\n     */setupGLContext:function(width,height){this.dispose();this.createWebGLCanvas(width,height);// eslint-disable-next-line\nthis.aPosition=new Float32Array([0,0,0,1,1,0,1,1]);this.chooseFastestCopyGLTo2DMethod(width,height);},/**\n     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using\n     * putImageData is faster than drawImage for that specific operation.\n     */chooseFastestCopyGLTo2DMethod:function(width,height){var canMeasurePerf=typeof window.performance!=='undefined',canUseImageData;try{new ImageData(1,1);canUseImageData=true;}catch(e){canUseImageData=false;}// eslint-disable-next-line no-undef\nvar canUseArrayBuffer=typeof ArrayBuffer!=='undefined';// eslint-disable-next-line no-undef\nvar canUseUint8Clamped=typeof Uint8ClampedArray!=='undefined';if(!(canMeasurePerf&&canUseImageData&&canUseArrayBuffer&&canUseUint8Clamped)){return;}var targetCanvas=fabric.util.createCanvasElement();// eslint-disable-next-line no-undef\nvar imageBuffer=new ArrayBuffer(width*height*4);if(fabric.forceGLPutImageData){this.imageBuffer=imageBuffer;this.copyGLTo2D=copyGLTo2DPutImageData;return;}var testContext={imageBuffer:imageBuffer,destinationWidth:width,destinationHeight:height,targetCanvas:targetCanvas};var startTime,drawImageTime,putImageDataTime;targetCanvas.width=width;targetCanvas.height=height;startTime=window.performance.now();copyGLTo2DDrawImage.call(testContext,this.gl,testContext);drawImageTime=window.performance.now()-startTime;startTime=window.performance.now();copyGLTo2DPutImageData.call(testContext,this.gl,testContext);putImageDataTime=window.performance.now()-startTime;if(drawImageTime>putImageDataTime){this.imageBuffer=imageBuffer;this.copyGLTo2D=copyGLTo2DPutImageData;}else{this.copyGLTo2D=copyGLTo2DDrawImage;}},/**\n     * Create a canvas element and associated WebGL context and attaches them as\n     * class properties to the GLFilterBackend class.\n     */createWebGLCanvas:function(width,height){var canvas=fabric.util.createCanvasElement();canvas.width=width;canvas.height=height;var glOptions={alpha:true,premultipliedAlpha:false,depth:false,stencil:false,antialias:false},gl=canvas.getContext('webgl',glOptions);if(!gl){gl=canvas.getContext('experimental-webgl',glOptions);}if(!gl){return;}gl.clearColor(0,0,0,0);// this canvas can fire webglcontextlost and webglcontextrestored\nthis.canvas=canvas;this.gl=gl;},/**\n     * Attempts to apply the requested filters to the source provided, drawing the filtered output\n     * to the provided target canvas.\n     *\n     * @param {Array} filters The filters to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.\n     * @param {Number} width The width of the source input.\n     * @param {Number} height The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If\n     * omitted, caching will be skipped.\n     */applyFilters:function(filters,source,width,height,targetCanvas,cacheKey){var gl=this.gl;var cachedTexture;if(cacheKey){cachedTexture=this.getCachedTexture(cacheKey,source);}var pipelineState={originalWidth:source.width||source.originalWidth,originalHeight:source.height||source.originalHeight,sourceWidth:width,sourceHeight:height,destinationWidth:width,destinationHeight:height,context:gl,sourceTexture:this.createTexture(gl,width,height,!cachedTexture&&source),targetTexture:this.createTexture(gl,width,height),originalTexture:cachedTexture||this.createTexture(gl,width,height,!cachedTexture&&source),passes:filters.length,webgl:true,aPosition:this.aPosition,programCache:this.programCache,pass:0,filterBackend:this,targetCanvas:targetCanvas};var tempFbo=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,tempFbo);filters.forEach(function(filter){filter&&filter.applyTo(pipelineState);});resizeCanvasIfNeeded(pipelineState);this.copyGLTo2D(gl,pipelineState);gl.bindTexture(gl.TEXTURE_2D,null);gl.deleteTexture(pipelineState.sourceTexture);gl.deleteTexture(pipelineState.targetTexture);gl.deleteFramebuffer(tempFbo);targetCanvas.getContext('2d').setTransform(1,0,0,1,0,0);return pipelineState;},/**\n     * Detach event listeners, remove references, and clean up caches.\n     */dispose:function(){if(this.canvas){this.canvas=null;this.gl=null;}this.clearWebGLCaches();},/**\n     * Wipe out WebGL-related caches.\n     */clearWebGLCaches:function(){this.programCache={};this.textureCache={};},/**\n     * Create a WebGL texture object.\n     *\n     * Accepts specific dimensions to initialize the texture to or a source image.\n     *\n     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.\n     * @param {Number} width The width to initialize the texture at.\n     * @param {Number} height The height to initialize the texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.\n     * @returns {WebGLTexture}\n     */createTexture:function(gl,width,height,textureImageSource){var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);if(textureImageSource){gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,textureImageSource);}else{gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);}return texture;},/**\n     * Can be optionally used to get a texture from the cache array\n     *\n     * If an existing texture is not found, a new texture is created and cached.\n     *\n     * @param {String} uniqueId A cache key to use to find an existing texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the\n     * texture cache entry if one does not already exist.\n     */getCachedTexture:function(uniqueId,textureImageSource){if(this.textureCache[uniqueId]){return this.textureCache[uniqueId];}else{var texture=this.createTexture(this.gl,textureImageSource.width,textureImageSource.height,textureImageSource);this.textureCache[uniqueId]=texture;return texture;}},/**\n     * Clear out cached resources related to a source image that has been\n     * filtered previously.\n     *\n     * @param {String} cacheKey The cache key provided when the source image was filtered.\n     */evictCachesForKey:function(cacheKey){if(this.textureCache[cacheKey]){this.gl.deleteTexture(this.textureCache[cacheKey]);delete this.textureCache[cacheKey];}},copyGLTo2D:copyGLTo2DDrawImage,/**\n     * Attempt to extract GPU information strings from a WebGL context.\n     *\n     * Useful information when debugging or blacklisting specific GPUs.\n     *\n     * @returns {Object} A GPU info object with renderer and vendor strings.\n     */captureGPUInfo:function(){if(this.gpuInfo){return this.gpuInfo;}var gl=this.gl,gpuInfo={renderer:'',vendor:''};if(!gl){return gpuInfo;}var ext=gl.getExtension('WEBGL_debug_renderer_info');if(ext){var renderer=gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);var vendor=gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);if(renderer){gpuInfo.renderer=renderer.toLowerCase();}if(vendor){gpuInfo.vendor=vendor.toLowerCase();}}this.gpuInfo=gpuInfo;return gpuInfo;}};})();function resizeCanvasIfNeeded(pipelineState){var targetCanvas=pipelineState.targetCanvas,width=targetCanvas.width,height=targetCanvas.height,dWidth=pipelineState.destinationWidth,dHeight=pipelineState.destinationHeight;if(width!==dWidth||height!==dHeight){targetCanvas.width=dWidth;targetCanvas.height=dHeight;}}/**\n * Copy an input WebGL canvas on to an output 2D canvas.\n *\n * The WebGL canvas is assumed to be upside down, with the top-left pixel of the\n * desired output image appearing in the bottom-left corner of the WebGL canvas.\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */function copyGLTo2DDrawImage(gl,pipelineState){var glCanvas=gl.canvas,targetCanvas=pipelineState.targetCanvas,ctx=targetCanvas.getContext('2d');ctx.translate(0,targetCanvas.height);// move it down again\nctx.scale(1,-1);// vertical flip\n// where is my image on the big glcanvas?\nvar sourceY=glCanvas.height-targetCanvas.height;ctx.drawImage(glCanvas,0,sourceY,targetCanvas.width,targetCanvas.height,0,0,targetCanvas.width,targetCanvas.height);}/**\n * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData\n * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */function copyGLTo2DPutImageData(gl,pipelineState){var targetCanvas=pipelineState.targetCanvas,ctx=targetCanvas.getContext('2d'),dWidth=pipelineState.destinationWidth,dHeight=pipelineState.destinationHeight,numBytes=dWidth*dHeight*4;// eslint-disable-next-line no-undef\nvar u8=new Uint8Array(this.imageBuffer,0,numBytes);// eslint-disable-next-line no-undef\nvar u8Clamped=new Uint8ClampedArray(this.imageBuffer,0,numBytes);gl.readPixels(0,0,dWidth,dHeight,gl.RGBA,gl.UNSIGNED_BYTE,u8);var imgData=new ImageData(u8Clamped,dWidth,dHeight);ctx.putImageData(imgData,0,0);}(function(){'use strict';var noop=function(){};fabric.Canvas2dFilterBackend=Canvas2dFilterBackend;/**\n   * Canvas 2D filter backend.\n   */function Canvas2dFilterBackend(){};Canvas2dFilterBackend.prototype=/** @lends fabric.Canvas2dFilterBackend.prototype */{evictCachesForKey:noop,dispose:noop,clearWebGLCaches:noop,/**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/resources:{},/**\n     * Apply a set of filters against a source image and draw the filtered output\n     * to the provided destination canvas.\n     *\n     * @param {EnhancedFilter} filters The filter to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.\n     * @param {Number} sourceWidth The width of the source input.\n     * @param {Number} sourceHeight The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     */applyFilters:function(filters,sourceElement,sourceWidth,sourceHeight,targetCanvas){var ctx=targetCanvas.getContext('2d');ctx.drawImage(sourceElement,0,0,sourceWidth,sourceHeight);var imageData=ctx.getImageData(0,0,sourceWidth,sourceHeight);var originalImageData=ctx.getImageData(0,0,sourceWidth,sourceHeight);var pipelineState={sourceWidth:sourceWidth,sourceHeight:sourceHeight,imageData:imageData,originalEl:sourceElement,originalImageData:originalImageData,canvasEl:targetCanvas,ctx:ctx,filterBackend:this};filters.forEach(function(filter){filter.applyTo(pipelineState);});if(pipelineState.imageData.width!==sourceWidth||pipelineState.imageData.height!==sourceHeight){targetCanvas.width=pipelineState.imageData.width;targetCanvas.height=pipelineState.imageData.height;}ctx.putImageData(pipelineState.imageData,0,0);return pipelineState;}};})();/**\n * @namespace fabric.Image.filters\n * @memberOf fabric.Image\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}\n * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n */fabric.Image=fabric.Image||{};fabric.Image.filters=fabric.Image.filters||{};/**\n * Root filter class from which all filter classes inherit from\n * @class fabric.Image.filters.BaseFilter\n * @memberOf fabric.Image.filters\n */fabric.Image.filters.BaseFilter=fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */{/**\n   * Filter type\n   * @param {String} type\n   * @default\n   */type:'BaseFilter',/**\n   * Array of attributes to send with buffers. do not modify\n   * @private\n   */vertexSource:'attribute vec2 aPosition;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vTexCoord = aPosition;\\n'+'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n'+'}',fragmentSource:'precision highp float;\\n'+'varying vec2 vTexCoord;\\n'+'uniform sampler2D uTexture;\\n'+'void main() {\\n'+'gl_FragColor = texture2D(uTexture, vTexCoord);\\n'+'}',/**\n   * Constructor\n   * @param {Object} [options] Options object\n   */initialize:function(options){if(options){this.setOptions(options);}},/**\n   * Sets filter's properties from options\n   * @param {Object} [options] Options object\n   */setOptions:function(options){for(var prop in options){this[prop]=options[prop];}},/**\n   * Compile this filter's shader program.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.\n   * @param {String} fragmentSource fragmentShader source for compilation\n   * @param {String} vertexSource vertexShader source for compilation\n   */createProgram:function(gl,fragmentSource,vertexSource){fragmentSource=fragmentSource||this.fragmentSource;vertexSource=vertexSource||this.vertexSource;if(fabric.webGlPrecision!=='highp'){fragmentSource=fragmentSource.replace(/precision highp float/g,'precision '+fabric.webGlPrecision+' float');}var vertexShader=gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vertexShader,vertexSource);gl.compileShader(vertexShader);if(!gl.getShaderParameter(vertexShader,gl.COMPILE_STATUS)){throw new Error(// eslint-disable-next-line prefer-template\n'Vertex shader compile error for '+this.type+': '+gl.getShaderInfoLog(vertexShader));}var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fragmentShader,fragmentSource);gl.compileShader(fragmentShader);if(!gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS)){throw new Error(// eslint-disable-next-line prefer-template\n'Fragment shader compile error for '+this.type+': '+gl.getShaderInfoLog(fragmentShader));}var program=gl.createProgram();gl.attachShader(program,vertexShader);gl.attachShader(program,fragmentShader);gl.linkProgram(program);if(!gl.getProgramParameter(program,gl.LINK_STATUS)){throw new Error(// eslint-disable-next-line prefer-template\n'Shader link error for \"${this.type}\" '+gl.getProgramInfoLog(program));}var attributeLocations=this.getAttributeLocations(gl,program);var uniformLocations=this.getUniformLocations(gl,program)||{};uniformLocations.uStepW=gl.getUniformLocation(program,'uStepW');uniformLocations.uStepH=gl.getUniformLocation(program,'uStepH');return{program:program,attributeLocations:attributeLocations,uniformLocations:uniformLocations};},/**\n   * Return a map of attribute names to WebGLAttributeLocation objects.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.\n   * @returns {Object} A map of attribute names to attribute locations.\n   */getAttributeLocations:function(gl,program){return{aPosition:gl.getAttribLocation(program,'aPosition')};},/**\n   * Return a map of uniform names to WebGLUniformLocation objects.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.\n   * @returns {Object} A map of uniform names to uniform locations.\n   */getUniformLocations:function/* gl, program */(){// in case i do not need any special uniform i need to return an empty object\nreturn{};},/**\n   * Send attribute data from this filter to its shader program on the GPU.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} attributeLocations A map of shader attribute names to their locations.\n   */sendAttributeData:function(gl,attributeLocations,aPositionData){var attributeLocation=attributeLocations.aPosition;var buffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buffer);gl.enableVertexAttribArray(attributeLocation);gl.vertexAttribPointer(attributeLocation,2,gl.FLOAT,false,0,0);gl.bufferData(gl.ARRAY_BUFFER,aPositionData,gl.STATIC_DRAW);},_setupFrameBuffer:function(options){var gl=options.context,width,height;if(options.passes>1){width=options.destinationWidth;height=options.destinationHeight;if(options.sourceWidth!==width||options.sourceHeight!==height){gl.deleteTexture(options.targetTexture);options.targetTexture=options.filterBackend.createTexture(gl,width,height);}gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,options.targetTexture,0);}else{// draw last filter on canvas and not to framebuffer.\ngl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.finish();}},_swapTextures:function(options){options.passes--;options.pass++;var temp=options.targetTexture;options.targetTexture=options.sourceTexture;options.sourceTexture=temp;},/**\n   * Generic isNeutral implementation for one parameter based filters.\n   * Used only in image applyFilters to discard filters that will not have an effect\n   * on the image\n   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )\n   * @param {Object} options\n   **/isNeutralState:function/* options */(){var main=this.mainParameter,_class=fabric.Image.filters[this.type].prototype;if(main){if(Array.isArray(_class[main])){for(var i=_class[main].length;i--;){if(this[main][i]!==_class[main][i]){return false;}}return true;}else{return _class[main]===this[main];}}else{return false;}},/**\n   * Apply this filter to the input image data provided.\n   *\n   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */applyTo:function(options){if(options.webgl){this._setupFrameBuffer(options);this.applyToWebGL(options);this._swapTextures(options);}else{this.applyTo2d(options);}},/**\n   * Retrieves the cached shader.\n   * @param {Object} options\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */retrieveShader:function(options){if(!options.programCache.hasOwnProperty(this.type)){options.programCache[this.type]=this.createProgram(options.context);}return options.programCache[this.type];},/**\n   * Apply this filter using webgl.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.originalTexture The texture of the original input image.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */applyToWebGL:function(options){var gl=options.context;var shader=this.retrieveShader(options);if(options.pass===0&&options.originalTexture){gl.bindTexture(gl.TEXTURE_2D,options.originalTexture);}else{gl.bindTexture(gl.TEXTURE_2D,options.sourceTexture);}gl.useProgram(shader.program);this.sendAttributeData(gl,shader.attributeLocations,options.aPosition);gl.uniform1f(shader.uniformLocations.uStepW,1/options.sourceWidth);gl.uniform1f(shader.uniformLocations.uStepH,1/options.sourceHeight);this.sendUniformData(gl,shader.uniformLocations);gl.viewport(0,0,options.destinationWidth,options.destinationHeight);gl.drawArrays(gl.TRIANGLE_STRIP,0,4);},bindAdditionalTexture:function(gl,texture,textureUnit){gl.activeTexture(textureUnit);gl.bindTexture(gl.TEXTURE_2D,texture);// reset active texture to 0 as usual\ngl.activeTexture(gl.TEXTURE0);},unbindAdditionalTexture:function(gl,textureUnit){gl.activeTexture(textureUnit);gl.bindTexture(gl.TEXTURE_2D,null);gl.activeTexture(gl.TEXTURE0);},getMainParameter:function(){return this[this.mainParameter];},setMainParameter:function(value){this[this.mainParameter]=value;},/**\n   * Send uniform data from this filter to its shader program on the GPU.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} uniformLocations A map of shader uniform names to their locations.\n   */sendUniformData:function/* gl, uniformLocations */(){// Intentionally left blank.  Override me in subclasses.\n},/**\n   * If needed by a 2d filter, this functions can create an helper canvas to be used\n   * remember that options.targetCanvas is available for use till end of chain.\n   */createHelpLayer:function(options){if(!options.helpLayer){var helpLayer=document.createElement('canvas');helpLayer.width=options.sourceWidth;helpLayer.height=options.sourceHeight;options.helpLayer=helpLayer;}},/**\n   * Returns object representation of an instance\n   * @return {Object} Object representation of an instance\n   */toObject:function(){var object={type:this.type},mainP=this.mainParameter;if(mainP){object[mainP]=this[mainP];}return object;},/**\n   * Returns a JSON representation of an instance\n   * @return {Object} JSON\n   */toJSON:function(){// delegate, not alias\nreturn this.toObject();}});fabric.Image.filters.BaseFilter.fromObject=function(object,callback){var filter=new fabric.Image.filters[object.type](object);callback&&callback(filter);return filter;};(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Color Matrix filter class\n   * @class fabric.Image.filters.ColorMatrix\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}\n   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}\n   * @example <caption>Kodachrome filter</caption>\n   * var filter = new fabric.Image.filters.ColorMatrix({\n   *  matrix: [\n       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n       0, 0, 0, 1, 0\n      ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.ColorMatrix=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.ColorMatrix.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'ColorMatrix',fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'varying vec2 vTexCoord;\\n'+'uniform mat4 uColorMatrix;\\n'+'uniform vec4 uConstants;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'color *= uColorMatrix;\\n'+'color += uConstants;\\n'+'gl_FragColor = color;\\n'+'}',/**\n     * Colormatrix for pixels.\n     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n     * outside the -1, 1 range.\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Array} matrix array of 20 numbers.\n     * @default\n     */matrix:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],mainParameter:'matrix',/**\n     * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario\n     * to save some calculation\n     */colorsOnly:true,/**\n     * Constructor\n     * @param {Object} [options] Options object\n     */initialize:function(options){this.callSuper('initialize',options);// create a new array instead mutating the prototype with push\nthis.matrix=this.matrix.slice(0);},/**\n     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */applyTo2d:function(options){var imageData=options.imageData,data=imageData.data,iLen=data.length,m=this.matrix,r,g,b,a,i,colorsOnly=this.colorsOnly;for(i=0;i<iLen;i+=4){r=data[i];g=data[i+1];b=data[i+2];if(colorsOnly){data[i]=r*m[0]+g*m[1]+b*m[2]+m[4]*255;data[i+1]=r*m[5]+g*m[6]+b*m[7]+m[9]*255;data[i+2]=r*m[10]+g*m[11]+b*m[12]+m[14]*255;}else{a=data[i+3];data[i]=r*m[0]+g*m[1]+b*m[2]+a*m[3]+m[4]*255;data[i+1]=r*m[5]+g*m[6]+b*m[7]+a*m[8]+m[9]*255;data[i+2]=r*m[10]+g*m[11]+b*m[12]+a*m[13]+m[14]*255;data[i+3]=r*m[15]+g*m[16]+b*m[17]+a*m[18]+m[19]*255;}}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uColorMatrix:gl.getUniformLocation(program,'uColorMatrix'),uConstants:gl.getUniformLocation(program,'uConstants')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){var m=this.matrix,matrix=[m[0],m[1],m[2],m[3],m[5],m[6],m[7],m[8],m[10],m[11],m[12],m[13],m[15],m[16],m[17],m[18]],constants=[m[4],m[9],m[14],m[19]];gl.uniformMatrix4fv(uniformLocations.uColorMatrix,false,matrix);gl.uniform4fv(uniformLocations.uConstants,constants);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] function to invoke after filter creation\n   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix\n   */fabric.Image.filters.ColorMatrix.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Brightness filter class\n   * @class fabric.Image.filters.Brightness\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Brightness({\n   *   brightness: 0.05\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.Brightness=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Brightness.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Brightness',/**\n     * Fragment source for the brightness program\n     */fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uBrightness;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'color.rgb += uBrightness;\\n'+'gl_FragColor = color;\\n'+'}',/**\n     * Brightness value, from -1 to 1.\n     * translated to -255 to 255 for 2d\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Number} brightness\n     * @default\n     */brightness:0,/**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */mainParameter:'brightness',/**\n    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n    *\n    * @param {Object} options\n    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n    */applyTo2d:function(options){if(this.brightness===0){return;}var imageData=options.imageData,data=imageData.data,i,len=data.length,brightness=Math.round(this.brightness*255);for(i=0;i<len;i+=4){data[i]=data[i]+brightness;data[i+1]=data[i+1]+brightness;data[i+2]=data[i+2]+brightness;}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uBrightness:gl.getUniformLocation(program,'uBrightness')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform1f(uniformLocations.uBrightness,this.brightness);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\n   */fabric.Image.filters.Brightness.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),extend=fabric.util.object.extend,filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Adapted from <a href=\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">html5rocks article</a>\n   * @class fabric.Image.filters.Convolute\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example <caption>Sharpen filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 0, -1,  0,\n   *            -1,  5, -1,\n   *             0, -1,  0 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Blur filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter with opaqueness</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   opaque: true,\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */filters.Convolute=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Convolute.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Convolute',/*\n     * Opaque value (true/false)\n     */opaque:false,/*\n     * matrix for the filter, max 9x9\n     */matrix:[0,0,0,0,1,0,0,0,0],/**\n     * Fragment source for the brightness program\n     */fragmentSource:{Convolute_3_1:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uMatrix[9];\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = vec4(0, 0, 0, 0);\\n'+'for (float h = 0.0; h < 3.0; h+=1.0) {\\n'+'for (float w = 0.0; w < 3.0; w+=1.0) {\\n'+'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\\n'+'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\\n'+'}\\n'+'}\\n'+'gl_FragColor = color;\\n'+'}',Convolute_3_0:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uMatrix[9];\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = vec4(0, 0, 0, 1);\\n'+'for (float h = 0.0; h < 3.0; h+=1.0) {\\n'+'for (float w = 0.0; w < 3.0; w+=1.0) {\\n'+'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\\n'+'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\\n'+'}\\n'+'}\\n'+'float alpha = texture2D(uTexture, vTexCoord).a;\\n'+'gl_FragColor = color;\\n'+'gl_FragColor.a = alpha;\\n'+'}',Convolute_5_1:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uMatrix[25];\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = vec4(0, 0, 0, 0);\\n'+'for (float h = 0.0; h < 5.0; h+=1.0) {\\n'+'for (float w = 0.0; w < 5.0; w+=1.0) {\\n'+'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n'+'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\\n'+'}\\n'+'}\\n'+'gl_FragColor = color;\\n'+'}',Convolute_5_0:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uMatrix[25];\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = vec4(0, 0, 0, 1);\\n'+'for (float h = 0.0; h < 5.0; h+=1.0) {\\n'+'for (float w = 0.0; w < 5.0; w+=1.0) {\\n'+'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n'+'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\\n'+'}\\n'+'}\\n'+'float alpha = texture2D(uTexture, vTexCoord).a;\\n'+'gl_FragColor = color;\\n'+'gl_FragColor.a = alpha;\\n'+'}',Convolute_7_1:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uMatrix[49];\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = vec4(0, 0, 0, 0);\\n'+'for (float h = 0.0; h < 7.0; h+=1.0) {\\n'+'for (float w = 0.0; w < 7.0; w+=1.0) {\\n'+'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n'+'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\\n'+'}\\n'+'}\\n'+'gl_FragColor = color;\\n'+'}',Convolute_7_0:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uMatrix[49];\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = vec4(0, 0, 0, 1);\\n'+'for (float h = 0.0; h < 7.0; h+=1.0) {\\n'+'for (float w = 0.0; w < 7.0; w+=1.0) {\\n'+'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n'+'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\\n'+'}\\n'+'}\\n'+'float alpha = texture2D(uTexture, vTexCoord).a;\\n'+'gl_FragColor = color;\\n'+'gl_FragColor.a = alpha;\\n'+'}',Convolute_9_1:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uMatrix[81];\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = vec4(0, 0, 0, 0);\\n'+'for (float h = 0.0; h < 9.0; h+=1.0) {\\n'+'for (float w = 0.0; w < 9.0; w+=1.0) {\\n'+'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n'+'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\\n'+'}\\n'+'}\\n'+'gl_FragColor = color;\\n'+'}',Convolute_9_0:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uMatrix[81];\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = vec4(0, 0, 0, 1);\\n'+'for (float h = 0.0; h < 9.0; h+=1.0) {\\n'+'for (float w = 0.0; w < 9.0; w+=1.0) {\\n'+'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n'+'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\\n'+'}\\n'+'}\\n'+'float alpha = texture2D(uTexture, vTexCoord).a;\\n'+'gl_FragColor = color;\\n'+'gl_FragColor.a = alpha;\\n'+'}'},/**\n     * Constructor\n     * @memberOf fabric.Image.filters.Convolute.prototype\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\n     * @param {Array} [options.matrix] Filter matrix\n     */ /**\n    * Retrieves the cached shader.\n    * @param {Object} options\n    * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n    */retrieveShader:function(options){var size=Math.sqrt(this.matrix.length);var cacheKey=this.type+'_'+size+'_'+(this.opaque?1:0);var shaderSource=this.fragmentSource[cacheKey];if(!options.programCache.hasOwnProperty(cacheKey)){options.programCache[cacheKey]=this.createProgram(options.context,shaderSource);}return options.programCache[cacheKey];},/**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */applyTo2d:function(options){var imageData=options.imageData,data=imageData.data,weights=this.matrix,side=Math.round(Math.sqrt(weights.length)),halfSide=Math.floor(side/2),sw=imageData.width,sh=imageData.height,output=options.ctx.createImageData(sw,sh),dst=output.data,// go through the destination image pixels\nalphaFac=this.opaque?1:0,r,g,b,a,dstOff,scx,scy,srcOff,wt,x,y,cx,cy;for(y=0;y<sh;y++){for(x=0;x<sw;x++){dstOff=(y*sw+x)*4;// calculate the weighed sum of the source image pixels that\n// fall under the convolution matrix\nr=0;g=0;b=0;a=0;for(cy=0;cy<side;cy++){for(cx=0;cx<side;cx++){scy=y+cy-halfSide;scx=x+cx-halfSide;// eslint-disable-next-line max-depth\nif(scy<0||scy>=sh||scx<0||scx>=sw){continue;}srcOff=(scy*sw+scx)*4;wt=weights[cy*side+cx];r+=data[srcOff]*wt;g+=data[srcOff+1]*wt;b+=data[srcOff+2]*wt;// eslint-disable-next-line max-depth\nif(!alphaFac){a+=data[srcOff+3]*wt;}}}dst[dstOff]=r;dst[dstOff+1]=g;dst[dstOff+2]=b;if(!alphaFac){dst[dstOff+3]=a;}else{dst[dstOff+3]=data[dstOff+3];}}}options.imageData=output;},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uMatrix:gl.getUniformLocation(program,'uMatrix'),uOpaque:gl.getUniformLocation(program,'uOpaque'),uHalfSize:gl.getUniformLocation(program,'uHalfSize'),uSize:gl.getUniformLocation(program,'uSize')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform1fv(uniformLocations.uMatrix,this.matrix);},/**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */toObject:function(){return extend(this.callSuper('toObject'),{opaque:this.opaque,matrix:this.matrix});}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\n   */fabric.Image.filters.Convolute.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Grayscale image filter class\n   * @class fabric.Image.filters.Grayscale\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Grayscale();\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.Grayscale=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Grayscale.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Grayscale',fragmentSource:{average:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'float average = (color.r + color.b + color.g) / 3.0;\\n'+'gl_FragColor = vec4(average, average, average, color.a);\\n'+'}',lightness:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform int uMode;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 col = texture2D(uTexture, vTexCoord);\\n'+'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\\n'+'gl_FragColor = vec4(average, average, average, col.a);\\n'+'}',luminosity:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform int uMode;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 col = texture2D(uTexture, vTexCoord);\\n'+'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\\n'+'gl_FragColor = vec4(average, average, average, col.a);\\n'+'}'},/**\n     * Grayscale mode, between 'average', 'lightness', 'luminosity'\n     * @param {String} type\n     * @default\n     */mode:'average',mainParameter:'mode',/**\n     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */applyTo2d:function(options){var imageData=options.imageData,data=imageData.data,i,len=data.length,value,mode=this.mode;for(i=0;i<len;i+=4){if(mode==='average'){value=(data[i]+data[i+1]+data[i+2])/3;}else if(mode==='lightness'){value=(Math.min(data[i],data[i+1],data[i+2])+Math.max(data[i],data[i+1],data[i+2]))/2;}else if(mode==='luminosity'){value=0.21*data[i]+0.72*data[i+1]+0.07*data[i+2];}data[i]=value;data[i+1]=value;data[i+2]=value;}},/**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */retrieveShader:function(options){var cacheKey=this.type+'_'+this.mode;if(!options.programCache.hasOwnProperty(cacheKey)){var shaderSource=this.fragmentSource[this.mode];options.programCache[cacheKey]=this.createProgram(options.context,shaderSource);}return options.programCache[cacheKey];},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uMode:gl.getUniformLocation(program,'uMode')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){// default average mode.\nvar mode=1;gl.uniform1i(uniformLocations.uMode,mode);},/**\n     * Grayscale filter isNeutralState implementation\n     * The filter is never neutral\n     * on the image\n     **/isNeutralState:function(){return false;}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\n   */fabric.Image.filters.Grayscale.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Invert filter class\n   * @class fabric.Image.filters.Invert\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Invert();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */filters.Invert=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Invert.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Invert',fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform int uInvert;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'if (uInvert == 1) {\\n'+'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\\n'+'} else {\\n'+'gl_FragColor = color;\\n'+'}\\n'+'}',/**\n     * Filter invert. if false, does nothing\n     * @param {Boolean} invert\n     * @default\n     */invert:true,mainParameter:'invert',/**\n     * Apply the Invert operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */applyTo2d:function(options){var imageData=options.imageData,data=imageData.data,i,len=data.length;for(i=0;i<len;i+=4){data[i]=255-data[i];data[i+1]=255-data[i+1];data[i+2]=255-data[i+2];}},/**\n     * Invert filter isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/isNeutralState:function(){return!this.invert;},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uInvert:gl.getUniformLocation(program,'uInvert')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform1i(uniformLocations.uInvert,this.invert);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\n   */fabric.Image.filters.Invert.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),extend=fabric.util.object.extend,filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Noise filter class\n   * @class fabric.Image.filters.Noise\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Noise({\n   *   noise: 700\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */filters.Noise=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Noise.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Noise',/**\n     * Fragment source for the noise program\n     */fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uStepH;\\n'+'uniform float uNoise;\\n'+'uniform float uSeed;\\n'+'varying vec2 vTexCoord;\\n'+'float rand(vec2 co, float seed, float vScale) {\\n'+'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\\n'+'}\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\\n'+'gl_FragColor = color;\\n'+'}',/**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */mainParameter:'noise',/**\n     * Noise value, from\n     * @param {Number} noise\n     * @default\n     */noise:0,/**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */applyTo2d:function(options){if(this.noise===0){return;}var imageData=options.imageData,data=imageData.data,i,len=data.length,noise=this.noise,rand;for(i=0,len=data.length;i<len;i+=4){rand=(0.5-Math.random())*noise;data[i]+=rand;data[i+1]+=rand;data[i+2]+=rand;}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uNoise:gl.getUniformLocation(program,'uNoise'),uSeed:gl.getUniformLocation(program,'uSeed')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform1f(uniformLocations.uNoise,this.noise/255);gl.uniform1f(uniformLocations.uSeed,Math.random());},/**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */toObject:function(){return extend(this.callSuper('toObject'),{noise:this.noise});}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\n   */fabric.Image.filters.Noise.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Pixelate filter class\n   * @class fabric.Image.filters.Pixelate\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Pixelate({\n   *   blocksize: 8\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.Pixelate=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Pixelate.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Pixelate',blocksize:4,mainParameter:'blocksize',/**\n     * Fragment source for the Pixelate program\n     */fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uBlocksize;\\n'+'uniform float uStepW;\\n'+'uniform float uStepH;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'float blockW = uBlocksize * uStepW;\\n'+'float blockH = uBlocksize * uStepW;\\n'+'int posX = int(vTexCoord.x / blockW);\\n'+'int posY = int(vTexCoord.y / blockH);\\n'+'float fposX = float(posX);\\n'+'float fposY = float(posY);\\n'+'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\\n'+'vec4 color = texture2D(uTexture, squareCoords);\\n'+'gl_FragColor = color;\\n'+'}',/**\n     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */applyTo2d:function(options){var imageData=options.imageData,data=imageData.data,iLen=imageData.height,jLen=imageData.width,index,i,j,r,g,b,a,_i,_j,_iLen,_jLen;for(i=0;i<iLen;i+=this.blocksize){for(j=0;j<jLen;j+=this.blocksize){index=i*4*jLen+j*4;r=data[index];g=data[index+1];b=data[index+2];a=data[index+3];_iLen=Math.min(i+this.blocksize,iLen);_jLen=Math.min(j+this.blocksize,jLen);for(_i=i;_i<_iLen;_i++){for(_j=j;_j<_jLen;_j++){index=_i*4*jLen+_j*4;data[index]=r;data[index+1]=g;data[index+2]=b;data[index+3]=a;}}}}},/**\n     * Indicate when the filter is not gonna apply changes to the image\n     **/isNeutralState:function(){return this.blocksize===1;},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uBlocksize:gl.getUniformLocation(program,'uBlocksize'),uStepW:gl.getUniformLocation(program,'uStepW'),uStepH:gl.getUniformLocation(program,'uStepH')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform1f(uniformLocations.uBlocksize,this.blocksize);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\n   */fabric.Image.filters.Pixelate.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),extend=fabric.util.object.extend,filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Remove white filter class\n   * @class fabric.Image.filters.RemoveColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.RemoveColor({\n   *   threshold: 0.2,\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */filters.RemoveColor=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.RemoveColor.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'RemoveColor',/**\n     * Color to remove, in any format understood by fabric.Color.\n     * @param {String} type\n     * @default\n     */color:'#FFFFFF',/**\n     * Fragment source for the brightness program\n     */fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform vec4 uLow;\\n'+'uniform vec4 uHigh;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'gl_FragColor = texture2D(uTexture, vTexCoord);\\n'+'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\\n'+'gl_FragColor.a = 0.0;\\n'+'}\\n'+'}',/**\n     * distance to actual color, as value up or down from each r,g,b\n     * between 0 and 1\n     **/distance:0.02,/**\n     * For color to remove inside distance, use alpha channel for a smoother deletion\n     * NOT IMPLEMENTED YET\n     **/useAlpha:false,/**\n     * Constructor\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.color=#RRGGBB] Threshold value\n     * @param {Number} [options.distance=10] Distance value\n     */ /**\n     * Applies filter to canvas element\n     * @param {Object} canvasEl Canvas element to apply filter to\n     */applyTo2d:function(options){var imageData=options.imageData,data=imageData.data,i,distance=this.distance*255,r,g,b,source=new fabric.Color(this.color).getSource(),lowC=[source[0]-distance,source[1]-distance,source[2]-distance],highC=[source[0]+distance,source[1]+distance,source[2]+distance];for(i=0;i<data.length;i+=4){r=data[i];g=data[i+1];b=data[i+2];if(r>lowC[0]&&g>lowC[1]&&b>lowC[2]&&r<highC[0]&&g<highC[1]&&b<highC[2]){data[i+3]=0;}}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uLow:gl.getUniformLocation(program,'uLow'),uHigh:gl.getUniformLocation(program,'uHigh')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){var source=new fabric.Color(this.color).getSource(),distance=parseFloat(this.distance),lowC=[0+source[0]/255-distance,0+source[1]/255-distance,0+source[2]/255-distance,1],highC=[source[0]/255+distance,source[1]/255+distance,source[2]/255+distance,1];gl.uniform4fv(uniformLocations.uLow,lowC);gl.uniform4fv(uniformLocations.uHigh,highC);},/**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */toObject:function(){return extend(this.callSuper('toObject'),{color:this.color,distance:this.distance});}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite\n   */fabric.Image.filters.RemoveColor.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;var matrices={Brownie:[0.59970,0.34553,-0.27082,0,0.186,-0.03770,0.86095,0.15059,0,-0.1449,0.24113,-0.07441,0.44972,0,-0.02965,0,0,0,1,0],Vintage:[0.62793,0.32021,-0.03965,0,0.03784,0.02578,0.64411,0.03259,0,0.02926,0.04660,-0.08512,0.52416,0,0.02023,0,0,0,1,0],Kodachrome:[1.12855,-0.39673,-0.03992,0,0.24991,-0.16404,1.08352,-0.05498,0,0.09698,-0.16786,-0.56034,1.60148,0,0.13972,0,0,0,1,0],Technicolor:[1.91252,-0.85453,-0.09155,0,0.04624,-0.30878,1.76589,-0.10601,0,-0.27589,-0.23110,-0.75018,1.84759,0,0.12137,0,0,0,1,0],Polaroid:[1.438,-0.062,-0.062,0,0,-0.122,1.378,-0.122,0,0,-0.016,-0.016,1.483,0,0,0,0,0,1,0],Sepia:[0.393,0.769,0.189,0,0,0.349,0.686,0.168,0,0,0.272,0.534,0.131,0,0,0,0,0,1,0],BlackWhite:[1.5,1.5,1.5,0,-1,1.5,1.5,1.5,0,-1,1.5,1.5,1.5,0,-1,0,0,0,1,0]};for(var key in matrices){filters[key]=createClass(filters.ColorMatrix,/** @lends fabric.Image.filters.Sepia.prototype */{/**\n       * Filter type\n       * @param {String} type\n       * @default\n       */type:key,/**\n       * Colormatrix for the effect\n       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n       * outside the -1, 1 range.\n       * @param {Array} matrix array of 20 numbers.\n       * @default\n       */matrix:matrices[key],/**\n       * Lock the matrix export for this kind of static, parameter less filters.\n       */mainParameter:false,/**\n       * Lock the colormatrix on the color part, skipping alpha\n       */colorsOnly:true});fabric.Image.filters[key].fromObject=fabric.Image.filters.BaseFilter.fromObject;}})( true?exports:0);(function(global){'use strict';var fabric=global.fabric,filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Color Blend filter class\n   * @class fabric.Image.filter.BlendColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */filters.BlendColor=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Blend.prototype */{type:'BlendColor',/**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     **/color:'#F95C63',/**\n     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,\n     * darken, lighten, overlay, exclusion, tint.\n     **/mode:'multiply',/**\n     * alpha value. represent the strength of the blend color operation.\n     **/alpha:1,/**\n     * Fragment source for the Multiply program\n     */fragmentSource:{multiply:'gl_FragColor.rgb *= uColor.rgb;\\n',screen:'gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\\n',add:'gl_FragColor.rgb += uColor.rgb;\\n',diff:'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\\n',subtract:'gl_FragColor.rgb -= uColor.rgb;\\n',lighten:'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\\n',darken:'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\\n',exclusion:'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\\n',overlay:'if (uColor.r < 0.5) {\\n'+'gl_FragColor.r *= 2.0 * uColor.r;\\n'+'} else {\\n'+'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\\n'+'}\\n'+'if (uColor.g < 0.5) {\\n'+'gl_FragColor.g *= 2.0 * uColor.g;\\n'+'} else {\\n'+'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\\n'+'}\\n'+'if (uColor.b < 0.5) {\\n'+'gl_FragColor.b *= 2.0 * uColor.b;\\n'+'} else {\\n'+'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\\n'+'}\\n',tint:'gl_FragColor.rgb *= (1.0 - uColor.a);\\n'+'gl_FragColor.rgb += uColor.rgb;\\n'},/**\n     * build the fragment source for the filters, joining the common part with\n     * the specific one.\n     * @param {String} mode the mode of the filter, a key of this.fragmentSource\n     * @return {String} the source to be compiled\n     * @private\n     */buildSource:function(mode){return'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform vec4 uColor;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'gl_FragColor = color;\\n'+'if (color.a > 0.0) {\\n'+this.fragmentSource[mode]+'}\\n'+'}';},/**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */retrieveShader:function(options){var cacheKey=this.type+'_'+this.mode,shaderSource;if(!options.programCache.hasOwnProperty(cacheKey)){shaderSource=this.buildSource(this.mode);options.programCache[cacheKey]=this.createProgram(options.context,shaderSource);}return options.programCache[cacheKey];},/**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */applyTo2d:function(options){var imageData=options.imageData,data=imageData.data,iLen=data.length,tr,tg,tb,r,g,b,source,alpha1=1-this.alpha;source=new fabric.Color(this.color).getSource();tr=source[0]*this.alpha;tg=source[1]*this.alpha;tb=source[2]*this.alpha;for(var i=0;i<iLen;i+=4){r=data[i];g=data[i+1];b=data[i+2];switch(this.mode){case'multiply':data[i]=r*tr/255;data[i+1]=g*tg/255;data[i+2]=b*tb/255;break;case'screen':data[i]=255-(255-r)*(255-tr)/255;data[i+1]=255-(255-g)*(255-tg)/255;data[i+2]=255-(255-b)*(255-tb)/255;break;case'add':data[i]=r+tr;data[i+1]=g+tg;data[i+2]=b+tb;break;case'diff':case'difference':data[i]=Math.abs(r-tr);data[i+1]=Math.abs(g-tg);data[i+2]=Math.abs(b-tb);break;case'subtract':data[i]=r-tr;data[i+1]=g-tg;data[i+2]=b-tb;break;case'darken':data[i]=Math.min(r,tr);data[i+1]=Math.min(g,tg);data[i+2]=Math.min(b,tb);break;case'lighten':data[i]=Math.max(r,tr);data[i+1]=Math.max(g,tg);data[i+2]=Math.max(b,tb);break;case'overlay':data[i]=tr<128?2*r*tr/255:255-2*(255-r)*(255-tr)/255;data[i+1]=tg<128?2*g*tg/255:255-2*(255-g)*(255-tg)/255;data[i+2]=tb<128?2*b*tb/255:255-2*(255-b)*(255-tb)/255;break;case'exclusion':data[i]=tr+r-2*tr*r/255;data[i+1]=tg+g-2*tg*g/255;data[i+2]=tb+b-2*tb*b/255;break;case'tint':data[i]=tr+r*alpha1;data[i+1]=tg+g*alpha1;data[i+2]=tb+b*alpha1;}}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uColor:gl.getUniformLocation(program,'uColor')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){var source=new fabric.Color(this.color).getSource();source[0]=this.alpha*source[0]/255;source[1]=this.alpha*source[1]/255;source[2]=this.alpha*source[2]/255;source[3]=this.alpha;gl.uniform4fv(uniformLocations.uColor,source);},/**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */toObject:function(){return{type:this.type,color:this.color,mode:this.mode,alpha:this.alpha};}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor\n   */fabric.Image.filters.BlendColor.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric,filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Image Blend filter class\n   * @class fabric.Image.filter.BlendImage\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */filters.BlendImage=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.BlendImage.prototype */{type:'BlendImage',/**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     **/image:null,/**\n     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,\n     * darken, lighten, overlay, exclusion, tint.\n     **/mode:'multiply',/**\n     * alpha value. represent the strength of the blend image operation.\n     * not implemented.\n     **/alpha:1,vertexSource:'attribute vec2 aPosition;\\n'+'varying vec2 vTexCoord;\\n'+'varying vec2 vTexCoord2;\\n'+'uniform mat3 uTransformMatrix;\\n'+'void main() {\\n'+'vTexCoord = aPosition;\\n'+'vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\\n'+'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n'+'}',/**\n     * Fragment source for the Multiply program\n     */fragmentSource:{multiply:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform sampler2D uImage;\\n'+'uniform vec4 uColor;\\n'+'varying vec2 vTexCoord;\\n'+'varying vec2 vTexCoord2;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'vec4 color2 = texture2D(uImage, vTexCoord2);\\n'+'color.rgba *= color2.rgba;\\n'+'gl_FragColor = color;\\n'+'}',mask:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform sampler2D uImage;\\n'+'uniform vec4 uColor;\\n'+'varying vec2 vTexCoord;\\n'+'varying vec2 vTexCoord2;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'vec4 color2 = texture2D(uImage, vTexCoord2);\\n'+'color.a = color2.a;\\n'+'gl_FragColor = color;\\n'+'}'},/**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */retrieveShader:function(options){var cacheKey=this.type+'_'+this.mode;var shaderSource=this.fragmentSource[this.mode];if(!options.programCache.hasOwnProperty(cacheKey)){options.programCache[cacheKey]=this.createProgram(options.context,shaderSource);}return options.programCache[cacheKey];},applyToWebGL:function(options){// load texture to blend.\nvar gl=options.context,texture=this.createTexture(options.filterBackend,this.image);this.bindAdditionalTexture(gl,texture,gl.TEXTURE1);this.callSuper('applyToWebGL',options);this.unbindAdditionalTexture(gl,gl.TEXTURE1);},createTexture:function(backend,image){return backend.getCachedTexture(image.cacheKey,image._element);},/**\n     * Calculate a transformMatrix to adapt the image to blend over\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */calculateMatrix:function(){var image=this.image,width=image._element.width,height=image._element.height;return[1/image.scaleX,0,0,0,1/image.scaleY,0,-image.left/width,-image.top/height,1];},/**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */applyTo2d:function(options){var imageData=options.imageData,resources=options.filterBackend.resources,data=imageData.data,iLen=data.length,width=imageData.width,height=imageData.height,tr,tg,tb,ta,r,g,b,a,canvas1,context,image=this.image,blendData;if(!resources.blendImage){resources.blendImage=fabric.util.createCanvasElement();}canvas1=resources.blendImage;context=canvas1.getContext('2d');if(canvas1.width!==width||canvas1.height!==height){canvas1.width=width;canvas1.height=height;}else{context.clearRect(0,0,width,height);}context.setTransform(image.scaleX,0,0,image.scaleY,image.left,image.top);context.drawImage(image._element,0,0,width,height);blendData=context.getImageData(0,0,width,height).data;for(var i=0;i<iLen;i+=4){r=data[i];g=data[i+1];b=data[i+2];a=data[i+3];tr=blendData[i];tg=blendData[i+1];tb=blendData[i+2];ta=blendData[i+3];switch(this.mode){case'multiply':data[i]=r*tr/255;data[i+1]=g*tg/255;data[i+2]=b*tb/255;data[i+3]=a*ta/255;break;case'mask':data[i+3]=ta;break;}}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uTransformMatrix:gl.getUniformLocation(program,'uTransformMatrix'),uImage:gl.getUniformLocation(program,'uImage')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){var matrix=this.calculateMatrix();gl.uniform1i(uniformLocations.uImage,1);// texture unit 1.\ngl.uniformMatrix3fv(uniformLocations.uTransformMatrix,false,matrix);},/**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */toObject:function(){return{type:this.type,image:this.image&&this.image.toObject(),mode:this.mode,alpha:this.alpha};}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} callback to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage\n   */fabric.Image.filters.BlendImage.fromObject=function(object,callback){fabric.Image.fromObject(object.image,function(image){var options=fabric.util.object.clone(object);options.image=image;callback(new fabric.Image.filters.BlendImage(options));});};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),pow=Math.pow,floor=Math.floor,sqrt=Math.sqrt,abs=Math.abs,round=Math.round,sin=Math.sin,ceil=Math.ceil,filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Resize image filter class\n   * @class fabric.Image.filters.Resize\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Resize();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */filters.Resize=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Resize.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Resize',/**\n     * Resize type\n     * for webgl resizeType is just lanczos, for canvas2d can be:\n     * bilinear, hermite, sliceHack, lanczos.\n     * @param {String} resizeType\n     * @default\n     */resizeType:'hermite',/**\n     * Scale factor for resizing, x axis\n     * @param {Number} scaleX\n     * @default\n     */scaleX:1,/**\n     * Scale factor for resizing, y axis\n     * @param {Number} scaleY\n     * @default\n     */scaleY:1,/**\n     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos\n     * @param {Number} lanczosLobes\n     * @default\n     */lanczosLobes:3,/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uDelta:gl.getUniformLocation(program,'uDelta'),uTaps:gl.getUniformLocation(program,'uTaps')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform2fv(uniformLocations.uDelta,this.horizontal?[1/this.width,0]:[0,1/this.height]);gl.uniform1fv(uniformLocations.uTaps,this.taps);},/**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */retrieveShader:function(options){var filterWindow=this.getFilterWindow(),cacheKey=this.type+'_'+filterWindow;if(!options.programCache.hasOwnProperty(cacheKey)){var fragmentShader=this.generateShader(filterWindow);options.programCache[cacheKey]=this.createProgram(options.context,fragmentShader);}return options.programCache[cacheKey];},getFilterWindow:function(){var scale=this.tempScale;return Math.ceil(this.lanczosLobes/scale);},getTaps:function(){var lobeFunction=this.lanczosCreate(this.lanczosLobes),scale=this.tempScale,filterWindow=this.getFilterWindow(),taps=new Array(filterWindow);for(var i=1;i<=filterWindow;i++){taps[i-1]=lobeFunction(i*scale);}return taps;},/**\n     * Generate vertex and shader sources from the necessary steps numbers\n     * @param {Number} filterWindow\n     */generateShader:function(filterWindow){var offsets=new Array(filterWindow),fragmentShader=this.fragmentSourceTOP,filterWindow;for(var i=1;i<=filterWindow;i++){offsets[i-1]=i+'.0 * uDelta';}fragmentShader+='uniform float uTaps['+filterWindow+'];\\n';fragmentShader+='void main() {\\n';fragmentShader+='  vec4 color = texture2D(uTexture, vTexCoord);\\n';fragmentShader+='  float sum = 1.0;\\n';offsets.forEach(function(offset,i){fragmentShader+='  color += texture2D(uTexture, vTexCoord + '+offset+') * uTaps['+i+'];\\n';fragmentShader+='  color += texture2D(uTexture, vTexCoord - '+offset+') * uTaps['+i+'];\\n';fragmentShader+='  sum += 2.0 * uTaps['+i+'];\\n';});fragmentShader+='  gl_FragColor = color / sum;\\n';fragmentShader+='}';return fragmentShader;},fragmentSourceTOP:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform vec2 uDelta;\\n'+'varying vec2 vTexCoord;\\n',/**\n     * Apply the resize filter to the image\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */applyTo:function(options){if(options.webgl){options.passes++;this.width=options.sourceWidth;this.horizontal=true;this.dW=Math.round(this.width*this.scaleX);this.dH=options.sourceHeight;this.tempScale=this.dW/this.width;this.taps=this.getTaps();options.destinationWidth=this.dW;this._setupFrameBuffer(options);this.applyToWebGL(options);this._swapTextures(options);options.sourceWidth=options.destinationWidth;this.height=options.sourceHeight;this.horizontal=false;this.dH=Math.round(this.height*this.scaleY);this.tempScale=this.dH/this.height;this.taps=this.getTaps();options.destinationHeight=this.dH;this._setupFrameBuffer(options);this.applyToWebGL(options);this._swapTextures(options);options.sourceHeight=options.destinationHeight;}else{this.applyTo2d(options);}},isNeutralState:function(){return this.scaleX===1&&this.scaleY===1;},lanczosCreate:function(lobes){return function(x){if(x>=lobes||x<=-lobes){return 0.0;}if(x<1.19209290E-07&&x>-1.19209290E-07){return 1.0;}x*=Math.PI;var xx=x/lobes;return sin(x)/x*sin(xx)/xx;};},/**\n     * Applies filter to canvas element\n     * @memberOf fabric.Image.filters.Resize.prototype\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} scaleX\n     * @param {Number} scaleY\n     */applyTo2d:function(options){var imageData=options.imageData,scaleX=this.scaleX,scaleY=this.scaleY;this.rcpScaleX=1/scaleX;this.rcpScaleY=1/scaleY;var oW=imageData.width,oH=imageData.height,dW=round(oW*scaleX),dH=round(oH*scaleY),newData;if(this.resizeType==='sliceHack'){newData=this.sliceByTwo(options,oW,oH,dW,dH);}else if(this.resizeType==='hermite'){newData=this.hermiteFastResize(options,oW,oH,dW,dH);}else if(this.resizeType==='bilinear'){newData=this.bilinearFiltering(options,oW,oH,dW,dH);}else if(this.resizeType==='lanczos'){newData=this.lanczosResize(options,oW,oH,dW,dH);}options.imageData=newData;},/**\n     * Filter sliceByTwo\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */sliceByTwo:function(options,oW,oH,dW,dH){var imageData=options.imageData,mult=0.5,doneW=false,doneH=false,stepW=oW*mult,stepH=oH*mult,resources=fabric.filterBackend.resources,tmpCanvas,ctx,sX=0,sY=0,dX=oW,dY=0;if(!resources.sliceByTwo){resources.sliceByTwo=document.createElement('canvas');}tmpCanvas=resources.sliceByTwo;if(tmpCanvas.width<oW*1.5||tmpCanvas.height<oH){tmpCanvas.width=oW*1.5;tmpCanvas.height=oH;}ctx=tmpCanvas.getContext('2d');ctx.clearRect(0,0,oW*1.5,oH);ctx.putImageData(imageData,0,0);dW=floor(dW);dH=floor(dH);while(!doneW||!doneH){oW=stepW;oH=stepH;if(dW<floor(stepW*mult)){stepW=floor(stepW*mult);}else{stepW=dW;doneW=true;}if(dH<floor(stepH*mult)){stepH=floor(stepH*mult);}else{stepH=dH;doneH=true;}ctx.drawImage(tmpCanvas,sX,sY,oW,oH,dX,dY,stepW,stepH);sX=dX;sY=dY;dY+=stepH;}return ctx.getImageData(sX,sY,dW,dH);},/**\n     * Filter lanczosResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */lanczosResize:function(options,oW,oH,dW,dH){function process(u){var v,i,weight,idx,a,red,green,blue,alpha,fX,fY;center.x=(u+0.5)*ratioX;icenter.x=floor(center.x);for(v=0;v<dH;v++){center.y=(v+0.5)*ratioY;icenter.y=floor(center.y);a=0;red=0;green=0;blue=0;alpha=0;for(i=icenter.x-range2X;i<=icenter.x+range2X;i++){if(i<0||i>=oW){continue;}fX=floor(1000*abs(i-center.x));if(!cacheLanc[fX]){cacheLanc[fX]={};}for(var j=icenter.y-range2Y;j<=icenter.y+range2Y;j++){if(j<0||j>=oH){continue;}fY=floor(1000*abs(j-center.y));if(!cacheLanc[fX][fY]){cacheLanc[fX][fY]=lanczos(sqrt(pow(fX*rcpRatioX,2)+pow(fY*rcpRatioY,2))/1000);}weight=cacheLanc[fX][fY];if(weight>0){idx=(j*oW+i)*4;a+=weight;red+=weight*srcData[idx];green+=weight*srcData[idx+1];blue+=weight*srcData[idx+2];alpha+=weight*srcData[idx+3];}}}idx=(v*dW+u)*4;destData[idx]=red/a;destData[idx+1]=green/a;destData[idx+2]=blue/a;destData[idx+3]=alpha/a;}if(++u<dW){return process(u);}else{return destImg;}}var srcData=options.imageData.data,destImg=options.ctx.createImageData(dW,dH),destData=destImg.data,lanczos=this.lanczosCreate(this.lanczosLobes),ratioX=this.rcpScaleX,ratioY=this.rcpScaleY,rcpRatioX=2/this.rcpScaleX,rcpRatioY=2/this.rcpScaleY,range2X=ceil(ratioX*this.lanczosLobes/2),range2Y=ceil(ratioY*this.lanczosLobes/2),cacheLanc={},center={},icenter={};return process(0);},/**\n     * bilinearFiltering\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */bilinearFiltering:function(options,oW,oH,dW,dH){var a,b,c,d,x,y,i,j,xDiff,yDiff,chnl,color,offset=0,origPix,ratioX=this.rcpScaleX,ratioY=this.rcpScaleY,w4=4*(oW-1),img=options.imageData,pixels=img.data,destImage=options.ctx.createImageData(dW,dH),destPixels=destImage.data;for(i=0;i<dH;i++){for(j=0;j<dW;j++){x=floor(ratioX*j);y=floor(ratioY*i);xDiff=ratioX*j-x;yDiff=ratioY*i-y;origPix=4*(y*oW+x);for(chnl=0;chnl<4;chnl++){a=pixels[origPix+chnl];b=pixels[origPix+4+chnl];c=pixels[origPix+w4+chnl];d=pixels[origPix+w4+4+chnl];color=a*(1-xDiff)*(1-yDiff)+b*xDiff*(1-yDiff)+c*yDiff*(1-xDiff)+d*xDiff*yDiff;destPixels[offset++]=color;}}}return destImage;},/**\n     * hermiteFastResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */hermiteFastResize:function(options,oW,oH,dW,dH){var ratioW=this.rcpScaleX,ratioH=this.rcpScaleY,ratioWHalf=ceil(ratioW/2),ratioHHalf=ceil(ratioH/2),img=options.imageData,data=img.data,img2=options.ctx.createImageData(dW,dH),data2=img2.data;for(var j=0;j<dH;j++){for(var i=0;i<dW;i++){var x2=(i+j*dW)*4,weight=0,weights=0,weightsAlpha=0,gxR=0,gxG=0,gxB=0,gxA=0,centerY=(j+0.5)*ratioH;for(var yy=floor(j*ratioH);yy<(j+1)*ratioH;yy++){var dy=abs(centerY-(yy+0.5))/ratioHHalf,centerX=(i+0.5)*ratioW,w0=dy*dy;for(var xx=floor(i*ratioW);xx<(i+1)*ratioW;xx++){var dx=abs(centerX-(xx+0.5))/ratioWHalf,w=sqrt(w0+dx*dx);/* eslint-disable max-depth */if(w>1&&w<-1){continue;}//hermite filter\nweight=2*w*w*w-3*w*w+1;if(weight>0){dx=4*(xx+yy*oW);//alpha\ngxA+=weight*data[dx+3];weightsAlpha+=weight;//colors\nif(data[dx+3]<255){weight=weight*data[dx+3]/250;}gxR+=weight*data[dx];gxG+=weight*data[dx+1];gxB+=weight*data[dx+2];weights+=weight;}/* eslint-enable max-depth */}}data2[x2]=gxR/weights;data2[x2+1]=gxG/weights;data2[x2+2]=gxB/weights;data2[x2+3]=gxA/weightsAlpha;}}return img2;},/**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */toObject:function(){return{type:this.type,scaleX:this.scaleX,scaleY:this.scaleY,resizeType:this.resizeType,lanczosLobes:this.lanczosLobes};}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\n   */fabric.Image.filters.Resize.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Contrast filter class\n   * @class fabric.Image.filters.Contrast\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Contrast({\n   *   contrast: 0.25\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.Contrast=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Contrast.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Contrast',fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uContrast;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\\n'+'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\\n'+'gl_FragColor = color;\\n'+'}',/**\n     * contrast value, range from -1 to 1.\n     * @param {Number} contrast\n     * @default 0\n     */contrast:0,mainParameter:'contrast',/**\n     * Constructor\n     * @memberOf fabric.Image.filters.Contrast.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)\n     */ /**\n      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.\n      *\n      * @param {Object} options\n      * @param {ImageData} options.imageData The Uint8Array to be filtered.\n      */applyTo2d:function(options){if(this.contrast===0){return;}var imageData=options.imageData,i,len,data=imageData.data,len=data.length,contrast=Math.floor(this.contrast*255),contrastF=259*(contrast+255)/(255*(259-contrast));for(i=0;i<len;i+=4){data[i]=contrastF*(data[i]-128)+128;data[i+1]=contrastF*(data[i+1]-128)+128;data[i+2]=contrastF*(data[i+2]-128)+128;}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uContrast:gl.getUniformLocation(program,'uContrast')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform1f(uniformLocations.uContrast,this.contrast);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast\n   */fabric.Image.filters.Contrast.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Saturate filter class\n   * @class fabric.Image.filters.Saturation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Saturation({\n   *   saturation: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.Saturation=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Saturation.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Saturation',fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uSaturation;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'float rgMax = max(color.r, color.g);\\n'+'float rgbMax = max(rgMax, color.b);\\n'+'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\\n'+'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\\n'+'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\\n'+'gl_FragColor = color;\\n'+'}',/**\n     * Saturation value, from -1 to 1.\n     * Increases/decreases the color saturation.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} saturation\n     * @default\n     */saturation:0,mainParameter:'saturation',/**\n     * Constructor\n     * @memberOf fabric.Image.filters.Saturate.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)\n     */ /**\n     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */applyTo2d:function(options){if(this.saturation===0){return;}var imageData=options.imageData,data=imageData.data,len=data.length,adjust=-this.saturation,i,max;for(i=0;i<len;i+=4){max=Math.max(data[i],data[i+1],data[i+2]);data[i]+=max!==data[i]?(max-data[i])*adjust:0;data[i+1]+=max!==data[i+1]?(max-data[i+1])*adjust:0;data[i+2]+=max!==data[i+2]?(max-data[i+2])*adjust:0;}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uSaturation:gl.getUniformLocation(program,'uSaturation')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform1f(uniformLocations.uSaturation,-this.saturation);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate\n   */fabric.Image.filters.Saturation.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Vibrance filter class\n   * @class fabric.Image.filters.Vibrance\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Vibrance#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Vibrance({\n   *   vibrance: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.Vibrance=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Vibrance.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Vibrance',fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform float uVibrance;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'float max = max(color.r, max(color.g, color.b));\\n'+'float avg = (color.r + color.g + color.b) / 3.0;\\n'+'float amt = (abs(max - avg) * 2.0) * uVibrance;\\n'+'color.r += max != color.r ? (max - color.r) * amt : 0.00;\\n'+'color.g += max != color.g ? (max - color.g) * amt : 0.00;\\n'+'color.b += max != color.b ? (max - color.b) * amt : 0.00;\\n'+'gl_FragColor = color;\\n'+'}',/**\n     * Vibrance value, from -1 to 1.\n     * Increases/decreases the saturation of more muted colors with less effect on saturated colors.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} vibrance\n     * @default\n     */vibrance:0,mainParameter:'vibrance',/**\n     * Constructor\n     * @memberOf fabric.Image.filters.Vibrance.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.vibrance=0] Vibrance value for the image (between -1 and 1)\n     */ /**\n     * Apply the Vibrance operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */applyTo2d:function(options){if(this.vibrance===0){return;}var imageData=options.imageData,data=imageData.data,len=data.length,adjust=-this.vibrance,i,max,avg,amt;for(i=0;i<len;i+=4){max=Math.max(data[i],data[i+1],data[i+2]);avg=(data[i]+data[i+1]+data[i+2])/3;amt=Math.abs(max-avg)*2/255*adjust;data[i]+=max!==data[i]?(max-data[i])*amt:0;data[i+1]+=max!==data[i+1]?(max-data[i+1])*amt:0;data[i+2]+=max!==data[i+2]?(max-data[i+2])*amt:0;}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uVibrance:gl.getUniformLocation(program,'uVibrance')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform1f(uniformLocations.uVibrance,-this.vibrance);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Vibrance} Instance of fabric.Image.filters.Vibrance\n   */fabric.Image.filters.Vibrance.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Blur filter class\n   * @class fabric.Image.filters.Blur\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Blur({\n   *   blur: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */filters.Blur=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Blur.prototype */{type:'Blur',/*\n'gl_FragColor = vec4(0.0);',\n'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',\n'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',\n'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',\n*/ /* eslint-disable max-len */fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform vec2 uDelta;\\n'+'varying vec2 vTexCoord;\\n'+'const float nSamples = 15.0;\\n'+'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\\n'+'float random(vec3 scale) {\\n'+/* use the fragment position for a different seed per-pixel */'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\\n'+'}\\n'+'void main() {\\n'+'vec4 color = vec4(0.0);\\n'+'float total = 0.0;\\n'+'float offset = random(v3offset);\\n'+'for (float t = -nSamples; t <= nSamples; t++) {\\n'+'float percent = (t + offset - 0.5) / nSamples;\\n'+'float weight = 1.0 - abs(percent);\\n'+'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\\n'+'total += weight;\\n'+'}\\n'+'gl_FragColor = color / total;\\n'+'}',/* eslint-enable max-len */ /**\n     * blur value, in percentage of image dimensions.\n     * specific to keep the image blur constant at different resolutions\n     * range between 0 and 1.\n     */blur:0,mainParameter:'blur',applyTo:function(options){if(options.webgl){// this aspectRatio is used to give the same blur to vertical and horizontal\nthis.aspectRatio=options.sourceWidth/options.sourceHeight;options.passes++;this._setupFrameBuffer(options);this.horizontal=true;this.applyToWebGL(options);this._swapTextures(options);this._setupFrameBuffer(options);this.horizontal=false;this.applyToWebGL(options);this._swapTextures(options);}else{this.applyTo2d(options);}},applyTo2d:function(options){// paint canvasEl with current image data.\n//options.ctx.putImageData(options.imageData, 0, 0);\noptions.imageData=this.simpleBlur(options);},simpleBlur:function(options){var resources=options.filterBackend.resources,canvas1,canvas2,width=options.imageData.width,height=options.imageData.height;if(!resources.blurLayer1){resources.blurLayer1=fabric.util.createCanvasElement();resources.blurLayer2=fabric.util.createCanvasElement();}canvas1=resources.blurLayer1;canvas2=resources.blurLayer2;if(canvas1.width!==width||canvas1.height!==height){canvas2.width=canvas1.width=width;canvas2.height=canvas1.height=height;}var ctx1=canvas1.getContext('2d'),ctx2=canvas2.getContext('2d'),nSamples=15,random,percent,j,i,blur=this.blur*0.06*0.5;// load first canvas\nctx1.putImageData(options.imageData,0,0);ctx2.clearRect(0,0,width,height);for(i=-nSamples;i<=nSamples;i++){random=(Math.random()-0.5)/4;percent=i/nSamples;j=blur*percent*width+random;ctx2.globalAlpha=1-Math.abs(percent);ctx2.drawImage(canvas1,j,random);ctx1.drawImage(canvas2,0,0);ctx2.globalAlpha=1;ctx2.clearRect(0,0,canvas2.width,canvas2.height);}for(i=-nSamples;i<=nSamples;i++){random=(Math.random()-0.5)/4;percent=i/nSamples;j=blur*percent*height+random;ctx2.globalAlpha=1-Math.abs(percent);ctx2.drawImage(canvas1,random,j);ctx1.drawImage(canvas2,0,0);ctx2.globalAlpha=1;ctx2.clearRect(0,0,canvas2.width,canvas2.height);}options.ctx.drawImage(canvas1,0,0);var newImageData=options.ctx.getImageData(0,0,canvas1.width,canvas1.height);ctx1.globalAlpha=1;ctx1.clearRect(0,0,canvas1.width,canvas1.height);return newImageData;},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{delta:gl.getUniformLocation(program,'uDelta')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){var delta=this.chooseRightDelta();gl.uniform2fv(uniformLocations.delta,delta);},/**\n     * choose right value of image percentage to blur with\n     * @returns {Array} a numeric array with delta values\n     */chooseRightDelta:function(){var blurScale=1,delta=[0,0],blur;if(this.horizontal){if(this.aspectRatio>1){// image is wide, i want to shrink radius horizontal\nblurScale=1/this.aspectRatio;}}else{if(this.aspectRatio<1){// image is tall, i want to shrink radius vertical\nblurScale=this.aspectRatio;}}blur=blurScale*this.blur*0.12;if(this.horizontal){delta[0]=blur;}else{delta[1]=blur;}return delta;}});/**\n   * Deserialize a JSON definition of a BlurFilter into a concrete instance.\n   */filters.Blur.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * Gamma filter class\n   * @class fabric.Image.filters.Gamma\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Gamma({\n   *   gamma: [1, 0.5, 2.1]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.Gamma=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Gamma.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'Gamma',fragmentSource:'precision highp float;\\n'+'uniform sampler2D uTexture;\\n'+'uniform vec3 uGamma;\\n'+'varying vec2 vTexCoord;\\n'+'void main() {\\n'+'vec4 color = texture2D(uTexture, vTexCoord);\\n'+'vec3 correction = (1.0 / uGamma);\\n'+'color.r = pow(color.r, correction.r);\\n'+'color.g = pow(color.g, correction.g);\\n'+'color.b = pow(color.b, correction.b);\\n'+'gl_FragColor = color;\\n'+'gl_FragColor.rgb *= color.a;\\n'+'}',/**\n     * Gamma array value, from 0.01 to 2.2.\n     * @param {Array} gamma\n     * @default\n     */gamma:[1,1,1],/**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */mainParameter:'gamma',/**\n     * Constructor\n     * @param {Object} [options] Options object\n     */initialize:function(options){this.gamma=[1,1,1];filters.BaseFilter.prototype.initialize.call(this,options);},/**\n     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */applyTo2d:function(options){var imageData=options.imageData,data=imageData.data,gamma=this.gamma,len=data.length,rInv=1/gamma[0],gInv=1/gamma[1],bInv=1/gamma[2],i;if(!this.rVals){// eslint-disable-next-line\nthis.rVals=new Uint8Array(256);// eslint-disable-next-line\nthis.gVals=new Uint8Array(256);// eslint-disable-next-line\nthis.bVals=new Uint8Array(256);}// This is an optimization - pre-compute a look-up table for each color channel\n// instead of performing these pow calls for each pixel in the image.\nfor(i=0,len=256;i<len;i++){this.rVals[i]=Math.pow(i/255,rInv)*255;this.gVals[i]=Math.pow(i/255,gInv)*255;this.bVals[i]=Math.pow(i/255,bInv)*255;}for(i=0,len=data.length;i<len;i+=4){data[i]=this.rVals[data[i]];data[i+1]=this.gVals[data[i+1]];data[i+2]=this.bVals[data[i+2]];}},/**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */getUniformLocations:function(gl,program){return{uGamma:gl.getUniformLocation(program,'uGamma')};},/**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */sendUniformData:function(gl,uniformLocations){gl.uniform3fv(uniformLocations.uGamma,this.gamma);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma\n   */fabric.Image.filters.Gamma.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * A container class that knows how to apply a sequence of filters to an input image.\n   */filters.Composed=createClass(filters.BaseFilter,/** @lends fabric.Image.filters.Composed.prototype */{type:'Composed',/**\n     * A non sparse array of filters to apply\n     */subFilters:[],/**\n     * Constructor\n     * @param {Object} [options] Options object\n     */initialize:function(options){this.callSuper('initialize',options);// create a new array instead mutating the prototype with push\nthis.subFilters=this.subFilters.slice(0);},/**\n     * Apply this container's filters to the input image provided.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be applied.\n     */applyTo:function(options){options.passes+=this.subFilters.length-1;this.subFilters.forEach(function(filter){filter.applyTo(options);});},/**\n     * Serialize this filter into JSON.\n     *\n     * @returns {Object} A JSON representation of this filter.\n     */toObject:function(){return fabric.util.object.extend(this.callSuper('toObject'),{subFilters:this.subFilters.map(function(filter){return filter.toObject();})});},isNeutralState:function(){return!this.subFilters.some(function(filter){return!filter.isNeutralState();});}});/**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   */fabric.Image.filters.Composed.fromObject=function(object,callback){var filters=object.subFilters||[],subFilters=filters.map(function(filter){return new fabric.Image.filters[filter.type](filter);}),instance=new fabric.Image.filters.Composed({subFilters:subFilters});callback&&callback(instance);return instance;};})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),filters=fabric.Image.filters,createClass=fabric.util.createClass;/**\n   * HueRotation filter class\n   * @class fabric.Image.filters.HueRotation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.HueRotation({\n   *   rotation: -0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */filters.HueRotation=createClass(filters.ColorMatrix,/** @lends fabric.Image.filters.HueRotation.prototype */{/**\n     * Filter type\n     * @param {String} type\n     * @default\n     */type:'HueRotation',/**\n     * HueRotation value, from -1 to 1.\n     * the unit is radians\n     * @param {Number} myParameter\n     * @default\n     */rotation:0,/**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */mainParameter:'rotation',calculateMatrix:function(){var rad=this.rotation*Math.PI,cos=fabric.util.cos(rad),sin=fabric.util.sin(rad),aThird=1/3,aThirdSqtSin=Math.sqrt(aThird)*sin,OneMinusCos=1-cos;this.matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];this.matrix[0]=cos+OneMinusCos/3;this.matrix[1]=aThird*OneMinusCos-aThirdSqtSin;this.matrix[2]=aThird*OneMinusCos+aThirdSqtSin;this.matrix[5]=aThird*OneMinusCos+aThirdSqtSin;this.matrix[6]=cos+aThird*OneMinusCos;this.matrix[7]=aThird*OneMinusCos-aThirdSqtSin;this.matrix[10]=aThird*OneMinusCos-aThirdSqtSin;this.matrix[11]=aThird*OneMinusCos+aThirdSqtSin;this.matrix[12]=cos+aThird*OneMinusCos;},/**\n     * HueRotation isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/isNeutralState:function(options){this.calculateMatrix();return filters.BaseFilter.prototype.isNeutralState.call(this,options);},/**\n     * Apply this filter to the input image data provided.\n     *\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */applyTo:function(options){this.calculateMatrix();filters.BaseFilter.prototype.applyTo.call(this,options);}});/**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation\n   */fabric.Image.filters.HueRotation.fromObject=fabric.Image.filters.BaseFilter.fromObject;})( true?exports:0);(function(global){'use strict';var fabric=global.fabric||(global.fabric={}),clone=fabric.util.object.clone;if(fabric.Text){fabric.warn('fabric.Text is already defined');return;}var additionalProps=('fontFamily fontWeight fontSize text underline overline linethrough'+' textAlign fontStyle lineHeight textBackgroundColor charSpacing styles'+' direction path pathStartOffset pathSide').split(' ');/**\n   * Text class\n   * @class fabric.Text\n   * @extends fabric.Object\n   * @return {fabric.Text} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}\n   * @see {@link fabric.Text#initialize} for constructor definition\n   */fabric.Text=fabric.util.createClass(fabric.Object,/** @lends fabric.Text.prototype */{/**\n     * Properties which when set cause object to change dimensions\n     * @type Array\n     * @private\n     */_dimensionAffectingProps:['fontSize','fontWeight','fontFamily','fontStyle','lineHeight','text','charSpacing','textAlign','styles','path','pathStartOffset','pathSide'],/**\n     * @private\n     */_reNewline:/\\r?\\n/,/**\n     * Use this regular expression to filter for whitespaces that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */_reSpacesAndTabs:/[ \\t\\r]/g,/**\n     * Use this regular expression to filter for whitespace that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */_reSpaceAndTab:/[ \\t\\r]/,/**\n     * Use this regular expression to filter consecutive groups of non spaces.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */_reWords:/\\S+/g,/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'text',/**\n     * Font size (in pixels)\n     * @type Number\n     * @default\n     */fontSize:40,/**\n     * Font weight (e.g. bold, normal, 400, 600, 800)\n     * @type {(Number|String)}\n     * @default\n     */fontWeight:'normal',/**\n     * Font family\n     * @type String\n     * @default\n     */fontFamily:'Times New Roman',/**\n     * Text decoration underline.\n     * @type Boolean\n     * @default\n     */underline:false,/**\n     * Text decoration overline.\n     * @type Boolean\n     * @default\n     */overline:false,/**\n     * Text decoration linethrough.\n     * @type Boolean\n     * @default\n     */linethrough:false,/**\n     * Text alignment. Possible values: \"left\", \"center\", \"right\", \"justify\",\n     * \"justify-left\", \"justify-center\" or \"justify-right\".\n     * @type String\n     * @default\n     */textAlign:'left',/**\n     * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\n     * @type String\n     * @default\n     */fontStyle:'normal',/**\n     * Line height\n     * @type Number\n     * @default\n     */lineHeight:1.16,/**\n     * Superscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */superscript:{size:0.60,// fontSize factor\nbaseline:-0.35// baseline-shift factor (upwards)\n},/**\n     * Subscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */subscript:{size:0.60,// fontSize factor\nbaseline:0.11// baseline-shift factor (downwards)\n},/**\n     * Background color of text lines\n     * @type String\n     * @default\n     */textBackgroundColor:'',/**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */stateProperties:fabric.Object.prototype.stateProperties.concat(additionalProps),/**\n     * List of properties to consider when checking if cache needs refresh\n     * @type Array\n     */cacheProperties:fabric.Object.prototype.cacheProperties.concat(additionalProps),/**\n     * When defined, an object is rendered via stroke and this property specifies its color.\n     * <b>Backwards incompatibility note:</b> This property was named \"strokeStyle\" until v1.1.6\n     * @type String\n     * @default\n     */stroke:null,/**\n     * Shadow object representing shadow of this shape.\n     * <b>Backwards incompatibility note:</b> This property was named \"textShadow\" (String) until v1.2.11\n     * @type fabric.Shadow\n     * @default\n     */shadow:null,/**\n     * fabric.Path that the text should follow.\n     * since 4.6.0 the path will be drawn automatically.\n     * if you want to make the path visible, give it a stroke and strokeWidth or fill value\n     * if you want it to be hidden, assign visible = false to the path.\n     * This feature is in BETA, and SVG import/export is not yet supported.\n     * @type fabric.Path\n     * @example\n     * var textPath = new fabric.Text('Text on a path', {\n     *     top: 150,\n     *     left: 150,\n     *     textAlign: 'center',\n     *     charSpacing: -50,\n     *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {\n     *         strokeWidth: 1,\n     *         visible: false\n     *     }),\n     *     pathSide: 'left',\n     *     pathStartOffset: 0\n     * });\n     * @default\n     */path:null,/**\n     * Offset amount for text path starting position\n     * Only used when text has a path\n     * @type Number\n     * @default\n     */pathStartOffset:0,/**\n     * Which side of the path the text should be drawn on.\n     * Only used when text has a path\n     * @type {String} 'left|right'\n     * @default\n     */pathSide:'left',/**\n     * @private\n     */_fontSizeFraction:0.222,/**\n     * @private\n     */offsets:{underline:0.10,linethrough:-0.315,overline:-0.88},/**\n     * Text Line proportion to font Size (in pixels)\n     * @type Number\n     * @default\n     */_fontSizeMult:1.13,/**\n     * additional space between characters\n     * expressed in thousands of em unit\n     * @type Number\n     * @default\n     */charSpacing:0,/**\n     * Object containing character styles - top-level properties -> line numbers,\n     * 2nd-level properties - character numbers\n     * @type Object\n     * @default\n     */styles:null,/**\n     * Reference to a context to measure text char or couple of chars\n     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas\n     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every\n     * text object created.\n     * @type {CanvasRenderingContext2D}\n     * @default\n     */_measuringContext:null,/**\n     * Baseline shift, styles only, keep at 0 for the main text object\n     * @type {Number}\n     * @default\n     */deltaY:0,/**\n     * WARNING: EXPERIMENTAL. NOT SUPPORTED YET\n     * determine the direction of the text.\n     * This has to be set manually together with textAlign and originX for proper\n     * experience.\n     * some interesting link for the future\n     * https://www.w3.org/International/questions/qa-bidi-unicode-controls\n     * @since 4.5.0\n     * @type {String} 'ltr|rtl'\n     * @default\n     */direction:'ltr',/**\n     * Array of properties that define a style unit (of 'styles').\n     * @type {Array}\n     * @default\n     */_styleProperties:['stroke','strokeWidth','fill','fontFamily','fontSize','fontWeight','fontStyle','underline','overline','linethrough','deltaY','textBackgroundColor'],/**\n     * contains characters bounding boxes\n     */__charBounds:[],/**\n     * use this size when measuring text. To avoid IE11 rounding errors\n     * @type {Number}\n     * @default\n     * @readonly\n     * @private\n     */CACHE_FONT_SIZE:400,/**\n     * contains the min text width to avoid getting 0\n     * @type {Number}\n     * @default\n     */MIN_TEXT_WIDTH:2,/**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */initialize:function(text,options){this.styles=options?options.styles||{}:{};this.text=text;this.__skipDimension=true;this.callSuper('initialize',options);if(this.path){this.setPathInfo();}this.__skipDimension=false;this.initDimensions();this.setCoords();this.setupState({propertySet:'_dimensionAffectingProps'});},/**\n     * If text has a path, it will add the extra information needed\n     * for path and text calculations\n     * @return {fabric.Text} thisArg\n     */setPathInfo:function(){var path=this.path;if(path){path.segmentsInfo=fabric.util.getPathSegmentsInfo(path.path);}},/**\n     * Return a context for measurement of text string.\n     * if created it gets stored for reuse\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */getMeasuringContext:function(){// if we did not return we have to measure something.\nif(!fabric._measuringContext){fabric._measuringContext=this.canvas&&this.canvas.contextCache||fabric.util.createCanvasElement().getContext('2d');}return fabric._measuringContext;},/**\n     * @private\n     * Divides text into lines of text and lines of graphemes.\n     */_splitText:function(){var newLines=this._splitTextIntoLines(this.text);this.textLines=newLines.lines;this._textLines=newLines.graphemeLines;this._unwrappedTextLines=newLines._unwrappedLines;this._text=newLines.graphemeText;return newLines;},/**\n     * Initialize or update text dimensions.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     */initDimensions:function(){if(this.__skipDimension){return;}this._splitText();this._clearCache();if(this.path){this.width=this.path.width;this.height=this.path.height;}else{this.width=this.calcTextWidth()||this.cursorWidth||this.MIN_TEXT_WIDTH;this.height=this.calcTextHeight();}if(this.textAlign.indexOf('justify')!==-1){// once text is measured we need to make space fatter to make justified text.\nthis.enlargeSpaces();}this.saveState({propertySet:'_dimensionAffectingProps'});},/**\n     * Enlarge space boxes and shift the others\n     */enlargeSpaces:function(){var diffSpace,currentLineWidth,numberOfSpaces,accumulatedSpace,line,charBound,spaces;for(var i=0,len=this._textLines.length;i<len;i++){if(this.textAlign!=='justify'&&(i===len-1||this.isEndOfWrapping(i))){continue;}accumulatedSpace=0;line=this._textLines[i];currentLineWidth=this.getLineWidth(i);if(currentLineWidth<this.width&&(spaces=this.textLines[i].match(this._reSpacesAndTabs))){numberOfSpaces=spaces.length;diffSpace=(this.width-currentLineWidth)/numberOfSpaces;for(var j=0,jlen=line.length;j<=jlen;j++){charBound=this.__charBounds[i][j];if(this._reSpaceAndTab.test(line[j])){charBound.width+=diffSpace;charBound.kernedWidth+=diffSpace;charBound.left+=accumulatedSpace;accumulatedSpace+=diffSpace;}else{charBound.left+=accumulatedSpace;}}}}},/**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @return {Boolean}\n     */isEndOfWrapping:function(lineIndex){return lineIndex===this._textLines.length-1;},/**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * It return always for text and Itext.\n     * @return Number\n     */missingNewlineOffset:function(){return 1;},/**\n     * Returns string representation of an instance\n     * @return {String} String representation of text object\n     */toString:function(){return'#<fabric.Text ('+this.complexity()+'): { \"text\": \"'+this.text+'\", \"fontFamily\": \"'+this.fontFamily+'\" }>';},/**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @param {Object} dim.x width of object to be cached\n     * @param {Object} dim.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */_getCacheCanvasDimensions:function(){var dims=this.callSuper('_getCacheCanvasDimensions');var fontSize=this.fontSize;dims.width+=fontSize*dims.zoomX;dims.height+=fontSize*dims.zoomY;return dims;},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function(ctx){var path=this.path;path&&!path.isNotVisible()&&path._render(ctx);this._setTextStyles(ctx);this._renderTextLinesBackground(ctx);this._renderTextDecoration(ctx,'underline');this._renderText(ctx);this._renderTextDecoration(ctx,'overline');this._renderTextDecoration(ctx,'linethrough');},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderText:function(ctx){if(this.paintFirst==='stroke'){this._renderTextStroke(ctx);this._renderTextFill(ctx);}else{this._renderTextFill(ctx);this._renderTextStroke(ctx);}},/**\n     * Set the font parameter of the context with the object properties or with charStyle\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [charStyle] object with font style properties\n     * @param {String} [charStyle.fontFamily] Font Family\n     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )\n     * @param {String} [charStyle.fontWeight] Font weight\n     * @param {String} [charStyle.fontStyle] Font style (italic|normal)\n     */_setTextStyles:function(ctx,charStyle,forMeasuring){ctx.textBaseline='alphabetic';ctx.font=this._getFontDeclaration(charStyle,forMeasuring);},/**\n     * calculate and return the text Width measuring each line.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {Number} Maximum width of fabric.Text object\n     */calcTextWidth:function(){var maxWidth=this.getLineWidth(0);for(var i=1,len=this._textLines.length;i<len;i++){var currentLineWidth=this.getLineWidth(i);if(currentLineWidth>maxWidth){maxWidth=currentLineWidth;}}return maxWidth;},/**\n     * @private\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} line Text to render\n     * @param {Number} left Left position of text\n     * @param {Number} top Top position of text\n     * @param {Number} lineIndex Index of a line in a text\n     */_renderTextLine:function(method,ctx,line,left,top,lineIndex){this._renderChars(method,ctx,line,left,top,lineIndex);},/**\n     * Renders the text background for lines, taking care of style\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderTextLinesBackground:function(ctx){if(!this.textBackgroundColor&&!this.styleHas('textBackgroundColor')){return;}var heightOfLine,lineLeftOffset,originalFill=ctx.fillStyle,line,lastColor,leftOffset=this._getLeftOffset(),lineTopOffset=this._getTopOffset(),boxStart=0,boxWidth=0,charBox,currentColor,path=this.path,drawStart;for(var i=0,len=this._textLines.length;i<len;i++){heightOfLine=this.getHeightOfLine(i);if(!this.textBackgroundColor&&!this.styleHas('textBackgroundColor',i)){lineTopOffset+=heightOfLine;continue;}line=this._textLines[i];lineLeftOffset=this._getLineLeftOffset(i);boxWidth=0;boxStart=0;lastColor=this.getValueOfPropertyAt(i,0,'textBackgroundColor');for(var j=0,jlen=line.length;j<jlen;j++){charBox=this.__charBounds[i][j];currentColor=this.getValueOfPropertyAt(i,j,'textBackgroundColor');if(path){ctx.save();ctx.translate(charBox.renderLeft,charBox.renderTop);ctx.rotate(charBox.angle);ctx.fillStyle=currentColor;currentColor&&ctx.fillRect(-charBox.width/2,-heightOfLine/this.lineHeight*(1-this._fontSizeFraction),charBox.width,heightOfLine/this.lineHeight);ctx.restore();}else if(currentColor!==lastColor){drawStart=leftOffset+lineLeftOffset+boxStart;if(this.direction==='rtl'){drawStart=this.width-drawStart-boxWidth;}ctx.fillStyle=lastColor;lastColor&&ctx.fillRect(drawStart,lineTopOffset,boxWidth,heightOfLine/this.lineHeight);boxStart=charBox.left;boxWidth=charBox.width;lastColor=currentColor;}else{boxWidth+=charBox.kernedWidth;}}if(currentColor&&!path){drawStart=leftOffset+lineLeftOffset+boxStart;if(this.direction==='rtl'){drawStart=this.width-drawStart-boxWidth;}ctx.fillStyle=currentColor;ctx.fillRect(drawStart,lineTopOffset,boxWidth,heightOfLine/this.lineHeight);}lineTopOffset+=heightOfLine;}ctx.fillStyle=originalFill;// if there is text background color no\n// other shadows should be casted\nthis._removeShadow(ctx);},/**\n     * @private\n     * @param {Object} decl style declaration for cache\n     * @param {String} decl.fontFamily fontFamily\n     * @param {String} decl.fontStyle fontStyle\n     * @param {String} decl.fontWeight fontWeight\n     * @return {Object} reference to cache\n     */getFontCache:function(decl){var fontFamily=decl.fontFamily.toLowerCase();if(!fabric.charWidthsCache[fontFamily]){fabric.charWidthsCache[fontFamily]={};}var cache=fabric.charWidthsCache[fontFamily],cacheProp=decl.fontStyle.toLowerCase()+'_'+(decl.fontWeight+'').toLowerCase();if(!cache[cacheProp]){cache[cacheProp]={};}return cache[cacheProp];},/**\n     * measure and return the width of a single character.\n     * possibly overridden to accommodate different measure logic or\n     * to hook some external lib for character measurement\n     * @private\n     * @param {String} _char, char to be measured\n     * @param {Object} charStyle style of char to be measured\n     * @param {String} [previousChar] previous char\n     * @param {Object} [prevCharStyle] style of previous char\n     */_measureChar:function(_char,charStyle,previousChar,prevCharStyle){// first i try to return from cache\nvar fontCache=this.getFontCache(charStyle),fontDeclaration=this._getFontDeclaration(charStyle),previousFontDeclaration=this._getFontDeclaration(prevCharStyle),couple=previousChar+_char,stylesAreEqual=fontDeclaration===previousFontDeclaration,width,coupleWidth,previousWidth,fontMultiplier=charStyle.fontSize/this.CACHE_FONT_SIZE,kernedWidth;if(previousChar&&fontCache[previousChar]!==undefined){previousWidth=fontCache[previousChar];}if(fontCache[_char]!==undefined){kernedWidth=width=fontCache[_char];}if(stylesAreEqual&&fontCache[couple]!==undefined){coupleWidth=fontCache[couple];kernedWidth=coupleWidth-previousWidth;}if(width===undefined||previousWidth===undefined||coupleWidth===undefined){var ctx=this.getMeasuringContext();// send a TRUE to specify measuring font size CACHE_FONT_SIZE\nthis._setTextStyles(ctx,charStyle,true);}if(width===undefined){kernedWidth=width=ctx.measureText(_char).width;fontCache[_char]=width;}if(previousWidth===undefined&&stylesAreEqual&&previousChar){previousWidth=ctx.measureText(previousChar).width;fontCache[previousChar]=previousWidth;}if(stylesAreEqual&&coupleWidth===undefined){// we can measure the kerning couple and subtract the width of the previous character\ncoupleWidth=ctx.measureText(couple).width;fontCache[couple]=coupleWidth;kernedWidth=coupleWidth-previousWidth;}return{width:width*fontMultiplier,kernedWidth:kernedWidth*fontMultiplier};},/**\n     * Computes height of character at given position\n     * @param {Number} line the line index number\n     * @param {Number} _char the character index number\n     * @return {Number} fontSize of the character\n     */getHeightOfChar:function(line,_char){return this.getValueOfPropertyAt(line,_char,'fontSize');},/**\n     * measure a text line measuring all characters.\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */measureLine:function(lineIndex){var lineInfo=this._measureLine(lineIndex);if(this.charSpacing!==0){lineInfo.width-=this._getWidthOfCharSpacing();}if(lineInfo.width<0){lineInfo.width=0;}return lineInfo;},/**\n     * measure every grapheme of a line, populating __charBounds\n     * @param {Number} lineIndex\n     * @return {Object} object.width total width of characters\n     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs\n     */_measureLine:function(lineIndex){var width=0,i,grapheme,line=this._textLines[lineIndex],prevGrapheme,graphemeInfo,numOfSpaces=0,lineBounds=new Array(line.length),positionInPath=0,startingPoint,totalPathLength,path=this.path,reverse=this.pathSide==='right';this.__charBounds[lineIndex]=lineBounds;for(i=0;i<line.length;i++){grapheme=line[i];graphemeInfo=this._getGraphemeBox(grapheme,lineIndex,i,prevGrapheme);lineBounds[i]=graphemeInfo;width+=graphemeInfo.kernedWidth;prevGrapheme=grapheme;}// this latest bound box represent the last character of the line\n// to simplify cursor handling in interactive mode.\nlineBounds[i]={left:graphemeInfo?graphemeInfo.left+graphemeInfo.width:0,width:0,kernedWidth:0,height:this.fontSize};if(path){totalPathLength=path.segmentsInfo[path.segmentsInfo.length-1].length;startingPoint=fabric.util.getPointOnPath(path.path,0,path.segmentsInfo);startingPoint.x+=path.pathOffset.x;startingPoint.y+=path.pathOffset.y;switch(this.textAlign){case'left':positionInPath=reverse?totalPathLength-width:0;break;case'center':positionInPath=(totalPathLength-width)/2;break;case'right':positionInPath=reverse?0:totalPathLength-width;break;//todo - add support for justify\n}positionInPath+=this.pathStartOffset*(reverse?-1:1);for(i=reverse?line.length-1:0;reverse?i>=0:i<line.length;reverse?i--:i++){graphemeInfo=lineBounds[i];if(positionInPath>totalPathLength){positionInPath%=totalPathLength;}else if(positionInPath<0){positionInPath+=totalPathLength;}// it would probably much faster to send all the grapheme position for a line\n// and calculate path position/angle at once.\nthis._setGraphemeOnPath(positionInPath,graphemeInfo,startingPoint);positionInPath+=graphemeInfo.kernedWidth;}}return{width:width,numOfSpaces:numOfSpaces};},/**\n     * Calculate the angle  and the left,top position of the char that follow a path.\n     * It appends it to graphemeInfo to be reused later at rendering\n     * @private\n     * @param {Number} positionInPath to be measured\n     * @param {Object} graphemeInfo current grapheme box information\n     * @param {Object} startingPoint position of the point\n     */_setGraphemeOnPath:function(positionInPath,graphemeInfo,startingPoint){var centerPosition=positionInPath+graphemeInfo.kernedWidth/2,path=this.path;// we are at currentPositionOnPath. we want to know what point on the path is.\nvar info=fabric.util.getPointOnPath(path.path,centerPosition,path.segmentsInfo);graphemeInfo.renderLeft=info.x-startingPoint.x;graphemeInfo.renderTop=info.y-startingPoint.y;graphemeInfo.angle=info.angle+(this.pathSide==='right'?Math.PI:0);},/**\n     * Measure and return the info of a single grapheme.\n     * needs the the info of previous graphemes already filled\n     * @private\n     * @param {String} grapheme to be measured\n     * @param {Number} lineIndex index of the line where the char is\n     * @param {Number} charIndex position in the line\n     * @param {String} [prevGrapheme] character preceding the one to be measured\n     */_getGraphemeBox:function(grapheme,lineIndex,charIndex,prevGrapheme,skipLeft){var style=this.getCompleteStyleDeclaration(lineIndex,charIndex),prevStyle=prevGrapheme?this.getCompleteStyleDeclaration(lineIndex,charIndex-1):{},info=this._measureChar(grapheme,style,prevGrapheme,prevStyle),kernedWidth=info.kernedWidth,width=info.width,charSpacing;if(this.charSpacing!==0){charSpacing=this._getWidthOfCharSpacing();width+=charSpacing;kernedWidth+=charSpacing;}var box={width:width,left:0,height:style.fontSize,kernedWidth:kernedWidth,deltaY:style.deltaY};if(charIndex>0&&!skipLeft){var previousBox=this.__charBounds[lineIndex][charIndex-1];box.left=previousBox.left+previousBox.width+info.kernedWidth-info.width;}return box;},/**\n     * Calculate height of line at 'lineIndex'\n     * @param {Number} lineIndex index of line to calculate\n     * @return {Number}\n     */getHeightOfLine:function(lineIndex){if(this.__lineHeights[lineIndex]){return this.__lineHeights[lineIndex];}var line=this._textLines[lineIndex],// char 0 is measured before the line cycle because it nneds to char\n// emptylines\nmaxHeight=this.getHeightOfChar(lineIndex,0);for(var i=1,len=line.length;i<len;i++){maxHeight=Math.max(this.getHeightOfChar(lineIndex,i),maxHeight);}return this.__lineHeights[lineIndex]=maxHeight*this.lineHeight*this._fontSizeMult;},/**\n     * Calculate text box height\n     */calcTextHeight:function(){var lineHeight,height=0;for(var i=0,len=this._textLines.length;i<len;i++){lineHeight=this.getHeightOfLine(i);height+=i===len-1?lineHeight/this.lineHeight:lineHeight;}return height;},/**\n     * @private\n     * @return {Number} Left offset\n     */_getLeftOffset:function(){return this.direction==='ltr'?-this.width/2:this.width/2;},/**\n     * @private\n     * @return {Number} Top offset\n     */_getTopOffset:function(){return-this.height/2;},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     */_renderTextCommon:function(ctx,method){ctx.save();var lineHeights=0,left=this._getLeftOffset(),top=this._getTopOffset();for(var i=0,len=this._textLines.length;i<len;i++){var heightOfLine=this.getHeightOfLine(i),maxHeight=heightOfLine/this.lineHeight,leftOffset=this._getLineLeftOffset(i);this._renderTextLine(method,ctx,this._textLines[i],left+leftOffset,top+lineHeights+maxHeight,i);lineHeights+=heightOfLine;}ctx.restore();},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderTextFill:function(ctx){if(!this.fill&&!this.styleHas('fill')){return;}this._renderTextCommon(ctx,'fillText');},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderTextStroke:function(ctx){if((!this.stroke||this.strokeWidth===0)&&this.isEmptyStyles()){return;}if(this.shadow&&!this.shadow.affectStroke){this._removeShadow(ctx);}ctx.save();this._setLineDash(ctx,this.strokeDashArray);ctx.beginPath();this._renderTextCommon(ctx,'strokeText');ctx.closePath();ctx.restore();},/**\n     * @private\n     * @param {String} method fillText or strokeText.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} line Content of the line, splitted in an array by grapheme\n     * @param {Number} left\n     * @param {Number} top\n     * @param {Number} lineIndex\n     */_renderChars:function(method,ctx,line,left,top,lineIndex){// set proper line offset\nvar lineHeight=this.getHeightOfLine(lineIndex),isJustify=this.textAlign.indexOf('justify')!==-1,actualStyle,nextStyle,charsToRender='',charBox,boxWidth=0,timeToRender,path=this.path,shortCut=!isJustify&&this.charSpacing===0&&this.isEmptyStyles(lineIndex)&&!path,isLtr=this.direction==='ltr',sign=this.direction==='ltr'?1:-1,drawingLeft;ctx.save();top-=lineHeight*this._fontSizeFraction/this.lineHeight;if(shortCut){// render all the line in one pass without checking\n// drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);\nctx.canvas.setAttribute('dir',isLtr?'ltr':'rtl');ctx.direction=isLtr?'ltr':'rtl';ctx.textAlign=isLtr?'left':'right';this._renderChar(method,ctx,lineIndex,0,line.join(''),left,top,lineHeight);ctx.restore();return;}for(var i=0,len=line.length-1;i<=len;i++){timeToRender=i===len||this.charSpacing||path;charsToRender+=line[i];charBox=this.__charBounds[lineIndex][i];if(boxWidth===0){left+=sign*(charBox.kernedWidth-charBox.width);boxWidth+=charBox.width;}else{boxWidth+=charBox.kernedWidth;}if(isJustify&&!timeToRender){if(this._reSpaceAndTab.test(line[i])){timeToRender=true;}}if(!timeToRender){// if we have charSpacing, we render char by char\nactualStyle=actualStyle||this.getCompleteStyleDeclaration(lineIndex,i);nextStyle=this.getCompleteStyleDeclaration(lineIndex,i+1);timeToRender=this._hasStyleChanged(actualStyle,nextStyle);}if(timeToRender){if(path){ctx.save();ctx.translate(charBox.renderLeft,charBox.renderTop);ctx.rotate(charBox.angle);this._renderChar(method,ctx,lineIndex,i,charsToRender,-boxWidth/2,0,lineHeight);ctx.restore();}else{drawingLeft=left;ctx.canvas.setAttribute('dir',isLtr?'ltr':'rtl');ctx.direction=isLtr?'ltr':'rtl';ctx.textAlign=isLtr?'left':'right';this._renderChar(method,ctx,lineIndex,i,charsToRender,drawingLeft,top,lineHeight);}charsToRender='';actualStyle=nextStyle;left+=sign*boxWidth;boxWidth=0;}}ctx.restore();},/**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     * @return {CanvasPattern} a pattern to use as fill/stroke style\n     */_applyPatternGradientTransformText:function(filler){var pCanvas=fabric.util.createCanvasElement(),pCtx,// TODO: verify compatibility with strokeUniform\nwidth=this.width+this.strokeWidth,height=this.height+this.strokeWidth;pCanvas.width=width;pCanvas.height=height;pCtx=pCanvas.getContext('2d');pCtx.beginPath();pCtx.moveTo(0,0);pCtx.lineTo(width,0);pCtx.lineTo(width,height);pCtx.lineTo(0,height);pCtx.closePath();pCtx.translate(width/2,height/2);pCtx.fillStyle=filler.toLive(pCtx);this._applyPatternGradientTransform(pCtx,filler);pCtx.fill();return pCtx.createPattern(pCanvas,'no-repeat');},handleFiller:function(ctx,property,filler){var offsetX,offsetY;if(filler.toLive){if(filler.gradientUnits==='percentage'||filler.gradientTransform||filler.patternTransform){// need to transform gradient in a pattern.\n// this is a slow process. If you are hitting this codepath, and the object\n// is not using caching, you should consider switching it on.\n// we need a canvas as big as the current object caching canvas.\noffsetX=-this.width/2;offsetY=-this.height/2;ctx.translate(offsetX,offsetY);ctx[property]=this._applyPatternGradientTransformText(filler);return{offsetX:offsetX,offsetY:offsetY};}else{// is a simple gradient or pattern\nctx[property]=filler.toLive(ctx,this);return this._applyPatternGradientTransform(ctx,filler);}}else{// is a color\nctx[property]=filler;}return{offsetX:0,offsetY:0};},_setStrokeStyles:function(ctx,decl){ctx.lineWidth=decl.strokeWidth;ctx.lineCap=this.strokeLineCap;ctx.lineDashOffset=this.strokeDashOffset;ctx.lineJoin=this.strokeLineJoin;ctx.miterLimit=this.strokeMiterLimit;return this.handleFiller(ctx,'strokeStyle',decl.stroke);},_setFillStyles:function(ctx,decl){return this.handleFiller(ctx,'fillStyle',decl.fill);},/**\n     * @private\n     * @param {String} method\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {String} _char\n     * @param {Number} left Left coordinate\n     * @param {Number} top Top coordinate\n     * @param {Number} lineHeight Height of the line\n     */_renderChar:function(method,ctx,lineIndex,charIndex,_char,left,top){var decl=this._getStyleDeclaration(lineIndex,charIndex),fullDecl=this.getCompleteStyleDeclaration(lineIndex,charIndex),shouldFill=method==='fillText'&&fullDecl.fill,shouldStroke=method==='strokeText'&&fullDecl.stroke&&fullDecl.strokeWidth,fillOffsets,strokeOffsets;if(!shouldStroke&&!shouldFill){return;}ctx.save();shouldFill&&(fillOffsets=this._setFillStyles(ctx,fullDecl));shouldStroke&&(strokeOffsets=this._setStrokeStyles(ctx,fullDecl));ctx.font=this._getFontDeclaration(fullDecl);if(decl&&decl.textBackgroundColor){this._removeShadow(ctx);}if(decl&&decl.deltaY){top+=decl.deltaY;}shouldFill&&ctx.fillText(_char,left-fillOffsets.offsetX,top-fillOffsets.offsetY);shouldStroke&&ctx.strokeText(_char,left-strokeOffsets.offsetX,top-strokeOffsets.offsetY);ctx.restore();},/**\n     * Turns the character into a 'superior figure' (i.e. 'superscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */setSuperscript:function(start,end){return this._setScript(start,end,this.superscript);},/**\n     * Turns the character into an 'inferior figure' (i.e. 'subscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */setSubscript:function(start,end){return this._setScript(start,end,this.subscript);},/**\n     * Applies 'schema' at given position\n     * @private\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @param {Number} schema\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */_setScript:function(start,end,schema){var loc=this.get2DCursorLocation(start,true),fontSize=this.getValueOfPropertyAt(loc.lineIndex,loc.charIndex,'fontSize'),dy=this.getValueOfPropertyAt(loc.lineIndex,loc.charIndex,'deltaY'),style={fontSize:fontSize*schema.size,deltaY:dy+fontSize*schema.baseline};this.setSelectionStyles(style,start,end);return this;},/**\n     * @private\n     * @param {Object} prevStyle\n     * @param {Object} thisStyle\n     */_hasStyleChanged:function(prevStyle,thisStyle){return prevStyle.fill!==thisStyle.fill||prevStyle.stroke!==thisStyle.stroke||prevStyle.strokeWidth!==thisStyle.strokeWidth||prevStyle.fontSize!==thisStyle.fontSize||prevStyle.fontFamily!==thisStyle.fontFamily||prevStyle.fontWeight!==thisStyle.fontWeight||prevStyle.fontStyle!==thisStyle.fontStyle||prevStyle.deltaY!==thisStyle.deltaY;},/**\n     * @private\n     * @param {Object} prevStyle\n     * @param {Object} thisStyle\n     */_hasStyleChangedForSvg:function(prevStyle,thisStyle){return this._hasStyleChanged(prevStyle,thisStyle)||prevStyle.overline!==thisStyle.overline||prevStyle.underline!==thisStyle.underline||prevStyle.linethrough!==thisStyle.linethrough;},/**\n     * @private\n     * @param {Number} lineIndex index text line\n     * @return {Number} Line left offset\n     */_getLineLeftOffset:function(lineIndex){var lineWidth=this.getLineWidth(lineIndex),lineDiff=this.width-lineWidth,textAlign=this.textAlign,direction=this.direction,isEndOfWrapping,leftOffset=0,isEndOfWrapping=this.isEndOfWrapping(lineIndex);if(textAlign==='justify'||textAlign==='justify-center'&&!isEndOfWrapping||textAlign==='justify-right'&&!isEndOfWrapping||textAlign==='justify-left'&&!isEndOfWrapping){return 0;}if(textAlign==='center'){leftOffset=lineDiff/2;}if(textAlign==='right'){leftOffset=lineDiff;}if(textAlign==='justify-center'){leftOffset=lineDiff/2;}if(textAlign==='justify-right'){leftOffset=lineDiff;}if(direction==='rtl'){leftOffset-=lineDiff;}return leftOffset;},/**\n     * @private\n     */_clearCache:function(){this.__lineWidths=[];this.__lineHeights=[];this.__charBounds=[];},/**\n     * @private\n     */_shouldClearDimensionCache:function(){var shouldClear=this._forceClearCache;shouldClear||(shouldClear=this.hasStateChanged('_dimensionAffectingProps'));if(shouldClear){this.dirty=true;this._forceClearCache=false;}return shouldClear;},/**\n     * Measure a single line given its index. Used to calculate the initial\n     * text bounding box. The values are calculated and stored in __lineWidths cache.\n     * @private\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */getLineWidth:function(lineIndex){if(this.__lineWidths[lineIndex]){return this.__lineWidths[lineIndex];}var width,line=this._textLines[lineIndex],lineInfo;if(line===''){width=0;}else{lineInfo=this.measureLine(lineIndex);width=lineInfo.width;}this.__lineWidths[lineIndex]=width;return width;},_getWidthOfCharSpacing:function(){if(this.charSpacing!==0){return this.fontSize*this.charSpacing/1000;}return 0;},/**\n     * Retrieves the value of property at given character position\n     * @param {Number} lineIndex the line number\n     * @param {Number} charIndex the character number\n     * @param {String} property the property name\n     * @returns the value of 'property'\n     */getValueOfPropertyAt:function(lineIndex,charIndex,property){var charStyle=this._getStyleDeclaration(lineIndex,charIndex);if(charStyle&&typeof charStyle[property]!=='undefined'){return charStyle[property];}return this[property];},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_renderTextDecoration:function(ctx,type){if(!this[type]&&!this.styleHas(type)){return;}var heightOfLine,size,_size,lineLeftOffset,dy,_dy,line,lastDecoration,leftOffset=this._getLeftOffset(),topOffset=this._getTopOffset(),top,boxStart,boxWidth,charBox,currentDecoration,maxHeight,currentFill,lastFill,path=this.path,charSpacing=this._getWidthOfCharSpacing(),offsetY=this.offsets[type];for(var i=0,len=this._textLines.length;i<len;i++){heightOfLine=this.getHeightOfLine(i);if(!this[type]&&!this.styleHas(type,i)){topOffset+=heightOfLine;continue;}line=this._textLines[i];maxHeight=heightOfLine/this.lineHeight;lineLeftOffset=this._getLineLeftOffset(i);boxStart=0;boxWidth=0;lastDecoration=this.getValueOfPropertyAt(i,0,type);lastFill=this.getValueOfPropertyAt(i,0,'fill');top=topOffset+maxHeight*(1-this._fontSizeFraction);size=this.getHeightOfChar(i,0);dy=this.getValueOfPropertyAt(i,0,'deltaY');for(var j=0,jlen=line.length;j<jlen;j++){charBox=this.__charBounds[i][j];currentDecoration=this.getValueOfPropertyAt(i,j,type);currentFill=this.getValueOfPropertyAt(i,j,'fill');_size=this.getHeightOfChar(i,j);_dy=this.getValueOfPropertyAt(i,j,'deltaY');if(path&&currentDecoration&&currentFill){ctx.save();ctx.fillStyle=lastFill;ctx.translate(charBox.renderLeft,charBox.renderTop);ctx.rotate(charBox.angle);ctx.fillRect(-charBox.kernedWidth/2,offsetY*_size+_dy,charBox.kernedWidth,this.fontSize/15);ctx.restore();}else if((currentDecoration!==lastDecoration||currentFill!==lastFill||_size!==size||_dy!==dy)&&boxWidth>0){var drawStart=leftOffset+lineLeftOffset+boxStart;if(this.direction==='rtl'){drawStart=this.width-drawStart-boxWidth;}if(lastDecoration&&lastFill){ctx.fillStyle=lastFill;ctx.fillRect(drawStart,top+offsetY*size+dy,boxWidth,this.fontSize/15);}boxStart=charBox.left;boxWidth=charBox.width;lastDecoration=currentDecoration;lastFill=currentFill;size=_size;dy=_dy;}else{boxWidth+=charBox.kernedWidth;}}var drawStart=leftOffset+lineLeftOffset+boxStart;if(this.direction==='rtl'){drawStart=this.width-drawStart-boxWidth;}ctx.fillStyle=currentFill;currentDecoration&&currentFill&&ctx.fillRect(drawStart,top+offsetY*size+dy,boxWidth-charSpacing,this.fontSize/15);topOffset+=heightOfLine;}// if there is text background color no\n// other shadows should be casted\nthis._removeShadow(ctx);},/**\n     * return font declaration string for canvas context\n     * @param {Object} [styleObject] object\n     * @returns {String} font declaration formatted for canvas context.\n     */_getFontDeclaration:function(styleObject,forMeasuring){var style=styleObject||this,family=this.fontFamily,fontIsGeneric=fabric.Text.genericFonts.indexOf(family.toLowerCase())>-1;var fontFamily=family===undefined||family.indexOf('\\'')>-1||family.indexOf(',')>-1||family.indexOf('\"')>-1||fontIsGeneric?style.fontFamily:'\"'+style.fontFamily+'\"';return[// node-canvas needs \"weight style\", while browsers need \"style weight\"\n// verify if this can be fixed in JSDOM\nfabric.isLikelyNode?style.fontWeight:style.fontStyle,fabric.isLikelyNode?style.fontStyle:style.fontWeight,forMeasuring?this.CACHE_FONT_SIZE+'px':style.fontSize+'px',fontFamily].join(' ');},/**\n     * Renders text instance on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */render:function(ctx){// do not render if object is not visible\nif(!this.visible){return;}if(this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()){return;}if(this._shouldClearDimensionCache()){this.initDimensions();}this.callSuper('render',ctx);},/**\n     * Returns the text as an array of lines.\n     * @param {String} text text to split\n     * @returns {Array} Lines in the text\n     */_splitTextIntoLines:function(text){var lines=text.split(this._reNewline),newLines=new Array(lines.length),newLine=['\\n'],newText=[];for(var i=0;i<lines.length;i++){newLines[i]=fabric.util.string.graphemeSplit(lines[i]);newText=newText.concat(newLines[i],newLine);}newText.pop();return{_unwrappedLines:newLines,lines:lines,graphemeText:newText,graphemeLines:newLines};},/**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */toObject:function(propertiesToInclude){var allProperties=additionalProps.concat(propertiesToInclude);var obj=this.callSuper('toObject',allProperties);// styles will be overridden with a properly cloned structure\nobj.styles=clone(this.styles,true);if(obj.path){obj.path=this.path.toObject();}return obj;},/**\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */set:function(key,value){this.callSuper('set',key,value);var needsDims=false;var isAddingPath=false;if(typeof key==='object'){for(var _key in key){if(_key==='path'){this.setPathInfo();}needsDims=needsDims||this._dimensionAffectingProps.indexOf(_key)!==-1;isAddingPath=isAddingPath||_key==='path';}}else{needsDims=this._dimensionAffectingProps.indexOf(key)!==-1;isAddingPath=key==='path';}if(isAddingPath){this.setPathInfo();}if(needsDims){this.initDimensions();this.setCoords();}return this;},/**\n     * Returns complexity of an instance\n     * @return {Number} complexity\n     */complexity:function(){return 1;}});/* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\n   * @static\n   * @memberOf fabric.Text\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\n   */fabric.Text.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat('x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor'.split(' '));/**\n   * Default SVG font size\n   * @static\n   * @memberOf fabric.Text\n   */fabric.Text.DEFAULT_SVG_FONT_SIZE=16;/**\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\n   * @static\n   * @memberOf fabric.Text\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */fabric.Text.fromElement=function(element,callback,options){if(!element){return callback(null);}var parsedAttributes=fabric.parseAttributes(element,fabric.Text.ATTRIBUTE_NAMES),parsedAnchor=parsedAttributes.textAnchor||'left';options=fabric.util.object.extend(options?clone(options):{},parsedAttributes);options.top=options.top||0;options.left=options.left||0;if(parsedAttributes.textDecoration){var textDecoration=parsedAttributes.textDecoration;if(textDecoration.indexOf('underline')!==-1){options.underline=true;}if(textDecoration.indexOf('overline')!==-1){options.overline=true;}if(textDecoration.indexOf('line-through')!==-1){options.linethrough=true;}delete options.textDecoration;}if('dx'in parsedAttributes){options.left+=parsedAttributes.dx;}if('dy'in parsedAttributes){options.top+=parsedAttributes.dy;}if(!('fontSize'in options)){options.fontSize=fabric.Text.DEFAULT_SVG_FONT_SIZE;}var textContent='';// The XML is not properly parsed in IE9 so a workaround to get\n// textContent is through firstChild.data. Another workaround would be\n// to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)\nif(!('textContent'in element)){if('firstChild'in element&&element.firstChild!==null){if('data'in element.firstChild&&element.firstChild.data!==null){textContent=element.firstChild.data;}}}else{textContent=element.textContent;}textContent=textContent.replace(/^\\s+|\\s+$|\\n+/g,'').replace(/\\s+/g,' ');var originalStrokeWidth=options.strokeWidth;options.strokeWidth=0;var text=new fabric.Text(textContent,options),textHeightScaleFactor=text.getScaledHeight()/text.height,lineHeightDiff=(text.height+text.strokeWidth)*text.lineHeight-text.height,scaledDiff=lineHeightDiff*textHeightScaleFactor,textHeight=text.getScaledHeight()+scaledDiff,offX=0;/*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */if(parsedAnchor==='center'){offX=text.getScaledWidth()/2;}if(parsedAnchor==='right'){offX=text.getScaledWidth();}text.set({left:text.left-offX,top:text.top-(textHeight-text.fontSize*(0.07+text._fontSizeFraction))/text.lineHeight,strokeWidth:typeof originalStrokeWidth!=='undefined'?originalStrokeWidth:1});callback(text);};/* _FROM_SVG_END_ */ /**\n   * Returns fabric.Text instance from an object representation\n   * @static\n   * @memberOf fabric.Text\n   * @param {Object} object plain js Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created\n   */fabric.Text.fromObject=function(object,callback){var objectCopy=clone(object),path=object.path;delete objectCopy.path;return fabric.Object._fromObject('Text',objectCopy,function(textInstance){if(path){fabric.Object._fromObject('Path',path,function(pathInstance){textInstance.set('path',pathInstance);callback(textInstance);},'path');}else{callback(textInstance);}},'text');};fabric.Text.genericFonts=['sans-serif','serif','cursive','fantasy','monospace'];fabric.util.createAccessors&&fabric.util.createAccessors(fabric.Text);})( true?exports:0);(function(){fabric.util.object.extend(fabric.Text.prototype,/** @lends fabric.Text.prototype */{/**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */isEmptyStyles:function(lineIndex){if(!this.styles){return true;}if(typeof lineIndex!=='undefined'&&!this.styles[lineIndex]){return true;}var obj=typeof lineIndex==='undefined'?this.styles:{line:this.styles[lineIndex]};for(var p1 in obj){for(var p2 in obj[p1]){// eslint-disable-next-line no-unused-vars\nfor(var p3 in obj[p1][p2]){return false;}}}return true;},/**\n     * Returns true if object has a style property or has it ina specified line\n     * This function is used to detect if a text will use a particular property or not.\n     * @param {String} property to check for\n     * @param {Number} lineIndex to check the style on\n     * @return {Boolean}\n     */styleHas:function(property,lineIndex){if(!this.styles||!property||property===''){return false;}if(typeof lineIndex!=='undefined'&&!this.styles[lineIndex]){return false;}var obj=typeof lineIndex==='undefined'?this.styles:{0:this.styles[lineIndex]};// eslint-disable-next-line\nfor(var p1 in obj){// eslint-disable-next-line\nfor(var p2 in obj[p1]){if(typeof obj[p1][p2][property]!=='undefined'){return true;}}}return false;},/**\n     * Check if characters in a text have a value for a property\n     * whose value matches the textbox's value for that property.  If so,\n     * the character-level property is deleted.  If the character\n     * has no other properties, then it is also deleted.  Finally,\n     * if the line containing that character has no other characters\n     * then it also is deleted.\n     *\n     * @param {string} property The property to compare between characters and text.\n     */cleanStyle:function(property){if(!this.styles||!property||property===''){return false;}var obj=this.styles,stylesCount=0,letterCount,stylePropertyValue,allStyleObjectPropertiesMatch=true,graphemeCount=0,styleObject;// eslint-disable-next-line\nfor(var p1 in obj){letterCount=0;// eslint-disable-next-line\nfor(var p2 in obj[p1]){var styleObject=obj[p1][p2],stylePropertyHasBeenSet=styleObject.hasOwnProperty(property);stylesCount++;if(stylePropertyHasBeenSet){if(!stylePropertyValue){stylePropertyValue=styleObject[property];}else if(styleObject[property]!==stylePropertyValue){allStyleObjectPropertiesMatch=false;}if(styleObject[property]===this[property]){delete styleObject[property];}}else{allStyleObjectPropertiesMatch=false;}if(Object.keys(styleObject).length!==0){letterCount++;}else{delete obj[p1][p2];}}if(letterCount===0){delete obj[p1];}}// if every grapheme has the same style set then\n// delete those styles and set it on the parent\nfor(var i=0;i<this._textLines.length;i++){graphemeCount+=this._textLines[i].length;}if(allStyleObjectPropertiesMatch&&stylesCount===graphemeCount){this[property]=stylePropertyValue;this.removeStyle(property);}},/**\n     * Remove a style property or properties from all individual character styles\n     * in a text object.  Deletes the character style object if it contains no other style\n     * props.  Deletes a line style object if it contains no other character styles.\n     *\n     * @param {String} props The property to remove from character styles.\n     */removeStyle:function(property){if(!this.styles||!property||property===''){return;}var obj=this.styles,line,lineNum,charNum;for(lineNum in obj){line=obj[lineNum];for(charNum in line){delete line[charNum][property];if(Object.keys(line[charNum]).length===0){delete line[charNum];}}if(Object.keys(line).length===0){delete obj[lineNum];}}},/**\n     * @private\n     */_extendStyles:function(index,styles){var loc=this.get2DCursorLocation(index);if(!this._getLineStyle(loc.lineIndex)){this._setLineStyle(loc.lineIndex);}if(!this._getStyleDeclaration(loc.lineIndex,loc.charIndex)){this._setStyleDeclaration(loc.lineIndex,loc.charIndex,{});}fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex,loc.charIndex),styles);},/**\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\n     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.\n     */get2DCursorLocation:function(selectionStart,skipWrapping){if(typeof selectionStart==='undefined'){selectionStart=this.selectionStart;}var lines=skipWrapping?this._unwrappedTextLines:this._textLines,len=lines.length;for(var i=0;i<len;i++){if(selectionStart<=lines[i].length){return{lineIndex:i,charIndex:selectionStart};}selectionStart-=lines[i].length+this.missingNewlineOffset(i);}return{lineIndex:i-1,charIndex:lines[i-1].length<selectionStart?lines[i-1].length:selectionStart};},/**\n     * Gets style of a current selection/cursor (at the start position)\n     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @param {Boolean} [complete] get full style or not\n     * @return {Array} styles an array with one, zero or more Style objects\n     */getSelectionStyles:function(startIndex,endIndex,complete){if(typeof startIndex==='undefined'){startIndex=this.selectionStart||0;}if(typeof endIndex==='undefined'){endIndex=this.selectionEnd||startIndex;}var styles=[];for(var i=startIndex;i<endIndex;i++){styles.push(this.getStyleAtPosition(i,complete));}return styles;},/**\n     * Gets style of a current selection/cursor position\n     * @param {Number} position  to get styles at\n     * @param {Boolean} [complete] full style if true\n     * @return {Object} style Style object at a specified index\n     * @private\n     */getStyleAtPosition:function(position,complete){var loc=this.get2DCursorLocation(position),style=complete?this.getCompleteStyleDeclaration(loc.lineIndex,loc.charIndex):this._getStyleDeclaration(loc.lineIndex,loc.charIndex);return style||{};},/**\n     * Sets style of a current selection, if no selection exist, do not set anything.\n     * @param {Object} [styles] Styles object\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */setSelectionStyles:function(styles,startIndex,endIndex){if(typeof startIndex==='undefined'){startIndex=this.selectionStart||0;}if(typeof endIndex==='undefined'){endIndex=this.selectionEnd||startIndex;}for(var i=startIndex;i<endIndex;i++){this._extendStyles(i,styles);}/* not included in _extendStyles to avoid clearing cache more than once */this._forceClearCache=true;return this;},/**\n     * get the reference, not a clone, of the style object for a given character\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @return {Object} style object\n     */_getStyleDeclaration:function(lineIndex,charIndex){var lineStyle=this.styles&&this.styles[lineIndex];if(!lineStyle){return null;}return lineStyle[charIndex];},/**\n     * return a new object that contains all the style property for a character\n     * the object returned is newly created\n     * @param {Number} lineIndex of the line where the character is\n     * @param {Number} charIndex position of the character on the line\n     * @return {Object} style object\n     */getCompleteStyleDeclaration:function(lineIndex,charIndex){var style=this._getStyleDeclaration(lineIndex,charIndex)||{},styleObject={},prop;for(var i=0;i<this._styleProperties.length;i++){prop=this._styleProperties[i];styleObject[prop]=typeof style[prop]==='undefined'?this[prop]:style[prop];}return styleObject;},/**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */_setStyleDeclaration:function(lineIndex,charIndex,style){this.styles[lineIndex][charIndex]=style;},/**\n     *\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */_deleteStyleDeclaration:function(lineIndex,charIndex){delete this.styles[lineIndex][charIndex];},/**\n     * @param {Number} lineIndex\n     * @return {Boolean} if the line exists or not\n     * @private\n     */_getLineStyle:function(lineIndex){return!!this.styles[lineIndex];},/**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @private\n     */_setLineStyle:function(lineIndex){this.styles[lineIndex]={};},/**\n     * @param {Number} lineIndex\n     * @private\n     */_deleteLineStyle:function(lineIndex){delete this.styles[lineIndex];}});})();(function(){function parseDecoration(object){if(object.textDecoration){object.textDecoration.indexOf('underline')>-1&&(object.underline=true);object.textDecoration.indexOf('line-through')>-1&&(object.linethrough=true);object.textDecoration.indexOf('overline')>-1&&(object.overline=true);delete object.textDecoration;}}/**\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \"text:\"\n   * prefix when observing canvas.\n   * @class fabric.IText\n   * @extends fabric.Text\n   * @mixes fabric.Observable\n   *\n   * @fires changed\n   * @fires selection:changed\n   * @fires editing:entered\n   * @fires editing:exited\n   *\n   * @return {fabric.IText} thisArg\n   * @see {@link fabric.IText#initialize} for constructor definition\n   *\n   * <p>Supported key combinations:</p>\n   * <pre>\n   *   Move cursor:                    left, right, up, down\n   *   Select character:               shift + left, shift + right\n   *   Select text vertically:         shift + up, shift + down\n   *   Move cursor by word:            alt + left, alt + right\n   *   Select words:                   shift + alt + left, shift + alt + right\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\n   *   Jump to start/end of text:      cmd + up, cmd + down\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\n   *   Delete character:               backspace\n   *   Delete word:                    alt + backspace\n   *   Delete line:                    cmd + backspace\n   *   Forward delete:                 delete\n   *   Copy text:                      ctrl/cmd + c\n   *   Paste text:                     ctrl/cmd + v\n   *   Cut text:                       ctrl/cmd + x\n   *   Select entire text:             ctrl/cmd + a\n   *   Quit editing                    tab or esc\n   * </pre>\n   *\n   * <p>Supported mouse/touch combination</p>\n   * <pre>\n   *   Position cursor:                click/touch\n   *   Create selection:               click/touch & drag\n   *   Create selection:               click & shift + click\n   *   Select word:                    double click\n   *   Select line:                    triple click\n   * </pre>\n   */fabric.IText=fabric.util.createClass(fabric.Text,fabric.Observable,/** @lends fabric.IText.prototype */{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'i-text',/**\n     * Index where text selection starts (or where cursor is when there is no selection)\n     * @type Number\n     * @default\n     */selectionStart:0,/**\n     * Index where text selection ends\n     * @type Number\n     * @default\n     */selectionEnd:0,/**\n     * Color of text selection\n     * @type String\n     * @default\n     */selectionColor:'rgba(17,119,255,0.3)',/**\n     * Indicates whether text is in editing mode\n     * @type Boolean\n     * @default\n     */isEditing:false,/**\n     * Indicates whether a text can be edited\n     * @type Boolean\n     * @default\n     */editable:true,/**\n     * Border color of text object while it's in editing mode\n     * @type String\n     * @default\n     */editingBorderColor:'rgba(102,153,255,0.25)',/**\n     * Width of cursor (in px)\n     * @type Number\n     * @default\n     */cursorWidth:2,/**\n     * Color of text cursor color in editing mode.\n     * if not set (default) will take color from the text.\n     * if set to a color value that fabric can understand, it will\n     * be used instead of the color of the text at the current position.\n     * @type String\n     * @default\n     */cursorColor:'',/**\n     * Delay between cursor blink (in ms)\n     * @type Number\n     * @default\n     */cursorDelay:1000,/**\n     * Duration of cursor fadein (in ms)\n     * @type Number\n     * @default\n     */cursorDuration:600,/**\n     * Indicates whether internal text char widths can be cached\n     * @type Boolean\n     * @default\n     */caching:true,/**\n     * DOM container to append the hiddenTextarea.\n     * An alternative to attaching to the document.body.\n     * Useful to reduce laggish redraw of the full document.body tree and\n     * also with modals event capturing that won't let the textarea take focus.\n     * @type HTMLElement\n     * @default\n     */hiddenTextareaContainer:null,/**\n     * @private\n     */_reSpace:/\\s|\\n/,/**\n     * @private\n     */_currentCursorOpacity:0,/**\n     * @private\n     */_selectionDirection:null,/**\n     * @private\n     */_abortCursorAnimation:false,/**\n     * @private\n     */__widthOfSpace:[],/**\n     * Helps determining when the text is in composition, so that the cursor\n     * rendering is altered.\n     */inCompositionMode:false,/**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.IText} thisArg\n     */initialize:function(text,options){this.callSuper('initialize',text,options);this.initBehavior();},/**\n     * Sets selection start (left boundary of a selection)\n     * @param {Number} index Index to set selection start to\n     */setSelectionStart:function(index){index=Math.max(index,0);this._updateAndFire('selectionStart',index);},/**\n     * Sets selection end (right boundary of a selection)\n     * @param {Number} index Index to set selection end to\n     */setSelectionEnd:function(index){index=Math.min(index,this.text.length);this._updateAndFire('selectionEnd',index);},/**\n     * @private\n     * @param {String} property 'selectionStart' or 'selectionEnd'\n     * @param {Number} index new position of property\n     */_updateAndFire:function(property,index){if(this[property]!==index){this._fireSelectionChanged();this[property]=index;}this._updateTextarea();},/**\n     * Fires the even of selection changed\n     * @private\n     */_fireSelectionChanged:function(){this.fire('selection:changed');this.canvas&&this.canvas.fire('text:selection:changed',{target:this});},/**\n     * Initialize text dimensions. Render all text on given context\n     * or on a offscreen canvas to get the text width with measureText.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     * @private\n     */initDimensions:function(){this.isEditing&&this.initDelayedCursor();this.clearContextTop();this.callSuper('initDimensions');},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */render:function(ctx){this.clearContextTop();this.callSuper('render',ctx);// clear the cursorOffsetCache, so we ensure to calculate once per renderCursor\n// the correct position but not at every cursor animation.\nthis.cursorOffsetCache={};this.renderCursorOrSelection();},/**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */_render:function(ctx){this.callSuper('_render',ctx);},/**\n     * Prepare and clean the contextTop\n     */clearContextTop:function(skipRestore){if(!this.isEditing||!this.canvas||!this.canvas.contextTop){return;}var ctx=this.canvas.contextTop,v=this.canvas.viewportTransform;ctx.save();ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]);this.transform(ctx);this._clearTextArea(ctx);skipRestore||ctx.restore();},/**\n     * Renders cursor or selection (depending on what exists)\n     * it does on the contextTop. If contextTop is not available, do nothing.\n     */renderCursorOrSelection:function(){if(!this.isEditing||!this.canvas||!this.canvas.contextTop){return;}var boundaries=this._getCursorBoundaries(),ctx=this.canvas.contextTop;this.clearContextTop(true);if(this.selectionStart===this.selectionEnd){this.renderCursor(boundaries,ctx);}else{this.renderSelection(boundaries,ctx);}ctx.restore();},_clearTextArea:function(ctx){// we add 4 pixel, to be sure to do not leave any pixel out\nvar width=this.width+4,height=this.height+4;ctx.clearRect(-width/2,-height/2,width,height);},/**\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\n     * @private\n     * @param {Array} chars Array of characters\n     * @param {String} typeOfBoundaries\n     */_getCursorBoundaries:function(position){// left/top are left/top of entire text box\n// leftOffset/topOffset are offset from that left/top point of a text box\nif(typeof position==='undefined'){position=this.selectionStart;}var left=this._getLeftOffset(),top=this._getTopOffset(),offsets=this._getCursorBoundariesOffsets(position);return{left:left,top:top,leftOffset:offsets.left,topOffset:offsets.top};},/**\n     * @private\n     */_getCursorBoundariesOffsets:function(position){if(this.cursorOffsetCache&&'top'in this.cursorOffsetCache){return this.cursorOffsetCache;}var lineLeftOffset,lineIndex,charIndex,topOffset=0,leftOffset=0,boundaries,cursorPosition=this.get2DCursorLocation(position);charIndex=cursorPosition.charIndex;lineIndex=cursorPosition.lineIndex;for(var i=0;i<lineIndex;i++){topOffset+=this.getHeightOfLine(i);}lineLeftOffset=this._getLineLeftOffset(lineIndex);var bound=this.__charBounds[lineIndex][charIndex];bound&&(leftOffset=bound.left);if(this.charSpacing!==0&&charIndex===this._textLines[lineIndex].length){leftOffset-=this._getWidthOfCharSpacing();}boundaries={top:topOffset,left:lineLeftOffset+(leftOffset>0?leftOffset:0)};if(this.direction==='rtl'){boundaries.left*=-1;}this.cursorOffsetCache=boundaries;return this.cursorOffsetCache;},/**\n     * Renders cursor\n     * @param {Object} boundaries\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */renderCursor:function(boundaries,ctx){var cursorLocation=this.get2DCursorLocation(),lineIndex=cursorLocation.lineIndex,charIndex=cursorLocation.charIndex>0?cursorLocation.charIndex-1:0,charHeight=this.getValueOfPropertyAt(lineIndex,charIndex,'fontSize'),multiplier=this.scaleX*this.canvas.getZoom(),cursorWidth=this.cursorWidth/multiplier,topOffset=boundaries.topOffset,dy=this.getValueOfPropertyAt(lineIndex,charIndex,'deltaY');topOffset+=(1-this._fontSizeFraction)*this.getHeightOfLine(lineIndex)/this.lineHeight-charHeight*(1-this._fontSizeFraction);if(this.inCompositionMode){this.renderSelection(boundaries,ctx);}ctx.fillStyle=this.cursorColor||this.getValueOfPropertyAt(lineIndex,charIndex,'fill');ctx.globalAlpha=this.__isMousedown?1:this._currentCursorOpacity;ctx.fillRect(boundaries.left+boundaries.leftOffset-cursorWidth/2,topOffset+boundaries.top+dy,cursorWidth,charHeight);},/**\n     * Renders text selection\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */renderSelection:function(boundaries,ctx){var selectionStart=this.inCompositionMode?this.hiddenTextarea.selectionStart:this.selectionStart,selectionEnd=this.inCompositionMode?this.hiddenTextarea.selectionEnd:this.selectionEnd,isJustify=this.textAlign.indexOf('justify')!==-1,start=this.get2DCursorLocation(selectionStart),end=this.get2DCursorLocation(selectionEnd),startLine=start.lineIndex,endLine=end.lineIndex,startChar=start.charIndex<0?0:start.charIndex,endChar=end.charIndex<0?0:end.charIndex;for(var i=startLine;i<=endLine;i++){var lineOffset=this._getLineLeftOffset(i)||0,lineHeight=this.getHeightOfLine(i),realLineHeight=0,boxStart=0,boxEnd=0;if(i===startLine){boxStart=this.__charBounds[startLine][startChar].left;}if(i>=startLine&&i<endLine){boxEnd=isJustify&&!this.isEndOfWrapping(i)?this.width:this.getLineWidth(i)||5;// WTF is this 5?\n}else if(i===endLine){if(endChar===0){boxEnd=this.__charBounds[endLine][endChar].left;}else{var charSpacing=this._getWidthOfCharSpacing();boxEnd=this.__charBounds[endLine][endChar-1].left+this.__charBounds[endLine][endChar-1].width-charSpacing;}}realLineHeight=lineHeight;if(this.lineHeight<1||i===endLine&&this.lineHeight>1){lineHeight/=this.lineHeight;}var drawStart=boundaries.left+lineOffset+boxStart,drawWidth=boxEnd-boxStart,drawHeight=lineHeight,extraTop=0;if(this.inCompositionMode){ctx.fillStyle=this.compositionColor||'black';drawHeight=1;extraTop=lineHeight;}else{ctx.fillStyle=this.selectionColor;}if(this.direction==='rtl'){drawStart=this.width-drawStart-drawWidth;}ctx.fillRect(drawStart,boundaries.top+boundaries.topOffset+extraTop,drawWidth,drawHeight);boundaries.topOffset+=realLineHeight;}},/**\n     * High level function to know the height of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns fontSize of char at the current cursor\n     * Unused from the library, is for the end user\n     * @return {Number} Character font size\n     */getCurrentCharFontSize:function(){var cp=this._getCurrentCharIndex();return this.getValueOfPropertyAt(cp.l,cp.c,'fontSize');},/**\n     * High level function to know the color of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns color (fill) of char at the current cursor\n     * if the text object has a pattern or gradient for filler, it will return that.\n     * Unused by the library, is for the end user\n     * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)\n     */getCurrentCharColor:function(){var cp=this._getCurrentCharIndex();return this.getValueOfPropertyAt(cp.l,cp.c,'fill');},/**\n     * Returns the cursor position for the getCurrent.. functions\n     * @private\n     */_getCurrentCharIndex:function(){var cursorPosition=this.get2DCursorLocation(this.selectionStart,true),charIndex=cursorPosition.charIndex>0?cursorPosition.charIndex-1:0;return{l:cursorPosition.lineIndex,c:charIndex};}});/**\n   * Returns fabric.IText instance from an object representation\n   * @static\n   * @memberOf fabric.IText\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as argument\n   */fabric.IText.fromObject=function(object,callback){parseDecoration(object);if(object.styles){for(var i in object.styles){for(var j in object.styles[i]){parseDecoration(object.styles[i][j]);}}}fabric.Object._fromObject('IText',object,callback,'text');};})();(function(){var clone=fabric.util.object.clone;fabric.util.object.extend(fabric.IText.prototype,/** @lends fabric.IText.prototype */{/**\n     * Initializes all the interactive behavior of IText\n     */initBehavior:function(){this.initAddedHandler();this.initRemovedHandler();this.initCursorSelectionHandlers();this.initDoubleClickSimulation();this.mouseMoveHandler=this.mouseMoveHandler.bind(this);},onDeselect:function(){this.isEditing&&this.exitEditing();this.selected=false;},/**\n     * Initializes \"added\" event handler\n     */initAddedHandler:function(){var _this=this;this.on('added',function(){var canvas=_this.canvas;if(canvas){if(!canvas._hasITextHandlers){canvas._hasITextHandlers=true;_this._initCanvasHandlers(canvas);}canvas._iTextInstances=canvas._iTextInstances||[];canvas._iTextInstances.push(_this);}});},initRemovedHandler:function(){var _this=this;this.on('removed',function(){var canvas=_this.canvas;if(canvas){canvas._iTextInstances=canvas._iTextInstances||[];fabric.util.removeFromArray(canvas._iTextInstances,_this);if(canvas._iTextInstances.length===0){canvas._hasITextHandlers=false;_this._removeCanvasHandlers(canvas);}}});},/**\n     * register canvas event to manage exiting on other instances\n     * @private\n     */_initCanvasHandlers:function(canvas){canvas._mouseUpITextHandler=function(){if(canvas._iTextInstances){canvas._iTextInstances.forEach(function(obj){obj.__isMousedown=false;});}};canvas.on('mouse:up',canvas._mouseUpITextHandler);},/**\n     * remove canvas event to manage exiting on other instances\n     * @private\n     */_removeCanvasHandlers:function(canvas){canvas.off('mouse:up',canvas._mouseUpITextHandler);},/**\n     * @private\n     */_tick:function(){this._currentTickState=this._animateCursor(this,1,this.cursorDuration,'_onTickComplete');},/**\n     * @private\n     */_animateCursor:function(obj,targetOpacity,duration,completeMethod){var tickState;tickState={isAborted:false,abort:function(){this.isAborted=true;}};obj.animate('_currentCursorOpacity',targetOpacity,{duration:duration,onComplete:function(){if(!tickState.isAborted){obj[completeMethod]();}},onChange:function(){// we do not want to animate a selection, only cursor\nif(obj.canvas&&obj.selectionStart===obj.selectionEnd){obj.renderCursorOrSelection();}},abort:function(){return tickState.isAborted;}});return tickState;},/**\n     * @private\n     */_onTickComplete:function(){var _this=this;if(this._cursorTimeout1){clearTimeout(this._cursorTimeout1);}this._cursorTimeout1=setTimeout(function(){_this._currentTickCompleteState=_this._animateCursor(_this,0,this.cursorDuration/2,'_tick');},100);},/**\n     * Initializes delayed cursor\n     */initDelayedCursor:function(restart){var _this=this,delay=restart?0:this.cursorDelay;this.abortCursorAnimation();this._currentCursorOpacity=1;this._cursorTimeout2=setTimeout(function(){_this._tick();},delay);},/**\n     * Aborts cursor animation and clears all timeouts\n     */abortCursorAnimation:function(){var shouldClear=this._currentTickState||this._currentTickCompleteState,canvas=this.canvas;this._currentTickState&&this._currentTickState.abort();this._currentTickCompleteState&&this._currentTickCompleteState.abort();clearTimeout(this._cursorTimeout1);clearTimeout(this._cursorTimeout2);this._currentCursorOpacity=0;// to clear just itext area we need to transform the context\n// it may not be worth it\nif(shouldClear&&canvas){canvas.clearContext(canvas.contextTop||canvas.contextContainer);}},/**\n     * Selects entire text\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */selectAll:function(){this.selectionStart=0;this.selectionEnd=this._text.length;this._fireSelectionChanged();this._updateTextarea();return this;},/**\n     * Returns selected text\n     * @return {String}\n     */getSelectedText:function(){return this._text.slice(this.selectionStart,this.selectionEnd).join('');},/**\n     * Find new selection index representing start of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */findWordBoundaryLeft:function(startFrom){var offset=0,index=startFrom-1;// remove space before cursor first\nif(this._reSpace.test(this._text[index])){while(this._reSpace.test(this._text[index])){offset++;index--;}}while(/\\S/.test(this._text[index])&&index>-1){offset++;index--;}return startFrom-offset;},/**\n     * Find new selection index representing end of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */findWordBoundaryRight:function(startFrom){var offset=0,index=startFrom;// remove space after cursor first\nif(this._reSpace.test(this._text[index])){while(this._reSpace.test(this._text[index])){offset++;index++;}}while(/\\S/.test(this._text[index])&&index<this._text.length){offset++;index++;}return startFrom+offset;},/**\n     * Find new selection index representing start of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */findLineBoundaryLeft:function(startFrom){var offset=0,index=startFrom-1;while(!/\\n/.test(this._text[index])&&index>-1){offset++;index--;}return startFrom-offset;},/**\n     * Find new selection index representing end of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */findLineBoundaryRight:function(startFrom){var offset=0,index=startFrom;while(!/\\n/.test(this._text[index])&&index<this._text.length){offset++;index++;}return startFrom+offset;},/**\n     * Finds index corresponding to beginning or end of a word\n     * @param {Number} selectionStart Index of a character\n     * @param {Number} direction 1 or -1\n     * @return {Number} Index of the beginning or end of a word\n     */searchWordBoundary:function(selectionStart,direction){var text=this._text,index=this._reSpace.test(text[selectionStart])?selectionStart-1:selectionStart,_char=text[index],// wrong\nreNonWord=fabric.reNonWord;while(!reNonWord.test(_char)&&index>0&&index<text.length){index+=direction;_char=text[index];}if(reNonWord.test(_char)){index+=direction===1?0:1;}return index;},/**\n     * Selects a word based on the index\n     * @param {Number} selectionStart Index of a character\n     */selectWord:function(selectionStart){selectionStart=selectionStart||this.selectionStart;var newSelectionStart=this.searchWordBoundary(selectionStart,-1),/* search backwards */newSelectionEnd=this.searchWordBoundary(selectionStart,1);/* search forward */this.selectionStart=newSelectionStart;this.selectionEnd=newSelectionEnd;this._fireSelectionChanged();this._updateTextarea();this.renderCursorOrSelection();},/**\n     * Selects a line based on the index\n     * @param {Number} selectionStart Index of a character\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */selectLine:function(selectionStart){selectionStart=selectionStart||this.selectionStart;var newSelectionStart=this.findLineBoundaryLeft(selectionStart),newSelectionEnd=this.findLineBoundaryRight(selectionStart);this.selectionStart=newSelectionStart;this.selectionEnd=newSelectionEnd;this._fireSelectionChanged();this._updateTextarea();return this;},/**\n     * Enters editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */enterEditing:function(e){if(this.isEditing||!this.editable){return;}if(this.canvas){this.canvas.calcOffset();this.exitEditingOnOthers(this.canvas);}this.isEditing=true;this.initHiddenTextarea(e);this.hiddenTextarea.focus();this.hiddenTextarea.value=this.text;this._updateTextarea();this._saveEditingProps();this._setEditingProps();this._textBeforeEdit=this.text;this._tick();this.fire('editing:entered');this._fireSelectionChanged();if(!this.canvas){return this;}this.canvas.fire('text:editing:entered',{target:this});this.initMouseMoveHandler();this.canvas.requestRenderAll();return this;},exitEditingOnOthers:function(canvas){if(canvas._iTextInstances){canvas._iTextInstances.forEach(function(obj){obj.selected=false;if(obj.isEditing){obj.exitEditing();}});}},/**\n     * Initializes \"mousemove\" event handler\n     */initMouseMoveHandler:function(){this.canvas.on('mouse:move',this.mouseMoveHandler);},/**\n     * @private\n     */mouseMoveHandler:function(options){if(!this.__isMousedown||!this.isEditing){return;}var newSelectionStart=this.getSelectionStartFromPointer(options.e),currentStart=this.selectionStart,currentEnd=this.selectionEnd;if((newSelectionStart!==this.__selectionStartOnMouseDown||currentStart===currentEnd)&&(currentStart===newSelectionStart||currentEnd===newSelectionStart)){return;}if(newSelectionStart>this.__selectionStartOnMouseDown){this.selectionStart=this.__selectionStartOnMouseDown;this.selectionEnd=newSelectionStart;}else{this.selectionStart=newSelectionStart;this.selectionEnd=this.__selectionStartOnMouseDown;}if(this.selectionStart!==currentStart||this.selectionEnd!==currentEnd){this.restartCursorIfNeeded();this._fireSelectionChanged();this._updateTextarea();this.renderCursorOrSelection();}},/**\n     * @private\n     */_setEditingProps:function(){this.hoverCursor='text';if(this.canvas){this.canvas.defaultCursor=this.canvas.moveCursor='text';}this.borderColor=this.editingBorderColor;this.hasControls=this.selectable=false;this.lockMovementX=this.lockMovementY=true;},/**\n     * convert from textarea to grapheme indexes\n     */fromStringToGraphemeSelection:function(start,end,text){var smallerTextStart=text.slice(0,start),graphemeStart=fabric.util.string.graphemeSplit(smallerTextStart).length;if(start===end){return{selectionStart:graphemeStart,selectionEnd:graphemeStart};}var smallerTextEnd=text.slice(start,end),graphemeEnd=fabric.util.string.graphemeSplit(smallerTextEnd).length;return{selectionStart:graphemeStart,selectionEnd:graphemeStart+graphemeEnd};},/**\n     * convert from fabric to textarea values\n     */fromGraphemeToStringSelection:function(start,end,_text){var smallerTextStart=_text.slice(0,start),graphemeStart=smallerTextStart.join('').length;if(start===end){return{selectionStart:graphemeStart,selectionEnd:graphemeStart};}var smallerTextEnd=_text.slice(start,end),graphemeEnd=smallerTextEnd.join('').length;return{selectionStart:graphemeStart,selectionEnd:graphemeStart+graphemeEnd};},/**\n     * @private\n     */_updateTextarea:function(){this.cursorOffsetCache={};if(!this.hiddenTextarea){return;}if(!this.inCompositionMode){var newSelection=this.fromGraphemeToStringSelection(this.selectionStart,this.selectionEnd,this._text);this.hiddenTextarea.selectionStart=newSelection.selectionStart;this.hiddenTextarea.selectionEnd=newSelection.selectionEnd;}this.updateTextareaPosition();},/**\n     * @private\n     */updateFromTextArea:function(){if(!this.hiddenTextarea){return;}this.cursorOffsetCache={};this.text=this.hiddenTextarea.value;if(this._shouldClearDimensionCache()){this.initDimensions();this.setCoords();}var newSelection=this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart,this.hiddenTextarea.selectionEnd,this.hiddenTextarea.value);this.selectionEnd=this.selectionStart=newSelection.selectionEnd;if(!this.inCompositionMode){this.selectionStart=newSelection.selectionStart;}this.updateTextareaPosition();},/**\n     * @private\n     */updateTextareaPosition:function(){if(this.selectionStart===this.selectionEnd){var style=this._calcTextareaPosition();this.hiddenTextarea.style.left=style.left;this.hiddenTextarea.style.top=style.top;}},/**\n     * @private\n     * @return {Object} style contains style for hiddenTextarea\n     */_calcTextareaPosition:function(){if(!this.canvas){return{x:1,y:1};}var desiredPosition=this.inCompositionMode?this.compositionStart:this.selectionStart,boundaries=this._getCursorBoundaries(desiredPosition),cursorLocation=this.get2DCursorLocation(desiredPosition),lineIndex=cursorLocation.lineIndex,charIndex=cursorLocation.charIndex,charHeight=this.getValueOfPropertyAt(lineIndex,charIndex,'fontSize')*this.lineHeight,leftOffset=boundaries.leftOffset,m=this.calcTransformMatrix(),p={x:boundaries.left+leftOffset,y:boundaries.top+boundaries.topOffset+charHeight},retinaScaling=this.canvas.getRetinaScaling(),upperCanvas=this.canvas.upperCanvasEl,upperCanvasWidth=upperCanvas.width/retinaScaling,upperCanvasHeight=upperCanvas.height/retinaScaling,maxWidth=upperCanvasWidth-charHeight,maxHeight=upperCanvasHeight-charHeight,scaleX=upperCanvas.clientWidth/upperCanvasWidth,scaleY=upperCanvas.clientHeight/upperCanvasHeight;p=fabric.util.transformPoint(p,m);p=fabric.util.transformPoint(p,this.canvas.viewportTransform);p.x*=scaleX;p.y*=scaleY;if(p.x<0){p.x=0;}if(p.x>maxWidth){p.x=maxWidth;}if(p.y<0){p.y=0;}if(p.y>maxHeight){p.y=maxHeight;}// add canvas offset on document\np.x+=this.canvas._offset.left;p.y+=this.canvas._offset.top;return{left:p.x+'px',top:p.y+'px',fontSize:charHeight+'px',charHeight:charHeight};},/**\n     * @private\n     */_saveEditingProps:function(){this._savedProps={hasControls:this.hasControls,borderColor:this.borderColor,lockMovementX:this.lockMovementX,lockMovementY:this.lockMovementY,hoverCursor:this.hoverCursor,selectable:this.selectable,defaultCursor:this.canvas&&this.canvas.defaultCursor,moveCursor:this.canvas&&this.canvas.moveCursor};},/**\n     * @private\n     */_restoreEditingProps:function(){if(!this._savedProps){return;}this.hoverCursor=this._savedProps.hoverCursor;this.hasControls=this._savedProps.hasControls;this.borderColor=this._savedProps.borderColor;this.selectable=this._savedProps.selectable;this.lockMovementX=this._savedProps.lockMovementX;this.lockMovementY=this._savedProps.lockMovementY;if(this.canvas){this.canvas.defaultCursor=this._savedProps.defaultCursor;this.canvas.moveCursor=this._savedProps.moveCursor;}},/**\n     * Exits from editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */exitEditing:function(){var isTextChanged=this._textBeforeEdit!==this.text;var hiddenTextarea=this.hiddenTextarea;this.selected=false;this.isEditing=false;this.selectionEnd=this.selectionStart;if(hiddenTextarea){hiddenTextarea.blur&&hiddenTextarea.blur();hiddenTextarea.parentNode&&hiddenTextarea.parentNode.removeChild(hiddenTextarea);}this.hiddenTextarea=null;this.abortCursorAnimation();this._restoreEditingProps();this._currentCursorOpacity=0;if(this._shouldClearDimensionCache()){this.initDimensions();this.setCoords();}this.fire('editing:exited');isTextChanged&&this.fire('modified');if(this.canvas){this.canvas.off('mouse:move',this.mouseMoveHandler);this.canvas.fire('text:editing:exited',{target:this});isTextChanged&&this.canvas.fire('object:modified',{target:this});}return this;},/**\n     * @private\n     */_removeExtraneousStyles:function(){for(var prop in this.styles){if(!this._textLines[prop]){delete this.styles[prop];}}},/**\n     * remove and reflow a style block from start to end.\n     * @param {Number} start linear start position for removal (included in removal)\n     * @param {Number} end linear end position for removal ( excluded from removal )\n     */removeStyleFromTo:function(start,end){var cursorStart=this.get2DCursorLocation(start,true),cursorEnd=this.get2DCursorLocation(end,true),lineStart=cursorStart.lineIndex,charStart=cursorStart.charIndex,lineEnd=cursorEnd.lineIndex,charEnd=cursorEnd.charIndex,i,styleObj;if(lineStart!==lineEnd){// step1 remove the trailing of lineStart\nif(this.styles[lineStart]){for(i=charStart;i<this._unwrappedTextLines[lineStart].length;i++){delete this.styles[lineStart][i];}}// step2 move the trailing of lineEnd to lineStart if needed\nif(this.styles[lineEnd]){for(i=charEnd;i<this._unwrappedTextLines[lineEnd].length;i++){styleObj=this.styles[lineEnd][i];if(styleObj){this.styles[lineStart]||(this.styles[lineStart]={});this.styles[lineStart][charStart+i-charEnd]=styleObj;}}}// step3 detects lines will be completely removed.\nfor(i=lineStart+1;i<=lineEnd;i++){delete this.styles[i];}// step4 shift remaining lines.\nthis.shiftLineStyles(lineEnd,lineStart-lineEnd);}else{// remove and shift left on the same line\nif(this.styles[lineStart]){styleObj=this.styles[lineStart];var diff=charEnd-charStart,numericChar,_char;for(i=charStart;i<charEnd;i++){delete styleObj[i];}for(_char in this.styles[lineStart]){numericChar=parseInt(_char,10);if(numericChar>=charEnd){styleObj[numericChar-diff]=styleObj[_char];delete styleObj[_char];}}}}},/**\n     * Shifts line styles up or down\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} offset Can any number?\n     */shiftLineStyles:function(lineIndex,offset){// shift all line styles by offset upward or downward\n// do not clone deep. we need new array, not new style objects\nvar clonedStyles=clone(this.styles);for(var line in this.styles){var numericLine=parseInt(line,10);if(numericLine>lineIndex){this.styles[numericLine+offset]=clonedStyles[numericLine];if(!clonedStyles[numericLine-offset]){delete this.styles[numericLine];}}}},restartCursorIfNeeded:function(){if(!this._currentTickState||this._currentTickState.isAborted||!this._currentTickCompleteState||this._currentTickCompleteState.isAborted){this.initDelayedCursor();}},/**\n     * Handle insertion of more consecutive style lines for when one or more\n     * newlines gets added to the text. Since current style needs to be shifted\n     * first we shift the current style of the number lines needed, then we add\n     * new lines from the last to the first.\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} qty number of lines to add\n     * @param {Array} copiedStyle Array of objects styles\n     */insertNewlineStyleObject:function(lineIndex,charIndex,qty,copiedStyle){var currentCharStyle,newLineStyles={},somethingAdded=false,isEndOfLine=this._unwrappedTextLines[lineIndex].length===charIndex;qty||(qty=1);this.shiftLineStyles(lineIndex,qty);if(this.styles[lineIndex]){currentCharStyle=this.styles[lineIndex][charIndex===0?charIndex:charIndex-1];}// we clone styles of all chars\n// after cursor onto the current line\nfor(var index in this.styles[lineIndex]){var numIndex=parseInt(index,10);if(numIndex>=charIndex){somethingAdded=true;newLineStyles[numIndex-charIndex]=this.styles[lineIndex][index];// remove lines from the previous line since they're on a new line now\nif(!(isEndOfLine&&charIndex===0)){delete this.styles[lineIndex][index];}}}var styleCarriedOver=false;if(somethingAdded&&!isEndOfLine){// if is end of line, the extra style we copied\n// is probably not something we want\nthis.styles[lineIndex+qty]=newLineStyles;styleCarriedOver=true;}if(styleCarriedOver){// skip the last line of since we already prepared it.\nqty--;}// for the all the lines or all the other lines\n// we clone current char style onto the next (otherwise empty) line\nwhile(qty>0){if(copiedStyle&&copiedStyle[qty-1]){this.styles[lineIndex+qty]={0:clone(copiedStyle[qty-1])};}else if(currentCharStyle){this.styles[lineIndex+qty]={0:clone(currentCharStyle)};}else{delete this.styles[lineIndex+qty];}qty--;}this._forceClearCache=true;},/**\n     * Inserts style object for a given line/char index\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} quantity number Style object to insert, if given\n     * @param {Array} copiedStyle array of style objects\n     */insertCharStyleObject:function(lineIndex,charIndex,quantity,copiedStyle){if(!this.styles){this.styles={};}var currentLineStyles=this.styles[lineIndex],currentLineStylesCloned=currentLineStyles?clone(currentLineStyles):{};quantity||(quantity=1);// shift all char styles by quantity forward\n// 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\nfor(var index in currentLineStylesCloned){var numericIndex=parseInt(index,10);if(numericIndex>=charIndex){currentLineStyles[numericIndex+quantity]=currentLineStylesCloned[numericIndex];// only delete the style if there was nothing moved there\nif(!currentLineStylesCloned[numericIndex-quantity]){delete currentLineStyles[numericIndex];}}}this._forceClearCache=true;if(copiedStyle){while(quantity--){if(!Object.keys(copiedStyle[quantity]).length){continue;}if(!this.styles[lineIndex]){this.styles[lineIndex]={};}this.styles[lineIndex][charIndex+quantity]=clone(copiedStyle[quantity]);}return;}if(!currentLineStyles){return;}var newStyle=currentLineStyles[charIndex?charIndex-1:1];while(newStyle&&quantity--){this.styles[lineIndex][charIndex+quantity]=clone(newStyle);}},/**\n     * Inserts style object(s)\n     * @param {Array} insertedText Characters at the location where style is inserted\n     * @param {Number} start cursor index for inserting style\n     * @param {Array} [copiedStyle] array of style objects to insert.\n     */insertNewStyleBlock:function(insertedText,start,copiedStyle){var cursorLoc=this.get2DCursorLocation(start,true),addedLines=[0],linesLength=0;// get an array of how many char per lines are being added.\nfor(var i=0;i<insertedText.length;i++){if(insertedText[i]==='\\n'){linesLength++;addedLines[linesLength]=0;}else{addedLines[linesLength]++;}}// for the first line copy the style from the current char position.\nif(addedLines[0]>0){this.insertCharStyleObject(cursorLoc.lineIndex,cursorLoc.charIndex,addedLines[0],copiedStyle);copiedStyle=copiedStyle&&copiedStyle.slice(addedLines[0]+1);}linesLength&&this.insertNewlineStyleObject(cursorLoc.lineIndex,cursorLoc.charIndex+addedLines[0],linesLength);for(var i=1;i<linesLength;i++){if(addedLines[i]>0){this.insertCharStyleObject(cursorLoc.lineIndex+i,0,addedLines[i],copiedStyle);}else if(copiedStyle){this.styles[cursorLoc.lineIndex+i][0]=copiedStyle[0];}copiedStyle=copiedStyle&&copiedStyle.slice(addedLines[i]+1);}// we use i outside the loop to get it like linesLength\nif(addedLines[i]>0){this.insertCharStyleObject(cursorLoc.lineIndex+i,0,addedLines[i],copiedStyle);}},/**\n     * Set the selectionStart and selectionEnd according to the new position of cursor\n     * mimic the key - mouse navigation when shift is pressed.\n     */setSelectionStartEndWithShift:function(start,end,newSelection){if(newSelection<=start){if(end===start){this._selectionDirection='left';}else if(this._selectionDirection==='right'){this._selectionDirection='left';this.selectionEnd=start;}this.selectionStart=newSelection;}else if(newSelection>start&&newSelection<end){if(this._selectionDirection==='right'){this.selectionEnd=newSelection;}else{this.selectionStart=newSelection;}}else{// newSelection is > selection start and end\nif(end===start){this._selectionDirection='right';}else if(this._selectionDirection==='left'){this._selectionDirection='right';this.selectionStart=end;}this.selectionEnd=newSelection;}},setSelectionInBoundaries:function(){var length=this.text.length;if(this.selectionStart>length){this.selectionStart=length;}else if(this.selectionStart<0){this.selectionStart=0;}if(this.selectionEnd>length){this.selectionEnd=length;}else if(this.selectionEnd<0){this.selectionEnd=0;}}});})();fabric.util.object.extend(fabric.IText.prototype,/** @lends fabric.IText.prototype */{/**\n   * Initializes \"dbclick\" event handler\n   */initDoubleClickSimulation:function(){// for double click\nthis.__lastClickTime=+new Date();// for triple click\nthis.__lastLastClickTime=+new Date();this.__lastPointer={};this.on('mousedown',this.onMouseDown);},/**\n   * Default event handler to simulate triple click\n   * @private\n   */onMouseDown:function(options){if(!this.canvas){return;}this.__newClickTime=+new Date();var newPointer=options.pointer;if(this.isTripleClick(newPointer)){this.fire('tripleclick',options);this._stopEvent(options.e);}this.__lastLastClickTime=this.__lastClickTime;this.__lastClickTime=this.__newClickTime;this.__lastPointer=newPointer;this.__lastIsEditing=this.isEditing;this.__lastSelected=this.selected;},isTripleClick:function(newPointer){return this.__newClickTime-this.__lastClickTime<500&&this.__lastClickTime-this.__lastLastClickTime<500&&this.__lastPointer.x===newPointer.x&&this.__lastPointer.y===newPointer.y;},/**\n   * @private\n   */_stopEvent:function(e){e.preventDefault&&e.preventDefault();e.stopPropagation&&e.stopPropagation();},/**\n   * Initializes event handlers related to cursor or selection\n   */initCursorSelectionHandlers:function(){this.initMousedownHandler();this.initMouseupHandler();this.initClicks();},/**\n   * Default handler for double click, select a word\n   */doubleClickHandler:function(options){if(!this.isEditing){return;}this.selectWord(this.getSelectionStartFromPointer(options.e));},/**\n   * Default handler for triple click, select a line\n   */tripleClickHandler:function(options){if(!this.isEditing){return;}this.selectLine(this.getSelectionStartFromPointer(options.e));},/**\n   * Initializes double and triple click event handlers\n   */initClicks:function(){this.on('mousedblclick',this.doubleClickHandler);this.on('tripleclick',this.tripleClickHandler);},/**\n   * Default event handler for the basic functionalities needed on _mouseDown\n   * can be overridden to do something different.\n   * Scope of this implementation is: find the click position, set selectionStart\n   * find selectionEnd, initialize the drawing of either cursor or selection area\n   * initializing a mousedDown on a text area will cancel fabricjs knowledge of\n   * current compositionMode. It will be set to false.\n   */_mouseDownHandler:function(options){if(!this.canvas||!this.editable||options.e.button&&options.e.button!==1){return;}this.__isMousedown=true;if(this.selected){this.inCompositionMode=false;this.setCursorByClick(options.e);}if(this.isEditing){this.__selectionStartOnMouseDown=this.selectionStart;if(this.selectionStart===this.selectionEnd){this.abortCursorAnimation();}this.renderCursorOrSelection();}},/**\n   * Default event handler for the basic functionalities needed on mousedown:before\n   * can be overridden to do something different.\n   * Scope of this implementation is: verify the object is already selected when mousing down\n   */_mouseDownHandlerBefore:function(options){if(!this.canvas||!this.editable||options.e.button&&options.e.button!==1){return;}// we want to avoid that an object that was selected and then becomes unselectable,\n// may trigger editing mode in some way.\nthis.selected=this===this.canvas._activeObject;},/**\n   * Initializes \"mousedown\" event handler\n   */initMousedownHandler:function(){this.on('mousedown',this._mouseDownHandler);this.on('mousedown:before',this._mouseDownHandlerBefore);},/**\n   * Initializes \"mouseup\" event handler\n   */initMouseupHandler:function(){this.on('mouseup',this.mouseUpHandler);},/**\n   * standard handler for mouse up, overridable\n   * @private\n   */mouseUpHandler:function(options){this.__isMousedown=false;if(!this.editable||this.group||options.transform&&options.transform.actionPerformed||options.e.button&&options.e.button!==1){return;}if(this.canvas){var currentActive=this.canvas._activeObject;if(currentActive&&currentActive!==this){// avoid running this logic when there is an active object\n// this because is possible with shift click and fast clicks,\n// to rapidly deselect and reselect this object and trigger an enterEdit\nreturn;}}if(this.__lastSelected&&!this.__corner){this.selected=false;this.__lastSelected=false;this.enterEditing(options.e);if(this.selectionStart===this.selectionEnd){this.initDelayedCursor(true);}else{this.renderCursorOrSelection();}}else{this.selected=true;}},/**\n   * Changes cursor location in a text depending on passed pointer (x/y) object\n   * @param {Event} e Event object\n   */setCursorByClick:function(e){var newSelection=this.getSelectionStartFromPointer(e),start=this.selectionStart,end=this.selectionEnd;if(e.shiftKey){this.setSelectionStartEndWithShift(start,end,newSelection);}else{this.selectionStart=newSelection;this.selectionEnd=newSelection;}if(this.isEditing){this._fireSelectionChanged();this._updateTextarea();}},/**\n   * Returns index of a character corresponding to where an object was clicked\n   * @param {Event} e Event object\n   * @return {Number} Index of a character\n   */getSelectionStartFromPointer:function(e){var mouseOffset=this.getLocalPointer(e),prevWidth=0,width=0,height=0,charIndex=0,lineIndex=0,lineLeftOffset,line;for(var i=0,len=this._textLines.length;i<len;i++){if(height<=mouseOffset.y){height+=this.getHeightOfLine(i)*this.scaleY;lineIndex=i;if(i>0){charIndex+=this._textLines[i-1].length+this.missingNewlineOffset(i-1);}}else{break;}}lineLeftOffset=this._getLineLeftOffset(lineIndex);width=lineLeftOffset*this.scaleX;line=this._textLines[lineIndex];// handling of RTL: in order to get things work correctly,\n// we assume RTL writing is mirrored compared to LTR writing.\n// so in position detection we mirror the X offset, and when is time\n// of rendering it, we mirror it again.\nif(this.direction==='rtl'){mouseOffset.x=this.width*this.scaleX-mouseOffset.x+width;}for(var j=0,jlen=line.length;j<jlen;j++){prevWidth=width;// i removed something about flipX here, check.\nwidth+=this.__charBounds[lineIndex][j].kernedWidth*this.scaleX;if(width<=mouseOffset.x){charIndex++;}else{break;}}return this._getNewSelectionStartFromOffset(mouseOffset,prevWidth,width,charIndex,jlen);},/**\n   * @private\n   */_getNewSelectionStartFromOffset:function(mouseOffset,prevWidth,width,index,jlen){// we need Math.abs because when width is after the last char, the offset is given as 1, while is 0\nvar distanceBtwLastCharAndCursor=mouseOffset.x-prevWidth,distanceBtwNextCharAndCursor=width-mouseOffset.x,offset=distanceBtwNextCharAndCursor>distanceBtwLastCharAndCursor||distanceBtwNextCharAndCursor<0?0:1,newSelectionStart=index+offset;// if object is horizontally flipped, mirror cursor location from the end\nif(this.flipX){newSelectionStart=jlen-newSelectionStart;}if(newSelectionStart>this._text.length){newSelectionStart=this._text.length;}return newSelectionStart;}});fabric.util.object.extend(fabric.IText.prototype,/** @lends fabric.IText.prototype */{/**\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\n   */initHiddenTextarea:function(){this.hiddenTextarea=fabric.document.createElement('textarea');this.hiddenTextarea.setAttribute('autocapitalize','off');this.hiddenTextarea.setAttribute('autocorrect','off');this.hiddenTextarea.setAttribute('autocomplete','off');this.hiddenTextarea.setAttribute('spellcheck','false');this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea','');this.hiddenTextarea.setAttribute('wrap','off');var style=this._calcTextareaPosition();// line-height: 1px; was removed from the style to fix this:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=870966\nthis.hiddenTextarea.style.cssText='position: absolute; top: '+style.top+'; left: '+style.left+'; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;'+' paddingtop: '+style.fontSize+';';if(this.hiddenTextareaContainer){this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);}else{fabric.document.body.appendChild(this.hiddenTextarea);}fabric.util.addListener(this.hiddenTextarea,'keydown',this.onKeyDown.bind(this));fabric.util.addListener(this.hiddenTextarea,'keyup',this.onKeyUp.bind(this));fabric.util.addListener(this.hiddenTextarea,'input',this.onInput.bind(this));fabric.util.addListener(this.hiddenTextarea,'copy',this.copy.bind(this));fabric.util.addListener(this.hiddenTextarea,'cut',this.copy.bind(this));fabric.util.addListener(this.hiddenTextarea,'paste',this.paste.bind(this));fabric.util.addListener(this.hiddenTextarea,'compositionstart',this.onCompositionStart.bind(this));fabric.util.addListener(this.hiddenTextarea,'compositionupdate',this.onCompositionUpdate.bind(this));fabric.util.addListener(this.hiddenTextarea,'compositionend',this.onCompositionEnd.bind(this));if(!this._clickHandlerInitialized&&this.canvas){fabric.util.addListener(this.canvas.upperCanvasEl,'click',this.onClick.bind(this));this._clickHandlerInitialized=true;}},/**\n   * For functionalities on keyDown\n   * Map a special key to a function of the instance/prototype\n   * If you need different behaviour for ESC or TAB or arrows, you have to change\n   * this map setting the name of a function that you build on the fabric.Itext or\n   * your prototype.\n   * the map change will affect all Instances unless you need for only some text Instances\n   * in that case you have to clone this object and assign your Instance.\n   * this.keysMap = fabric.util.object.clone(this.keysMap);\n   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]\n   */keysMap:{9:'exitEditing',27:'exitEditing',33:'moveCursorUp',34:'moveCursorDown',35:'moveCursorRight',36:'moveCursorLeft',37:'moveCursorLeft',38:'moveCursorUp',39:'moveCursorRight',40:'moveCursorDown'},keysMapRtl:{9:'exitEditing',27:'exitEditing',33:'moveCursorUp',34:'moveCursorDown',35:'moveCursorLeft',36:'moveCursorRight',37:'moveCursorRight',38:'moveCursorUp',39:'moveCursorLeft',40:'moveCursorDown'},/**\n   * For functionalities on keyUp + ctrl || cmd\n   */ctrlKeysMapUp:{67:'copy',88:'cut'},/**\n   * For functionalities on keyDown + ctrl || cmd\n   */ctrlKeysMapDown:{65:'selectAll'},onClick:function(){// No need to trigger click event here, focus is enough to have the keyboard appear on Android\nthis.hiddenTextarea&&this.hiddenTextarea.focus();},/**\n   * Handles keydown event\n   * only used for arrows and combination of modifier keys.\n   * @param {Event} e Event object\n   */onKeyDown:function(e){if(!this.isEditing){return;}var keyMap=this.direction==='rtl'?this.keysMapRtl:this.keysMap;if(e.keyCode in keyMap){this[keyMap[e.keyCode]](e);}else if(e.keyCode in this.ctrlKeysMapDown&&(e.ctrlKey||e.metaKey)){this[this.ctrlKeysMapDown[e.keyCode]](e);}else{return;}e.stopImmediatePropagation();e.preventDefault();if(e.keyCode>=33&&e.keyCode<=40){// if i press an arrow key just update selection\nthis.inCompositionMode=false;this.clearContextTop();this.renderCursorOrSelection();}else{this.canvas&&this.canvas.requestRenderAll();}},/**\n   * Handles keyup event\n   * We handle KeyUp because ie11 and edge have difficulties copy/pasting\n   * if a copy/cut event fired, keyup is dismissed\n   * @param {Event} e Event object\n   */onKeyUp:function(e){if(!this.isEditing||this._copyDone||this.inCompositionMode){this._copyDone=false;return;}if(e.keyCode in this.ctrlKeysMapUp&&(e.ctrlKey||e.metaKey)){this[this.ctrlKeysMapUp[e.keyCode]](e);}else{return;}e.stopImmediatePropagation();e.preventDefault();this.canvas&&this.canvas.requestRenderAll();},/**\n   * Handles onInput event\n   * @param {Event} e Event object\n   */onInput:function(e){var fromPaste=this.fromPaste;this.fromPaste=false;e&&e.stopPropagation();if(!this.isEditing){return;}// decisions about style changes.\nvar nextText=this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,charCount=this._text.length,nextCharCount=nextText.length,removedText,insertedText,charDiff=nextCharCount-charCount,selectionStart=this.selectionStart,selectionEnd=this.selectionEnd,selection=selectionStart!==selectionEnd,copiedStyle,removeFrom,removeTo;if(this.hiddenTextarea.value===''){this.styles={};this.updateFromTextArea();this.fire('changed');if(this.canvas){this.canvas.fire('text:changed',{target:this});this.canvas.requestRenderAll();}return;}var textareaSelection=this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart,this.hiddenTextarea.selectionEnd,this.hiddenTextarea.value);var backDelete=selectionStart>textareaSelection.selectionStart;if(selection){removedText=this._text.slice(selectionStart,selectionEnd);charDiff+=selectionEnd-selectionStart;}else if(nextCharCount<charCount){if(backDelete){removedText=this._text.slice(selectionEnd+charDiff,selectionEnd);}else{removedText=this._text.slice(selectionStart,selectionStart-charDiff);}}insertedText=nextText.slice(textareaSelection.selectionEnd-charDiff,textareaSelection.selectionEnd);if(removedText&&removedText.length){if(insertedText.length){// let's copy some style before deleting.\n// we want to copy the style before the cursor OR the style at the cursor if selection\n// is bigger than 0.\ncopiedStyle=this.getSelectionStyles(selectionStart,selectionStart+1,false);// now duplicate the style one for each inserted text.\ncopiedStyle=insertedText.map(function(){// this return an array of references, but that is fine since we are\n// copying the style later.\nreturn copiedStyle[0];});}if(selection){removeFrom=selectionStart;removeTo=selectionEnd;}else if(backDelete){// detect differences between forwardDelete and backDelete\nremoveFrom=selectionEnd-removedText.length;removeTo=selectionEnd;}else{removeFrom=selectionEnd;removeTo=selectionEnd+removedText.length;}this.removeStyleFromTo(removeFrom,removeTo);}if(insertedText.length){if(fromPaste&&insertedText.join('')===fabric.copiedText&&!fabric.disableStyleCopyPaste){copiedStyle=fabric.copiedTextStyle;}this.insertNewStyleBlock(insertedText,selectionStart,copiedStyle);}this.updateFromTextArea();this.fire('changed');if(this.canvas){this.canvas.fire('text:changed',{target:this});this.canvas.requestRenderAll();}},/**\n   * Composition start\n   */onCompositionStart:function(){this.inCompositionMode=true;},/**\n   * Composition end\n   */onCompositionEnd:function(){this.inCompositionMode=false;},// /**\n//  * Composition update\n//  */\nonCompositionUpdate:function(e){this.compositionStart=e.target.selectionStart;this.compositionEnd=e.target.selectionEnd;this.updateTextareaPosition();},/**\n   * Copies selected text\n   * @param {Event} e Event object\n   */copy:function(){if(this.selectionStart===this.selectionEnd){//do not cut-copy if no selection\nreturn;}fabric.copiedText=this.getSelectedText();if(!fabric.disableStyleCopyPaste){fabric.copiedTextStyle=this.getSelectionStyles(this.selectionStart,this.selectionEnd,true);}else{fabric.copiedTextStyle=null;}this._copyDone=true;},/**\n   * Pastes text\n   * @param {Event} e Event object\n   */paste:function(){this.fromPaste=true;},/**\n   * @private\n   * @param {Event} e Event object\n   * @return {Object} Clipboard data object\n   */_getClipboardData:function(e){return e&&e.clipboardData||fabric.window.clipboardData;},/**\n   * Finds the width in pixels before the cursor on the same line\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {Number} widthBeforeCursor width before cursor\n   */_getWidthBeforeCursor:function(lineIndex,charIndex){var widthBeforeCursor=this._getLineLeftOffset(lineIndex),bound;if(charIndex>0){bound=this.__charBounds[lineIndex][charIndex-1];widthBeforeCursor+=bound.left+bound.width;}return widthBeforeCursor;},/**\n   * Gets start offset of a selection\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */getDownCursorOffset:function(e,isRight){var selectionProp=this._getSelectionForOffset(e,isRight),cursorLocation=this.get2DCursorLocation(selectionProp),lineIndex=cursorLocation.lineIndex;// if on last line, down cursor goes to end of line\nif(lineIndex===this._textLines.length-1||e.metaKey||e.keyCode===34){// move to the end of a text\nreturn this._text.length-selectionProp;}var charIndex=cursorLocation.charIndex,widthBeforeCursor=this._getWidthBeforeCursor(lineIndex,charIndex),indexOnOtherLine=this._getIndexOnLine(lineIndex+1,widthBeforeCursor),textAfterCursor=this._textLines[lineIndex].slice(charIndex);return textAfterCursor.length+indexOnOtherLine+1+this.missingNewlineOffset(lineIndex);},/**\n   * private\n   * Helps finding if the offset should be counted from Start or End\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */_getSelectionForOffset:function(e,isRight){if(e.shiftKey&&this.selectionStart!==this.selectionEnd&&isRight){return this.selectionEnd;}else{return this.selectionStart;}},/**\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */getUpCursorOffset:function(e,isRight){var selectionProp=this._getSelectionForOffset(e,isRight),cursorLocation=this.get2DCursorLocation(selectionProp),lineIndex=cursorLocation.lineIndex;if(lineIndex===0||e.metaKey||e.keyCode===33){// if on first line, up cursor goes to start of line\nreturn-selectionProp;}var charIndex=cursorLocation.charIndex,widthBeforeCursor=this._getWidthBeforeCursor(lineIndex,charIndex),indexOnOtherLine=this._getIndexOnLine(lineIndex-1,widthBeforeCursor),textBeforeCursor=this._textLines[lineIndex].slice(0,charIndex),missingNewlineOffset=this.missingNewlineOffset(lineIndex-1);// return a negative offset\nreturn-this._textLines[lineIndex-1].length+indexOnOtherLine-textBeforeCursor.length+(1-missingNewlineOffset);},/**\n   * for a given width it founds the matching character.\n   * @private\n   */_getIndexOnLine:function(lineIndex,width){var line=this._textLines[lineIndex],lineLeftOffset=this._getLineLeftOffset(lineIndex),widthOfCharsOnLine=lineLeftOffset,indexOnLine=0,charWidth,foundMatch;for(var j=0,jlen=line.length;j<jlen;j++){charWidth=this.__charBounds[lineIndex][j].width;widthOfCharsOnLine+=charWidth;if(widthOfCharsOnLine>width){foundMatch=true;var leftEdge=widthOfCharsOnLine-charWidth,rightEdge=widthOfCharsOnLine,offsetFromLeftEdge=Math.abs(leftEdge-width),offsetFromRightEdge=Math.abs(rightEdge-width);indexOnLine=offsetFromRightEdge<offsetFromLeftEdge?j:j-1;break;}}// reached end\nif(!foundMatch){indexOnLine=line.length-1;}return indexOnLine;},/**\n   * Moves cursor down\n   * @param {Event} e Event object\n   */moveCursorDown:function(e){if(this.selectionStart>=this._text.length&&this.selectionEnd>=this._text.length){return;}this._moveCursorUpOrDown('Down',e);},/**\n   * Moves cursor up\n   * @param {Event} e Event object\n   */moveCursorUp:function(e){if(this.selectionStart===0&&this.selectionEnd===0){return;}this._moveCursorUpOrDown('Up',e);},/**\n   * Moves cursor up or down, fires the events\n   * @param {String} direction 'Up' or 'Down'\n   * @param {Event} e Event object\n   */_moveCursorUpOrDown:function(direction,e){// getUpCursorOffset\n// getDownCursorOffset\nvar action='get'+direction+'CursorOffset',offset=this[action](e,this._selectionDirection==='right');if(e.shiftKey){this.moveCursorWithShift(offset);}else{this.moveCursorWithoutShift(offset);}if(offset!==0){this.setSelectionInBoundaries();this.abortCursorAnimation();this._currentCursorOpacity=1;this.initDelayedCursor();this._fireSelectionChanged();this._updateTextarea();}},/**\n   * Moves cursor with shift\n   * @param {Number} offset\n   */moveCursorWithShift:function(offset){var newSelection=this._selectionDirection==='left'?this.selectionStart+offset:this.selectionEnd+offset;this.setSelectionStartEndWithShift(this.selectionStart,this.selectionEnd,newSelection);return offset!==0;},/**\n   * Moves cursor up without shift\n   * @param {Number} offset\n   */moveCursorWithoutShift:function(offset){if(offset<0){this.selectionStart+=offset;this.selectionEnd=this.selectionStart;}else{this.selectionEnd+=offset;this.selectionStart=this.selectionEnd;}return offset!==0;},/**\n   * Moves cursor left\n   * @param {Event} e Event object\n   */moveCursorLeft:function(e){if(this.selectionStart===0&&this.selectionEnd===0){return;}this._moveCursorLeftOrRight('Left',e);},/**\n   * @private\n   * @return {Boolean} true if a change happened\n   */_move:function(e,prop,direction){var newValue;if(e.altKey){newValue=this['findWordBoundary'+direction](this[prop]);}else if(e.metaKey||e.keyCode===35||e.keyCode===36){newValue=this['findLineBoundary'+direction](this[prop]);}else{this[prop]+=direction==='Left'?-1:1;return true;}if(typeof newValue!==undefined&&this[prop]!==newValue){this[prop]=newValue;return true;}},/**\n   * @private\n   */_moveLeft:function(e,prop){return this._move(e,prop,'Left');},/**\n   * @private\n   */_moveRight:function(e,prop){return this._move(e,prop,'Right');},/**\n   * Moves cursor left without keeping selection\n   * @param {Event} e\n   */moveCursorLeftWithoutShift:function(e){var change=true;this._selectionDirection='left';// only move cursor when there is no selection,\n// otherwise we discard it, and leave cursor on same place\nif(this.selectionEnd===this.selectionStart&&this.selectionStart!==0){change=this._moveLeft(e,'selectionStart');}this.selectionEnd=this.selectionStart;return change;},/**\n   * Moves cursor left while keeping selection\n   * @param {Event} e\n   */moveCursorLeftWithShift:function(e){if(this._selectionDirection==='right'&&this.selectionStart!==this.selectionEnd){return this._moveLeft(e,'selectionEnd');}else if(this.selectionStart!==0){this._selectionDirection='left';return this._moveLeft(e,'selectionStart');}},/**\n   * Moves cursor right\n   * @param {Event} e Event object\n   */moveCursorRight:function(e){if(this.selectionStart>=this._text.length&&this.selectionEnd>=this._text.length){return;}this._moveCursorLeftOrRight('Right',e);},/**\n   * Moves cursor right or Left, fires event\n   * @param {String} direction 'Left', 'Right'\n   * @param {Event} e Event object\n   */_moveCursorLeftOrRight:function(direction,e){var actionName='moveCursor'+direction+'With';this._currentCursorOpacity=1;if(e.shiftKey){actionName+='Shift';}else{actionName+='outShift';}if(this[actionName](e)){this.abortCursorAnimation();this.initDelayedCursor();this._fireSelectionChanged();this._updateTextarea();}},/**\n   * Moves cursor right while keeping selection\n   * @param {Event} e\n   */moveCursorRightWithShift:function(e){if(this._selectionDirection==='left'&&this.selectionStart!==this.selectionEnd){return this._moveRight(e,'selectionStart');}else if(this.selectionEnd!==this._text.length){this._selectionDirection='right';return this._moveRight(e,'selectionEnd');}},/**\n   * Moves cursor right without keeping selection\n   * @param {Event} e Event object\n   */moveCursorRightWithoutShift:function(e){var changed=true;this._selectionDirection='right';if(this.selectionStart===this.selectionEnd){changed=this._moveRight(e,'selectionStart');this.selectionEnd=this.selectionStart;}else{this.selectionStart=this.selectionEnd;}return changed;},/**\n   * Removes characters from start/end\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */removeChars:function(start,end){if(typeof end==='undefined'){end=start+1;}this.removeStyleFromTo(start,end);this._text.splice(start,end-start);this.text=this._text.join('');this.set('dirty',true);if(this._shouldClearDimensionCache()){this.initDimensions();this.setCoords();}this._removeExtraneousStyles();},/**\n   * insert characters at start position, before start position.\n   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1\n   * if style array is provided, it must be as the same length of text in graphemes\n   * if end is provided and is bigger than start, old text is replaced.\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {String} text text to insert\n   * @param {Array} style array of style objects\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */insertChars:function(text,style,start,end){if(typeof end==='undefined'){end=start;}if(end>start){this.removeStyleFromTo(start,end);}var graphemes=fabric.util.string.graphemeSplit(text);this.insertNewStyleBlock(graphemes,start,style);this._text=[].concat(this._text.slice(0,start),graphemes,this._text.slice(end));this.text=this._text.join('');this.set('dirty',true);if(this._shouldClearDimensionCache()){this.initDimensions();this.setCoords();}this._removeExtraneousStyles();}});/* _TO_SVG_START_ */(function(){var toFixed=fabric.util.toFixed,multipleSpacesRegex=/  +/g;fabric.util.object.extend(fabric.Text.prototype,/** @lends fabric.Text.prototype */{/**\n     * Returns SVG representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */_toSVG:function(){var offsets=this._getSVGLeftTopOffsets(),textAndBg=this._getSVGTextAndBg(offsets.textTop,offsets.textLeft);return this._wrapSVGTextAndBg(textAndBg);},/**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */toSVG:function(reviver){return this._createBaseSVGMarkup(this._toSVG(),{reviver:reviver,noStyle:true,withShadow:true});},/**\n     * @private\n     */_getSVGLeftTopOffsets:function(){return{textLeft:-this.width/2,textTop:-this.height/2,lineTop:this.getHeightOfLine(0)};},/**\n     * @private\n     */_wrapSVGTextAndBg:function(textAndBg){var noShadow=true,textDecoration=this.getSvgTextDecoration(this);return[textAndBg.textBgRects.join(''),'\\t\\t<text xml:space=\"preserve\" ',this.fontFamily?'font-family=\"'+this.fontFamily.replace(/\"/g,'\\'')+'\" ':'',this.fontSize?'font-size=\"'+this.fontSize+'\" ':'',this.fontStyle?'font-style=\"'+this.fontStyle+'\" ':'',this.fontWeight?'font-weight=\"'+this.fontWeight+'\" ':'',textDecoration?'text-decoration=\"'+textDecoration+'\" ':'','style=\"',this.getSvgStyles(noShadow),'\"',this.addPaintOrder(),' >',textAndBg.textSpans.join(''),'</text>\\n'];},/**\n     * @private\n     * @param {Number} textTopOffset Text top offset\n     * @param {Number} textLeftOffset Text left offset\n     * @return {Object}\n     */_getSVGTextAndBg:function(textTopOffset,textLeftOffset){var textSpans=[],textBgRects=[],height=textTopOffset,lineOffset;// bounding-box background\nthis._setSVGBg(textBgRects);// text and text-background\nfor(var i=0,len=this._textLines.length;i<len;i++){lineOffset=this._getLineLeftOffset(i);if(this.textBackgroundColor||this.styleHas('textBackgroundColor',i)){this._setSVGTextLineBg(textBgRects,i,textLeftOffset+lineOffset,height);}this._setSVGTextLineText(textSpans,i,textLeftOffset+lineOffset,height);height+=this.getHeightOfLine(i);}return{textSpans:textSpans,textBgRects:textBgRects};},/**\n     * @private\n     */_createTextCharSpan:function(_char,styleDecl,left,top){var shouldUseWhitespace=_char!==_char.trim()||_char.match(multipleSpacesRegex),styleProps=this.getSvgSpanStyles(styleDecl,shouldUseWhitespace),fillStyles=styleProps?'style=\"'+styleProps+'\"':'',dy=styleDecl.deltaY,dySpan='',NUM_FRACTION_DIGITS=fabric.Object.NUM_FRACTION_DIGITS;if(dy){dySpan=' dy=\"'+toFixed(dy,NUM_FRACTION_DIGITS)+'\" ';}return['<tspan x=\"',toFixed(left,NUM_FRACTION_DIGITS),'\" y=\"',toFixed(top,NUM_FRACTION_DIGITS),'\" ',dySpan,fillStyles,'>',fabric.util.string.escapeXml(_char),'</tspan>'].join('');},_setSVGTextLineText:function(textSpans,lineIndex,textLeftOffset,textTopOffset){// set proper line offset\nvar lineHeight=this.getHeightOfLine(lineIndex),isJustify=this.textAlign.indexOf('justify')!==-1,actualStyle,nextStyle,charsToRender='',charBox,style,boxWidth=0,line=this._textLines[lineIndex],timeToRender;textTopOffset+=lineHeight*(1-this._fontSizeFraction)/this.lineHeight;for(var i=0,len=line.length-1;i<=len;i++){timeToRender=i===len||this.charSpacing;charsToRender+=line[i];charBox=this.__charBounds[lineIndex][i];if(boxWidth===0){textLeftOffset+=charBox.kernedWidth-charBox.width;boxWidth+=charBox.width;}else{boxWidth+=charBox.kernedWidth;}if(isJustify&&!timeToRender){if(this._reSpaceAndTab.test(line[i])){timeToRender=true;}}if(!timeToRender){// if we have charSpacing, we render char by char\nactualStyle=actualStyle||this.getCompleteStyleDeclaration(lineIndex,i);nextStyle=this.getCompleteStyleDeclaration(lineIndex,i+1);timeToRender=this._hasStyleChangedForSvg(actualStyle,nextStyle);}if(timeToRender){style=this._getStyleDeclaration(lineIndex,i)||{};textSpans.push(this._createTextCharSpan(charsToRender,style,textLeftOffset,textTopOffset));charsToRender='';actualStyle=nextStyle;textLeftOffset+=boxWidth;boxWidth=0;}}},_pushTextBgRect:function(textBgRects,color,left,top,width,height){var NUM_FRACTION_DIGITS=fabric.Object.NUM_FRACTION_DIGITS;textBgRects.push('\\t\\t<rect ',this._getFillAttributes(color),' x=\"',toFixed(left,NUM_FRACTION_DIGITS),'\" y=\"',toFixed(top,NUM_FRACTION_DIGITS),'\" width=\"',toFixed(width,NUM_FRACTION_DIGITS),'\" height=\"',toFixed(height,NUM_FRACTION_DIGITS),'\"></rect>\\n');},_setSVGTextLineBg:function(textBgRects,i,leftOffset,textTopOffset){var line=this._textLines[i],heightOfLine=this.getHeightOfLine(i)/this.lineHeight,boxWidth=0,boxStart=0,charBox,currentColor,lastColor=this.getValueOfPropertyAt(i,0,'textBackgroundColor');for(var j=0,jlen=line.length;j<jlen;j++){charBox=this.__charBounds[i][j];currentColor=this.getValueOfPropertyAt(i,j,'textBackgroundColor');if(currentColor!==lastColor){lastColor&&this._pushTextBgRect(textBgRects,lastColor,leftOffset+boxStart,textTopOffset,boxWidth,heightOfLine);boxStart=charBox.left;boxWidth=charBox.width;lastColor=currentColor;}else{boxWidth+=charBox.kernedWidth;}}currentColor&&this._pushTextBgRect(textBgRects,currentColor,leftOffset+boxStart,textTopOffset,boxWidth,heightOfLine);},/**\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\n     * we work around it by \"moving\" alpha channel into opacity attribute and setting fill's alpha to 1\n     *\n     * @private\n     * @param {*} value\n     * @return {String}\n     */_getFillAttributes:function(value){var fillColor=value&&typeof value==='string'?new fabric.Color(value):'';if(!fillColor||!fillColor.getSource()||fillColor.getAlpha()===1){return'fill=\"'+value+'\"';}return'opacity=\"'+fillColor.getAlpha()+'\" fill=\"'+fillColor.setAlpha(1).toRgb()+'\"';},/**\n     * @private\n     */_getSVGLineTopOffset:function(lineIndex){var lineTopOffset=0,lastHeight=0;for(var j=0;j<lineIndex;j++){lineTopOffset+=this.getHeightOfLine(j);}lastHeight=this.getHeightOfLine(j);return{lineTop:lineTopOffset,offset:(this._fontSizeMult-this._fontSizeFraction)*lastHeight/(this.lineHeight*this._fontSizeMult)};},/**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */getSvgStyles:function(skipShadow){var svgStyle=fabric.Object.prototype.getSvgStyles.call(this,skipShadow);return svgStyle+' white-space: pre;';}});})();/* _TO_SVG_END_ */(function(global){'use strict';var fabric=global.fabric||(global.fabric={});/**\n   * Textbox class, based on IText, allows the user to resize the text rectangle\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\n   * user can only change width. Height is adjusted automatically based on the\n   * wrapping of lines.\n   * @class fabric.Textbox\n   * @extends fabric.IText\n   * @mixes fabric.Observable\n   * @return {fabric.Textbox} thisArg\n   * @see {@link fabric.Textbox#initialize} for constructor definition\n   */fabric.Textbox=fabric.util.createClass(fabric.IText,fabric.Observable,{/**\n     * Type of an object\n     * @type String\n     * @default\n     */type:'textbox',/**\n     * Minimum width of textbox, in pixels.\n     * @type Number\n     * @default\n     */minWidth:20,/**\n     * Minimum calculated width of a textbox, in pixels.\n     * fixed to 2 so that an empty textbox cannot go to 0\n     * and is still selectable without text.\n     * @type Number\n     * @default\n     */dynamicMinWidth:2,/**\n     * Cached array of text wrapping.\n     * @type Array\n     */__cachedLines:null,/**\n     * Override standard Object class values\n     */lockScalingFlip:true,/**\n     * Override standard Object class values\n     * Textbox needs this on false\n     */noScaleCache:false,/**\n     * Properties which when set cause object to change dimensions\n     * @type Object\n     * @private\n     */_dimensionAffectingProps:fabric.Text.prototype._dimensionAffectingProps.concat('width'),/**\n     * Use this regular expression to split strings in breakable lines\n     * @private\n     */_wordJoiners:/[ \\t\\r]/,/**\n     * Use this boolean property in order to split strings that have no white space concept.\n     * this is a cheap way to help with chinese/japanese\n     * @type Boolean\n     * @since 2.6.0\n     */splitByGrapheme:false,/**\n     * Unlike superclass's version of this function, Textbox does not update\n     * its width.\n     * @private\n     * @override\n     */initDimensions:function(){if(this.__skipDimension){return;}this.isEditing&&this.initDelayedCursor();this.clearContextTop();this._clearCache();// clear dynamicMinWidth as it will be different after we re-wrap line\nthis.dynamicMinWidth=0;// wrap lines\nthis._styleMap=this._generateStyleMap(this._splitText());// if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\nif(this.dynamicMinWidth>this.width){this._set('width',this.dynamicMinWidth);}if(this.textAlign.indexOf('justify')!==-1){// once text is measured we need to make space fatter to make justified text.\nthis.enlargeSpaces();}// clear cache and re-calculate height\nthis.height=this.calcTextHeight();this.saveState({propertySet:'_dimensionAffectingProps'});},/**\n     * Generate an object that translates the style object so that it is\n     * broken up by visual lines (new lines and automatic wrapping).\n     * The original text styles object is broken up by actual lines (new lines only),\n     * which is only sufficient for Text / IText\n     * @private\n     */_generateStyleMap:function(textInfo){var realLineCount=0,realLineCharCount=0,charCount=0,map={};for(var i=0;i<textInfo.graphemeLines.length;i++){if(textInfo.graphemeText[charCount]==='\\n'&&i>0){realLineCharCount=0;charCount++;realLineCount++;}else if(!this.splitByGrapheme&&this._reSpaceAndTab.test(textInfo.graphemeText[charCount])&&i>0){// this case deals with space's that are removed from end of lines when wrapping\nrealLineCharCount++;charCount++;}map[i]={line:realLineCount,offset:realLineCharCount};charCount+=textInfo.graphemeLines[i].length;realLineCharCount+=textInfo.graphemeLines[i].length;}return map;},/**\n     * Returns true if object has a style property or has it on a specified line\n     * @param {Number} lineIndex\n     * @return {Boolean}\n     */styleHas:function(property,lineIndex){if(this._styleMap&&!this.isWrapping){var map=this._styleMap[lineIndex];if(map){lineIndex=map.line;}}return fabric.Text.prototype.styleHas.call(this,property,lineIndex);},/**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */isEmptyStyles:function(lineIndex){if(!this.styles){return true;}var offset=0,nextLineIndex=lineIndex+1,nextOffset,obj,shouldLimit=false,map=this._styleMap[lineIndex],mapNextLine=this._styleMap[lineIndex+1];if(map){lineIndex=map.line;offset=map.offset;}if(mapNextLine){nextLineIndex=mapNextLine.line;shouldLimit=nextLineIndex===lineIndex;nextOffset=mapNextLine.offset;}obj=typeof lineIndex==='undefined'?this.styles:{line:this.styles[lineIndex]};for(var p1 in obj){for(var p2 in obj[p1]){if(p2>=offset&&(!shouldLimit||p2<nextOffset)){// eslint-disable-next-line no-unused-vars\nfor(var p3 in obj[p1][p2]){return false;}}}}return true;},/**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */_getStyleDeclaration:function(lineIndex,charIndex){if(this._styleMap&&!this.isWrapping){var map=this._styleMap[lineIndex];if(!map){return null;}lineIndex=map.line;charIndex=map.offset+charIndex;}return this.callSuper('_getStyleDeclaration',lineIndex,charIndex);},/**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */_setStyleDeclaration:function(lineIndex,charIndex,style){var map=this._styleMap[lineIndex];lineIndex=map.line;charIndex=map.offset+charIndex;this.styles[lineIndex][charIndex]=style;},/**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */_deleteStyleDeclaration:function(lineIndex,charIndex){var map=this._styleMap[lineIndex];lineIndex=map.line;charIndex=map.offset+charIndex;delete this.styles[lineIndex][charIndex];},/**\n     * probably broken need a fix\n     * Returns the real style line that correspond to the wrapped lineIndex line\n     * Used just to verify if the line does exist or not.\n     * @param {Number} lineIndex\n     * @returns {Boolean} if the line exists or not\n     * @private\n     */_getLineStyle:function(lineIndex){var map=this._styleMap[lineIndex];return!!this.styles[map.line];},/**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @param {Object} style\n     * @private\n     */_setLineStyle:function(lineIndex){var map=this._styleMap[lineIndex];this.styles[map.line]={};},/**\n     * Wraps text using the 'width' property of Textbox. First this function\n     * splits text on newlines, so we preserve newlines entered by the user.\n     * Then it wraps each line using the width of the Textbox by calling\n     * _wrapLine().\n     * @param {Array} lines The string array of text that is split into lines\n     * @param {Number} desiredWidth width you want to wrap to\n     * @returns {Array} Array of lines\n     */_wrapText:function(lines,desiredWidth){var wrapped=[],i;this.isWrapping=true;for(i=0;i<lines.length;i++){wrapped=wrapped.concat(this._wrapLine(lines[i],i,desiredWidth));}this.isWrapping=false;return wrapped;},/**\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\n     * it gets called when charBounds are not available yet.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {String} text\n     * @param {number} lineIndex\n     * @param {number} charOffset\n     * @returns {number}\n     * @private\n     */_measureWord:function(word,lineIndex,charOffset){var width=0,prevGrapheme,skipLeft=true;charOffset=charOffset||0;for(var i=0,len=word.length;i<len;i++){var box=this._getGraphemeBox(word[i],lineIndex,i+charOffset,prevGrapheme,skipLeft);width+=box.kernedWidth;prevGrapheme=word[i];}return width;},/**\n     * Wraps a line of text using the width of the Textbox and a context.\n     * @param {Array} line The grapheme array that represent the line\n     * @param {Number} lineIndex\n     * @param {Number} desiredWidth width you want to wrap the line to\n     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities\n     * @returns {Array} Array of line(s) into which the given text is wrapped\n     * to.\n     */_wrapLine:function(_line,lineIndex,desiredWidth,reservedSpace){var lineWidth=0,splitByGrapheme=this.splitByGrapheme,graphemeLines=[],line=[],// spaces in different languages?\nwords=splitByGrapheme?fabric.util.string.graphemeSplit(_line):_line.split(this._wordJoiners),word='',offset=0,infix=splitByGrapheme?'':' ',wordWidth=0,infixWidth=0,largestWordWidth=0,lineJustStarted=true,additionalSpace=this._getWidthOfCharSpacing(),reservedSpace=reservedSpace||0;// fix a difference between split and graphemeSplit\nif(words.length===0){words.push([]);}desiredWidth-=reservedSpace;for(var i=0;i<words.length;i++){// if using splitByGrapheme words are already in graphemes.\nword=splitByGrapheme?words[i]:fabric.util.string.graphemeSplit(words[i]);wordWidth=this._measureWord(word,lineIndex,offset);offset+=word.length;lineWidth+=infixWidth+wordWidth-additionalSpace;if(lineWidth>desiredWidth&&!lineJustStarted){graphemeLines.push(line);line=[];lineWidth=wordWidth;lineJustStarted=true;}else{lineWidth+=additionalSpace;}if(!lineJustStarted&&!splitByGrapheme){line.push(infix);}line=line.concat(word);infixWidth=splitByGrapheme?0:this._measureWord([infix],lineIndex,offset);offset++;lineJustStarted=false;// keep track of largest word\nif(wordWidth>largestWordWidth){largestWordWidth=wordWidth;}}i&&graphemeLines.push(line);if(largestWordWidth+reservedSpace>this.dynamicMinWidth){this.dynamicMinWidth=largestWordWidth-additionalSpace+reservedSpace;}return graphemeLines;},/**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @param {Number} lineIndex text to split\n     * @return {Boolean}\n     */isEndOfWrapping:function(lineIndex){if(!this._styleMap[lineIndex+1]){// is last line, return true;\nreturn true;}if(this._styleMap[lineIndex+1].line!==this._styleMap[lineIndex].line){// this is last line before a line break, return true;\nreturn true;}return false;},/**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * @return Number\n     */missingNewlineOffset:function(lineIndex){if(this.splitByGrapheme){return this.isEndOfWrapping(lineIndex)?1:0;}return 1;},/**\n    * Gets lines of text to render in the Textbox. This function calculates\n    * text wrapping on the fly every time it is called.\n    * @param {String} text text to split\n    * @returns {Array} Array of lines in the Textbox.\n    * @override\n    */_splitTextIntoLines:function(text){var newText=fabric.Text.prototype._splitTextIntoLines.call(this,text),graphemeLines=this._wrapText(newText.lines,this.width),lines=new Array(graphemeLines.length);for(var i=0;i<graphemeLines.length;i++){lines[i]=graphemeLines[i].join('');}newText.lines=lines;newText.graphemeLines=graphemeLines;return newText;},getMinWidth:function(){return Math.max(this.minWidth,this.dynamicMinWidth);},_removeExtraneousStyles:function(){var linesToKeep={};for(var prop in this._styleMap){if(this._textLines[prop]){linesToKeep[this._styleMap[prop].line]=1;}}for(var prop in this.styles){if(!linesToKeep[prop]){delete this.styles[prop];}}},/**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */toObject:function(propertiesToInclude){return this.callSuper('toObject',['minWidth','splitByGrapheme'].concat(propertiesToInclude));}});/**\n   * Returns fabric.Textbox instance from an object representation\n   * @static\n   * @memberOf fabric.Textbox\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created\n   */fabric.Textbox.fromObject=function(object,callback){return fabric.Object._fromObject('Textbox',object,callback,'text');};})( true?exports:0);(function(){var controlsUtils=fabric.controlsUtils,scaleSkewStyleHandler=controlsUtils.scaleSkewCursorStyleHandler,scaleStyleHandler=controlsUtils.scaleCursorStyleHandler,scalingEqually=controlsUtils.scalingEqually,scalingYOrSkewingX=controlsUtils.scalingYOrSkewingX,scalingXOrSkewingY=controlsUtils.scalingXOrSkewingY,scaleOrSkewActionName=controlsUtils.scaleOrSkewActionName,objectControls=fabric.Object.prototype.controls;objectControls.ml=new fabric.Control({x:-0.5,y:0,cursorStyleHandler:scaleSkewStyleHandler,actionHandler:scalingXOrSkewingY,getActionName:scaleOrSkewActionName});objectControls.mr=new fabric.Control({x:0.5,y:0,cursorStyleHandler:scaleSkewStyleHandler,actionHandler:scalingXOrSkewingY,getActionName:scaleOrSkewActionName});objectControls.mb=new fabric.Control({x:0,y:0.5,cursorStyleHandler:scaleSkewStyleHandler,actionHandler:scalingYOrSkewingX,getActionName:scaleOrSkewActionName});objectControls.mt=new fabric.Control({x:0,y:-0.5,cursorStyleHandler:scaleSkewStyleHandler,actionHandler:scalingYOrSkewingX,getActionName:scaleOrSkewActionName});objectControls.tl=new fabric.Control({x:-0.5,y:-0.5,cursorStyleHandler:scaleStyleHandler,actionHandler:scalingEqually});objectControls.tr=new fabric.Control({x:0.5,y:-0.5,cursorStyleHandler:scaleStyleHandler,actionHandler:scalingEqually});objectControls.bl=new fabric.Control({x:-0.5,y:0.5,cursorStyleHandler:scaleStyleHandler,actionHandler:scalingEqually});objectControls.br=new fabric.Control({x:0.5,y:0.5,cursorStyleHandler:scaleStyleHandler,actionHandler:scalingEqually});objectControls.mtr=new fabric.Control({x:0,y:-0.5,actionHandler:controlsUtils.rotationWithSnapping,cursorStyleHandler:controlsUtils.rotationStyleHandler,offsetY:-40,withConnection:true,actionName:'rotate'});if(fabric.Textbox){// this is breaking the prototype inheritance, no time / ideas to fix it.\n// is important to document that if you want to have all objects to have a\n// specific custom control, you have to add it to Object prototype and to Textbox\n// prototype. The controls are shared as references. So changes to control `tr`\n// can still apply to all objects if needed.\nvar textBoxControls=fabric.Textbox.prototype.controls={};textBoxControls.mtr=objectControls.mtr;textBoxControls.tr=objectControls.tr;textBoxControls.br=objectControls.br;textBoxControls.tl=objectControls.tl;textBoxControls.bl=objectControls.bl;textBoxControls.mt=objectControls.mt;textBoxControls.mb=objectControls.mb;textBoxControls.mr=new fabric.Control({x:0.5,y:0,actionHandler:controlsUtils.changeWidth,cursorStyleHandler:scaleSkewStyleHandler,actionName:'resizing'});textBoxControls.ml=new fabric.Control({x:-0.5,y:0,actionHandler:controlsUtils.changeWidth,cursorStyleHandler:scaleSkewStyleHandler,actionName:'resizing'});}})();\n\n//# sourceURL=webpack://note/./node_modules/fabric/dist/fabric.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fabric */ \"./node_modules/fabric/dist/fabric.js\");\n/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fabric__WEBPACK_IMPORTED_MODULE_0__);\n\nlet canvas = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Canvas('c');\ncanvas.freeDrawingBrush = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.CrayonBrush(canvas, {\n  width: 70,\n  opacity: 0.6,\n  color: \"#ff0000\"\n});\n\n//# sourceURL=webpack://note/./src/index.js?");

/***/ }),

/***/ "?7b10":
/*!***********************!*\
  !*** jsdom (ignored) ***!
  \***********************/
/***/ (function() {

eval("/* (ignored) */\n\n//# sourceURL=webpack://note/jsdom_(ignored)?");

/***/ }),

/***/ "?6799":
/*!********************************************************!*\
  !*** jsdom/lib/jsdom/living/generated/utils (ignored) ***!
  \********************************************************/
/***/ (function() {

eval("/* (ignored) */\n\n//# sourceURL=webpack://note/jsdom/lib/jsdom/living/generated/utils_(ignored)?");

/***/ }),

/***/ "?9748":
/*!***************************************!*\
  !*** jsdom/lib/jsdom/utils (ignored) ***!
  \***************************************/
/***/ (function() {

eval("/* (ignored) */\n\n//# sourceURL=webpack://note/jsdom/lib/jsdom/utils_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;